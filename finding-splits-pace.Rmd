```{r cache = T, echo = F, message=F}
knitr::opts_chunk$set(error = TRUE)
knitr::opts_chunk$set(fig.path = "images/finding-splits-pace-")
```
# Visualising Pace Across Splits

We have already seen how we can perform pace calculations on stage level data and use pace maps and off-the-pace charts to visualise pace over the course of a rally.

But in WRC rallies at least, the stages are often long enough, and the promoter well resourced enough, to merit the collection of split data data at various split points along a stage. So in this chapter, we'll review how we can create pace charts and apply the techniques to plotting progress *within* a stage, across stage splits.

## Load Base Data

As ever, load in the helper functions:

```{r message=F, warning=F}
source('code/wrc-api.R')
source('code/wrc-wrangling.R')
source('code/wrc-charts.R')
```

And get the base data:

```{r}
s = get_active_season()
eventId = get_eventId_from_name(s, 'arctic')

itinerary = get_itinerary(eventId)
sections = get_sections(itinerary)
stages = get_stages(sections)
stages_lookup = get_stages_lookup(stages)

# Quick Lookups
stage_list = get_stage_list(stages)
stage_codes = stages$code

# Driver details
entries = get_rally_entries(eventId)
cars = get_car_data(entries)
```

Get a sample stage ID and associated splits:

```{r}
# Get example stage ID
stageId = stages_lookup[['SS3']]

# Get splits for the stage
splits = get_splits(eventId, stageId)
splits_locations = get_split_locations(splits)
splits_list = splits_locations$splitPointId

# Get wide format data
splits_wide = get_splits_wide(splits) %>%
                relabel_times_df(stage_list, cars)
```

Get long form splits data for one or more stages:

```{r}
splits_long = get_multi_split_times(stageId)
```

### Obtaining Split Distances

We can find the distance between each split as the difference between consecutive values. Let's augment the *splits_locations* with these values as well as with section start distances:

```{r}
splits_locations$start_dist = lag(splits_locations$distance,
                                  default=0)

splits_locations$section_dist = c(splits_locations$distance[1],
                                  diff(splits_locations$distance))

splits_locations
```

We can also retrieve these section distances into a *splitPointId* named list:

```{r}
split_distances = splits_locations$section_dist

# Label the values
names(split_distances) = splits_locations$splitPointId
  
split_distances
```

We recall that the split points do not include the final timing line (the finish), so a complete set of distances also means we neeed to access the overall stage distance and account for that:

```{r}
stage_dist = stages[stages['stageId']==stageId,'distance']
stage_dist
```

The complete set of intermediate distances is then:

```{r}
full_split_distances = c(split_distances, stage_dist-sum(split_distances))

names(full_split_distances) = c(names(split_distances), 'total')
  
full_split_distances
```

## Calculating Splits Pace

To calculate pace between two split points we need to get the elapsed time between those two points as well as the distance between split points.

We can obtain the split differences by finding differences between the columns of the wide format dataframe using the `get_split_duration()` function we created previously:

```{r}
split_cols = get_split_cols(splits)

split_durations_wide = get_split_duration(splits_wide, split_cols,
                                          idcol='code')

split_durations_wide %>% head(3)
```

We can then find the pace by dividing the split section times through by the split distances:

```{r}
split_pace_wide = split_durations_wide

for (s in splits_list) {
  s_ = as.character(s)
  split_pace_wide[,s_] = split_pace_wide[,s_] / split_distances[s_]
                            
}

split_pace_wide %>% head(2)
```

## Visualising the Splits Pace

To visualise the pace over each of the split sections, we can use exactly the same techaniques that we used to visualise the stage pace, including pace maps and off-the-pace charts.

### Splits Sections Pace Maps

To generate the pace map, let's first rebase the split times with respect to a specified driver:

```{r}
example_driver = split_pace_wide[2,]$code

split_pace_wide_rebased = rebase(split_pace_wide, example_driver,
                           splits_list,
                           id_col='code')

split_pace_wide_rebased %>% head(3)
```

To plot the pace map, we need to get the data into a long format:

```{r}
split_pace_long_rebased = split_pace_wide_rebased %>% 
                  head(10) %>%
                gather(splitPointId, pace,
                       as.character(splits_list)) %>%
                merge(splits_locations[,c('splitPointId',
                                          'start_dist', 'distance')],
                          by='splitPointId')

split_pace_long_rebased %>% head()
```

We can now view the rebased pace over the splits:

```{r example_pace_splits, warning=FALSE}
split_pace_long_rebased %>%
    pace_map( xstart='start_dist',
         drivers=c('KAT','ROV'),
         xend='distance', idcol='code', lines=FALSE, label_dodge=2)
```

We might also want to compare actual pace across the splits. One way of doing that is to co--pt the off-the-pace chart:

```{r pace-over-splits, warning=FALSE}
split_pace_long = split_pace_wide %>% 
                  head(10) %>%
                gather(splitPointId, pace,
                       as.character(splits_list)) %>%
                merge(splits_locations[,c('splitPointId',
                                          'start_dist', 'distance')],
                          by='splitPointId')


split_pace_long %>% 
    off_the_pace_chart(dist='distance', t='pace',
                              code='code', ylim=NULL)
```

### Off-the-Pace Splits Pace Mapping

To review the off-the-pace performance over the splits on a stage, we can reuse the off-the-pace chart function.

At the start of the chart, let's add some zeroed values:

```{r}
zero_df = data.frame(code=unique(split_pace_long_rebased$code))
zero_df$start_dist = 0
zero_df$distance = 0
zero_df$pace=0
zero_df$splitPointId = 'Split_0'
```

Let's see how our sample rebased times look:

```{r off-the-pace-splits-rebased, warning=FALSE, message=FALSE}
 bind_rows(split_pace_long_rebased, zero_df) %>% 
    off_the_pace_chart(dist='distance', t='pace', label_typ='ggrepel',
                              code='code', ylim=NULL)
```

There is currently something very wrong with the labeling; add that to the TO DO list!

