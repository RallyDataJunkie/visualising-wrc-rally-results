[["index.html", "Visualising WRC Rally Timing and Results Data A RallyDataJunkie Adventure Index", " Visualising WRC Rally Timing and Results Data A RallyDataJunkie Adventure Tony Hirst Index "],["introduction.html", "1 Introduction", " 1 Introduction For fans of WRC, the live timing data screens as well as results from ewrc-results.com provide up-to-date information about timing and results over the course of an event weekend, as well as a historical results for the current season (WRC) as well as back into the mists of time (ewrc-results). In this recipe collection, I’ll describe various ways of visualising WRC rally results and timing data using data retrieved from the WRC results API. Many of the techniques should also apply directly to data retrieved from other services, such as ewrc-results.com if the data is appropriately represented. "],["accessing-data-from-the-wrc-live-timing-api.html", "2 Accessing Data from the WRC Live Timing API 2.1 Current Season Rallies 2.2 Itinerary Lookup 2.3 Competitor Details 2.4 Penalties and Retirements 2.5 Results and Stage Winner 2.6 Stage Result 2.7 Stage Times 2.8 Split Times", " 2 Accessing Data from the WRC Live Timing API We can get rally details, timing and results data from the WRC live timing service JSON API. 2.1 Current Season Rallies To start with, let’s see what rallies are scheduled for the current, active season. The jsonlite::fromJSON() will retrieve a JSON (JavaScript Object Notation) file from a URL and attempt to unpack it into an R dataframe: library(jsonlite) library(stringr) library(dplyr) season_url = &quot;https://api.wrc.com/contel-page/83388/calendar/active-season/&quot; get_active_season = function(active_season_url=season_url) { jsonlite::fromJSON(active_season_url)$rallyEvents$items } s = get_active_season() # Preview the column names of the resulting dataframe colnames(s) ## [1] &quot;id&quot; &quot;name&quot; &quot;active&quot; &quot;jwrc&quot; &quot;deleted&quot; ## [6] &quot;rally&quot; &quot;status&quot; &quot;pageInfo&quot; &quot;pageResult&quot; &quot;eventDays&quot; ## [11] &quot;winner&quot; Let’s preview the contents of a couple of those columns: # The tidyr / magrittr pipe syntax makes things easier to read s %&gt;% select(c(&#39;id&#39;, &#39;name&#39;)) %&gt;% head() ## id name ## 1 1695 WRC Rallye Monte-Carlo ## 2 1745 WRC Arctic Rally Finland Powered by CapitalBox ## 3 1696 WRC Croatia Rally ## 4 1698 WRC Vodafone Rally de Portugal ## 5 1704 WRC Rally Italia Sardegna ## 6 1709 WRC Safari Rally Kenya We can search the name column to find the unique identifier value for a particular event: eventId = s[s[&#39;name&#39;]==&#39;WRC Arctic Rally Finland Powered by CapitalBox&#39;,&#39;id&#39;] eventId ## [1] 1745 Or we can be more generic with a regular expression lookup: get_eventId_from_name = function(season, name){ season[str_detect(season$name, regex(name, ignore_case = T)), &#39;id&#39;] } get_eventId_from_name(s, &#39;arctic&#39;) ## [1] 1745 2.2 Itinerary Lookup We can make another call to the WRC API to look up the itinerary for the event. Each leg of the event corresponds to a particular day: results_api = &#39;https://api.wrc.com/results-api&#39; get_itinerary = function(eventId) { jsonlite::fromJSON(paste0(results_api,&quot;/rally-event/&quot;, eventId, &quot;/itinerary&quot;))$itineraryLegs } itinerary = get_itinerary(eventId) itinerary %&gt;% select(-itinerarySections) ## itineraryLegId itineraryId startListId name legDate ## 1 320 266 523 Friday 26th February 2021-02-26 ## 2 319 266 524 Saturday 27th February 2021-02-27 ## 3 318 266 525 Sunday 28th February 2021-02-28 ## order status ## 1 1 Completed ## 2 2 Completed ## 3 3 Running The itinerarySections columns dataframes describing details of each leg. 2.2.1 Leg Sections Within each leg, the itinerary provides information about each section (that is, each “loop”) of the rally. This information is retrieved in form of a dataframe in a standard format. We can use the base R do.call() to call the rbind() function against each row of the dataframe and bind all the dataframes in a specified column into a single dataframe: get_sections = function(itinerary){ sections = do.call(rbind, itinerary$itinerarySections) sections } sections = get_sections(itinerary) sections %&gt;% select(-c(controls, stages)) ## itinerarySectionId itineraryLegId order name ## 1 733 320 1 Section 1 ## 2 734 320 2 Section 2 ## 3 735 319 3 Section 3 ## 4 736 319 4 Section 4 ## 5 737 318 5 Section 5 ## 6 738 318 6 Section 6 In the sections dataframe we have one row per section. Two of the columns, `controls and stages each use dataframes to “nest” subdataframes within each row. For example, here’s one of the controls dataframes that describes timing controls: sections$controls[[1]] ## controlId eventId stageId type code location ## 1 7527 170 NA TimeControl TC0 Start ( Santasport, Rovaniemi ) ## 2 7564 170 1747 TimeControl TC1 Sarriojärvi ## 3 7563 170 1747 StageStart SS1 Sarriojärvi 1 (Live TV) ## 4 7562 170 1747 FlyingFinish SF1 Sarriojärvi 1 (Live TV) ## 5 7531 170 NA RegroupIn TC1A Regroup IN ## timingPrecision distance targetDuration targetDurationMs firstCarDueDateTime ## 1 Minute NA &lt;NA&gt; NA 2021-02-26T11:30:00 ## 2 Minute 77.79 01:32:00 5520000 2021-02-26T13:02:00 ## 3 Minute 31.05 00:06:00 360000 2021-02-26T13:08:00 ## 4 Tenth NA &lt;NA&gt; NA &lt;NA&gt; ## 5 Minute 31.57 01:20:00 4800000 2021-02-26T14:28:00 ## firstCarDueDateTimeLocal status controlPenalties roundingPolicy ## 1 2021-02-26T13:30:00+02:00 Completed All NoRounding ## 2 2021-02-26T15:02:00+02:00 Completed All NoRounding ## 3 2021-02-26T15:08:00+02:00 Completed None RoundToClosestMinute ## 4 &lt;NA&gt; Completed None NoRounding ## 5 2021-02-26T16:28:00+02:00 Completed All NoRounding ## locked ## 1 TRUE ## 2 TRUE ## 3 TRUE ## 4 TRUE ## 5 TRUE And an example of a dataframe from the first row of the stages column: sections$stages[[1]] ## stageId eventId number name distance status ## 1 1747 170 1 Sarriojärvi 1 (Live TV) 31.05 Completed ## stageType timingPrecision locked code ## 1 SpecialStage Tenth TRUE SS1 2.2.2 Time Controls We can look up information about each time control from data provided as part of the itinerary lookup using the same trick as before to “unroll” the contents of each dataframe in a specified column into a single dataframe. An alternative to the do.call() approach is to use a tidy approach and use the dplyr::bind_rows() function on the sections$controls column values via a pipe. We can add a reference to the original section ID by naming each row in the controls column with the itinerarySectionId value and then ensuring an identifier column is defined when we bind the dataframes: get_controls = function(sections){ # Name each row in the list of dataframes we want to bind names(sections$controls) = sections$itinerarySectionId controls = sections$controls %&gt;% # Ensure that we create an identifier column (uses list names) bind_rows(.id=&#39;itinerarySectionId&#39;) controls } controls = get_controls(sections) controls %&gt;% head(2) ## itinerarySectionId controlId eventId stageId type code ## 1 733 7527 170 NA TimeControl TC0 ## 2 733 7564 170 1747 TimeControl TC1 ## location timingPrecision distance targetDuration ## 1 Start ( Santasport, Rovaniemi ) Minute NA &lt;NA&gt; ## 2 Sarriojärvi Minute 77.79 01:32:00 ## targetDurationMs firstCarDueDateTime firstCarDueDateTimeLocal status ## 1 NA 2021-02-26T11:30:00 2021-02-26T13:30:00+02:00 Completed ## 2 5520000 2021-02-26T13:02:00 2021-02-26T15:02:00+02:00 Completed ## controlPenalties roundingPolicy locked ## 1 All NoRounding TRUE ## 2 All NoRounding TRUE 2.2.3 Stage Details We can pull stage details from the dataframes contained in the sections dataframe from the itinerary lookup: get_stages = function(sections){ # Name each row in the list of dataframes we want to bind names(sections$stages) = sections$itinerarySectionId stages = sections$stages %&gt;% # Ensure that we create an identifier column (uses list names) bind_rows(.id=&#39;itinerarySectionId&#39;) stages } stages = get_stages(sections) stages %&gt;% head() ## itinerarySectionId stageId eventId number name distance ## 1 733 1747 170 1 Sarriojärvi 1 (Live TV) 31.05 ## 2 734 1743 170 2 Sarriojärvi 2 (Live TV) 31.05 ## 3 735 1750 170 3 Mustalampi 1 24.43 ## 4 735 1751 170 4 Kaihuavaara 1 (Live TV) 19.91 ## 5 735 1748 170 5 Siikakämä 1 27.68 ## 6 736 1745 170 6 Mustalampi 2 24.43 ## status stageType timingPrecision locked code ## 1 Completed SpecialStage Tenth TRUE SS1 ## 2 Completed SpecialStage Tenth TRUE SS2 ## 3 Completed SpecialStage Tenth TRUE SS3 ## 4 Completed SpecialStage Tenth TRUE SS4 ## 5 Completed SpecialStage Tenth TRUE SS5 ## 6 Completed SpecialStage Tenth TRUE SS6 We can get a list of stage IDs from the stageId column (stages$stageId): get_stage_list = function(stages){ stage_list = stages$stageId stage_list } get_stage_list(stages) ## [1] 1747 1743 1750 1751 1748 1745 1744 1742 1746 1749 Perhaps more conveniently, we can create a lookup from code to stage ID: # https://stackoverflow.com/a/19265431/454773 get_stages_lookup = function(stages, fromCol=&#39;code&#39;, toCol=&#39;stageId&#39;){ stages_lookup = stages[[toCol]] names(stages_lookup) = stages[[fromCol]] stages_lookup } stages_lookup = get_stages_lookup(stages) stages_lookup ## SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 ## 1747 1743 1750 1751 1748 1745 1744 1742 1746 1749 # Lookup particular stage ID by stage code #stages_lookup[[&#39;SS2&#39;]] From the stages table, we can get the identifier for a particular stage, either by code (for example, “SS3”) or by (partial) name match: ssnum = &#39;SS3&#39; get_stage_id = function(stages, sname, typ=&#39;code&#39;){ # code, name if (typ==&#39;code&#39;) stageId = stages[stages[typ] == sname, &#39;stageId&#39;] else stageId = stages[stringr::str_detect(stages[[typ]], sname), &#39;stageId&#39;] stageId } stageId = get_stage_id(stages, &#39;Mustalampi 1&#39;, &#39;name&#39;) stageId ## [1] 1750 And the stage distance and name: get_stage_info = function(stages, sid, typ=&#39;stageId&#39;, clean=TRUE){ # stageId, code name=stages[stages[typ] == sid, &#39;name&#39;] distance=stages[stages[typ] == sid, &#39;distance&#39;] if (clean) stringr::str_replace(name, &#39; (Live TV)&#39;, &#39;&#39;) c(name=name, distance=distance) } get_stage_info(stages, stageId) ## name distance ## &quot;Mustalampi 1&quot; &quot;24.43&quot; 2.2.4 Road Order Start Lists The startListId can be used alongside the event ID to look up the startlist for a leg. We can order the startlist by start order: get_startlist = function(eventId, startListId) { startlist_url = paste0(results_api, &#39;/rally-event/&#39;, eventId,&#39;/start-list-external/&#39;, startListId) startlist = jsonlite::fromJSON(startlist_url)$startListItems # Order the startlist dataframe by start order startlist %&gt;% arrange(order) } # Example startlist ID # Use a regular expression to find the startlist ID by day startListId = itinerary[str_detect(itinerary$name, regex(&#39;Friday&#39;, ignore_case = T)), &#39;startListId&#39;] startlist = get_startlist(eventId, startListId) startlist %&gt;% head() ## startListItemId startListId entryId startDateTime ## 1 24435 523 21530 2021-02-26T11:30:00 ## 2 24409 523 21531 2021-02-26T11:33:00 ## 3 24410 523 21532 2021-02-26T11:36:00 ## 4 24411 523 21533 2021-02-26T11:39:00 ## 5 24412 523 21534 2021-02-26T11:42:00 ## 6 24413 523 21535 2021-02-26T11:45:00 ## startDateTimeLocal order ## 1 2021-02-26T13:30:00+02:00 1 ## 2 2021-02-26T13:33:00+02:00 2 ## 3 2021-02-26T13:36:00+02:00 3 ## 4 2021-02-26T13:39:00+02:00 4 ## 5 2021-02-26T13:42:00+02:00 5 ## 6 2021-02-26T13:45:00+02:00 6 Looking up a startlist ID is a little fiddly: get_startlist_id = function(itinerary, itinerarySectionId){ sections = get_sections(itinerary) itineraryLegId = sections[sections$itinerarySectionId==itinerarySectionId, &#39;itineraryLegId&#39;] itinerary[itinerary$itineraryLegId==itineraryLegId,&#39;startListId&#39;] } get_startlist_id(itinerary, stages$itinerarySectionId[[1]]) ## [1] 523 2.3 Competitor Details Details of car entries for each event can be retrieved from the WRC live timing API given an event ID. get_rally_entries = function(eventId) { cars_url = paste0(results_api, &#39;/rally-event/&#39;, eventId,&#39;/cars&#39;) jsonlite::fromJSON(cars_url) } entries = get_rally_entries(eventId) # $driver, $codriver, $manufacturer, $entrant, $group, $eventClasses # $identifier, $vehicleModel, $eligibility, $status entries %&gt;% head(2) ## driver.personId driver.countryId driver.country.countryId ## 1 670 76 76 ## 2 534 235 235 ## driver.country.name driver.country.iso2 ## 1 France FR ## 2 United Kingdom of Great Britain and Northern Ireland GB ## driver.country.iso3 driver.firstName driver.lastName driver.abbvName ## 1 FRA Sébastien OGIER S. OGIER ## 2 GBR Elfyn EVANS E. EVANS ## driver.fullName driver.code codriver.personId codriver.countryId ## 1 Sébastien OGIER OGI 3027 76 ## 2 Elfyn EVANS EVA 553 235 ## codriver.country.countryId ## 1 76 ## 2 235 ## codriver.country.name codriver.country.iso2 ## 1 France FR ## 2 United Kingdom of Great Britain and Northern Ireland GB ## codriver.country.iso3 codriver.firstName codriver.lastName codriver.abbvName ## 1 FRA Julien INGRASSIA J. INGRASSIA ## 2 GBR Scott MARTIN S. MARTIN ## codriver.fullName codriver.code manufacturer.manufacturerId manufacturer.name ## 1 Julien INGRASSIA ING 84 Toyota ## 2 Scott MARTIN MAR 84 Toyota ## manufacturer.logoFilename entrant.entrantId entrant.name ## 1 toyota 91 TOYOTA GAZOO RACING WRT ## 2 toyota 91 TOYOTA GAZOO RACING WRT ## entrant.logoFilename group.groupId group.name eventClasses tags entryId ## 1 &lt;NA&gt; 10 WRC 640, 170, RC1 NULL 21530 ## 2 &lt;NA&gt; 10 WRC 640, 170, RC1 NULL 21531 ## eventId driverId codriverId manufacturerId entrantId groupId entryListOrder ## 1 170 670 3027 84 91 10 1 ## 2 170 534 553 84 91 10 2 ## identifier vehicleModel eligibility priority status tyreManufacturer ## 1 1 Yaris WRC M P1 Rejoined None ## 2 33 Yaris WRC M P1 Entry None 2.3.1 Looking Up Entries by Group We can index the entries by group to find all the WRC car entryId values: entries[entries$group$name==&#39;WRC&#39;, &#39;entryId&#39;] ## [1] 21530 21531 21532 21533 21534 21535 21536 21537 21538 21539 21540 21541 ## [13] 21542 2.3.2 Driver &amp; Codriver Details Detailed information for each driver and codriver can be found in the corresponding sub-dataframes. For example, we can look up the details for each driver, noting in this case that we need to column bind (cbind()) the subdataframes to produce the collated dataframe of driver details: get_drivers = function(entries){ drivers = do.call(cbind, entries$driver) drivers } drivers = get_drivers(entries) drivers %&gt;% head(2) ## personId countryId country.countryId ## 1 670 76 76 ## 2 534 235 235 ## country.name country.iso2 ## 1 France FR ## 2 United Kingdom of Great Britain and Northern Ireland GB ## country.iso3 firstName lastName abbvName fullName code ## 1 FRA Sébastien OGIER S. OGIER Sébastien OGIER OGI ## 2 GBR Elfyn EVANS E. EVANS Elfyn EVANS EVA We can similarly obtain data for the codrivers: #codrivers = do.call(cbind, entries$codriver) # Again, there is a tidyverse approach with dplyr::bind_cols() get_codrivers = function(entries){ codrivers = bind_cols(entries$codriver) codrivers } codrivers = get_codrivers(entries) codrivers %&gt;% head(2) ## personId countryId country.countryId ## 1 3027 76 76 ## 2 553 235 235 ## country.name country.iso2 ## 1 France FR ## 2 United Kingdom of Great Britain and Northern Ireland GB ## country.iso3 firstName lastName abbvName fullName code ## 1 FRA Julien INGRASSIA J. INGRASSIA Julien INGRASSIA ING ## 2 GBR Scott MARTIN S. MARTIN Scott MARTIN MAR We can conveniently obtain the identifier for a particular driver or codriver by searching against their name or three letter code, although note that the three letter code may not be a unique identifier: get_person_id = function(persons, sname, typ=&#39;fullName&#39;){ # code, fullName if (typ==&#39;code&#39;) personsId = persons[persons[typ]==sname, &#39;personId&#39;] else personId = persons[str_detect(persons[[typ]], regex(sname, ignore_case = T)), &#39;personId&#39;] personId } ogierDriverId = get_person_id(drivers, &#39;ogier&#39;) ogierDriverId ## [1] 670 From the driver person identifier we can get the entry identifier for the rally we’re exploring: ogierEntryId = entries[entries[&#39;driverId&#39;]==ogierDriverId, &#39;entryId&#39;] ogierEntryId ## [1] 21530 2.3.3 Summarising Essential Entry Data We can manually create a dataframe containing essential fields from the original cars dataframe and the dataframes contained within it: get_car_data = function(entries){ cols = c(&#39;entryId&#39;, &#39;driverId&#39;, &#39;codriverId&#39;,&#39;manufacturerId&#39;, &#39;vehicleModel&#39;,&#39;eligibility&#39;, &#39;classname&#39;,&#39;manufacturer&#39;, &#39;entrantname&#39;, &#39;groupname&#39;, &#39;drivername&#39;, &#39;code&#39;, &#39;driverfullname&#39;, &#39;codrivername&#39;,&#39;codriverfullname&#39; ) entries = entries %&gt;% rowwise() %&gt;% mutate(classname = eventClasses$name) %&gt;% mutate(manufacturer = manufacturer$name) %&gt;% mutate(entrantname = entrant$name) %&gt;% mutate(groupname = group$name) %&gt;% mutate(drivername = driver$abbvName) %&gt;% mutate(driverfullname = driver$fullName) %&gt;% mutate(codrivername = codriver$abbvName) %&gt;% mutate(codriverfullname = codriver$fullName) %&gt;% mutate(code = driver$code) %&gt;% select(all_of(cols)) # If we don&#39;t cast, it&#39;s a non-rankable rowwise df as.data.frame(entries) } get_car_data(entries) %&gt;% head(2) ## entryId driverId codriverId manufacturerId vehicleModel eligibility classname ## 1 21530 670 3027 84 Yaris WRC M RC1 ## 2 21531 534 553 84 Yaris WRC M RC1 ## manufacturer entrantname groupname drivername code ## 1 Toyota TOYOTA GAZOO RACING WRT WRC S. OGIER OGI ## 2 Toyota TOYOTA GAZOO RACING WRT WRC E. EVANS EVA ## driverfullname codrivername codriverfullname ## 1 Sébastien OGIER J. INGRASSIA Julien INGRASSIA ## 2 Elfyn EVANS S. MARTIN Scott MARTIN 2.4 Penalties and Retirements We can look up penalties from an event ID: get_penalties = function(eventId) { penalties_url = paste0(results_api, &#39;/rally-event/&#39;, eventId, &#39;/penalties&#39;) jsonlite::fromJSON(penalties_url) } get_penalties(eventId) %&gt;% head(2) ## penaltyId controlId entryId penaltyDurationMs penaltyDuration reason ## 1 959 7546 21559 10000 PT10S 1 MIN LATE ## 2 956 7533 21568 10000 PT10S 1 MIN LATE The event ID is also all we need to request a list of retirements: get_retirements = function(eventId) { retirements_url = paste0(results_api, &#39;/rally-event/&#39;, eventId, &#39;/retirements&#39;) jsonlite::fromJSON(retirements_url) } get_retirements(eventId) %&gt;% head(2) ## retirementId controlId entryId reason retirementDateTime ## 1 1802 7562 21547 MECHANICAL 2021-02-26T14:50:00 ## 2 1803 7556 21542 OFF ROAD 2021-02-27T08:01:00 ## retirementDateTimeLocal status ## 1 0001-01-01T00:00:00+00:00 Permanent ## 2 0001-01-01T00:00:00+00:00 Temporary 2.5 Results and Stage Winner As well as retrieving penalties and retirements using just the event ID as a key, we can also retrieve the overall results and the stage winners: get_result = function(eventId) { result_url = paste0(results_api, &#39;/rally-event/&#39;, eventId,&#39;/result&#39;) jsonlite::fromJSON(result_url) } get_result(eventId) %&gt;% head(2) ## entryId stageTimeMs stageTime penaltyTimeMs penaltyTime totalTimeMs ## 1 21536 7429600 PT2H3M49.6S 0 PT0S 7429600 ## 2 21533 7447100 PT2H4M7.1S 0 PT0S 7447100 ## totalTime position diffFirstMs diffFirst diffPrevMs diffPrev ## 1 PT2H3M49.6S 1 0 PT0S 0 PT0S ## 2 PT2H4M7.1S 2 17500 PT17.5S 17500 PT17.5S And for the stage winners: get_stage_winners = function(eventId) { stage_winners_url = paste0(results_api, &#39;/rally-event/&#39;, eventId,&#39;/stage-winners&#39;) jsonlite::fromJSON(stage_winners_url) } get_stage_winners(eventId) %&gt;% head(2) ## stageId entryId stageName elapsedDurationMs elapsedDuration ## 1 1747 21536 Sarriojärvi 1 (Live TV) 957800 00:15:57.8000000 ## 2 1743 21536 Sarriojärvi 2 (Live TV) 952900 00:15:52.9000000 2.6 Stage Result At the end of each stage, there are actually two different sorts of results data are available: data relating to the result of the stage itself, and data relating to how the stage result affected the overall rally position. Let’s start by getting the overall rally result at the end of a particular stage. Note that the overall result does not include the stage ID in the returned data so we need to add it in: get_overall_result = function(eventId, stageId) { overall_url = paste0(results_api, &#39;/rally-event/&#39;, eventId, &#39;/stage-result/stage-external/&#39;, stageId) jsonlite::fromJSON(overall_url) %&gt;% # Also add in the stage ID mutate(stageId = stageId) } overall_result = get_overall_result(eventId, stageId) overall_result %&gt;% head(2) ## entryId stageTimeMs stageTime penaltyTimeMs penaltyTime totalTimeMs ## 1 21536 2745200 PT45M45.2S 0 PT0S 2745200 ## 2 21538 2768800 PT46M8.8S 0 PT0S 2768800 ## totalTime position diffFirstMs diffFirst diffPrevMs diffPrev stageId ## 1 PT45M45.2S 1 0 PT0S 0 PT0S 1750 ## 2 PT46M8.8S 2 23600 PT23.6S 23600 PT23.6S 1750 2.6.1 Getting Stage Results for Multiple Stages It will be convenient to be able to retrieve overall results for multiple stages from one function call. One way of achieving that is to create a function to retrieve the details for a single specified stage that can be applied via a purrr::map() function call to a list of the stage IDs we want overall results data for: library(purrr) ## ## Attaching package: &#39;purrr&#39; ## The following object is masked from &#39;package:jsonlite&#39;: ## ## flatten get_overall_result2 = function(stageId, eventId) { get_overall_result(eventId, stageId) } get_multi_overall = function(stage_list){ multi_overall = stage_list %&gt;% map(get_overall_result2, eventId=eventId) %&gt;% bind_rows() multi_overall } # Specify the stage IDs for multiple stages stage_list = c(1747, 1743) multi_overall_results = get_multi_overall(stage_list) multi_overall_results %&gt;% tail(2) ## entryId stageTimeMs stageTime penaltyTimeMs penaltyTime totalTimeMs ## 107 21579 2866500 PT47M46.5S 0 PT0S 2866500 ## 108 21573 3115400 PT51M55.4S 0 PT0S 3115400 ## totalTime position diffFirstMs diffFirst diffPrevMs diffPrev stageId ## 107 PT47M46.5S 53 955800 PT15M55.8S 123200 PT2M3.2S 1743 ## 108 PT51M55.4S 54 1204700 PT20M4.7S 248900 PT4M8.9S 1743 2.7 Stage Times We can get the stage times for each stage on a rally by event and stage ID: get_stage_times = function(eventId, stageId) { stage_times_url = paste0(results_api, &#39;/rally-event/&#39;, eventId, &#39;/stage-times/stage-external/&#39;, stageId) jsonlite::fromJSON(stage_times_url) } stage_times = get_stage_times(eventId, stageId) stage_times %&gt;% head(2) ## stageTimeId stageId entryId elapsedDurationMs elapsedDuration status ## 1 96580 1750 21536 834500 00:13:54.5000000 Completed ## 2 96474 1750 21532 835500 00:13:55.5000000 Completed ## source position diffFirstMs diffFirst diffPrevMs diffPrev ## 1 Default 1 0 00:00:00 0 00:00:00 ## 2 Default 2 1000 00:00:01 1000 00:00:01 2.7.1 Getting Stage Times for Multiple Stages It will also be convenient to be able to retrieve stage times for multiple stages from a single function call. We can take the same approach we used previously: get_stage_times2 = function(stageId, eventId) { get_stage_times(eventId, stageId) } get_multi_stage_times = function(stage_list){ multi_stage_times = stage_list %&gt;% map(get_stage_times2, eventId=eventId) %&gt;% bind_rows() multi_stage_times } multi_stage_times = get_multi_stage_times(stage_list) multi_stage_times %&gt;% tail(2) ## stageTimeId stageId entryId elapsedDurationMs elapsedDuration status ## 109 96321 1743 21573 1950700 00:32:30.7000000 Completed ## 110 96355 1743 21547 NA &lt;NA&gt; DNS ## source position diffFirstMs diffFirst diffPrevMs diffPrev ## 109 Default 54 997800 00:16:37.8000000 245500 00:04:05.5000000 ## 110 Default NA NA &lt;NA&gt; NA &lt;NA&gt; 2.7.2 Getting Wide Stage Times for Multiple Stages We can then widen the stage times for each driver: get_multi_stage_times_wide = function(multi_stage_times, stage_list){ stage_times_cols = c(&#39;entryId&#39;, &#39;stageId&#39;, &#39;elapsedDurationMs&#39;) multi_stage_times_wide = multi_stage_times %&gt;% select(all_of(stage_times_cols)) %&gt;% mutate(elapsedDurationS = elapsedDurationMs / 1000) %&gt;% select(-elapsedDurationMs) %&gt;% group_by(entryId) %&gt;% tidyr::spread(key = stageId, value = elapsedDurationS) %&gt;% select(c(&#39;entryId&#39;, as.character(stage_list))) %&gt;% # If we don&#39;t cast, it&#39;s a # non-rankable rowwise df as.data.frame() multi_stage_times_wide } multi_stage_times_wide = get_multi_stage_times_wide(multi_stage_times, stage_list) multi_stage_times_wide %&gt;% head(2) ## entryId 1747 1743 ## 1 21530 980.5 980.0 ## 2 21531 974.5 968.2 2.7.3 Getting Wide Stage Positions We can also get the stage positions: get_multi_stage_positions_wide = function(multi_stage_times, stage_list){ stage_positions_cols = c(&#39;entryId&#39;, &#39;stageId&#39;, &#39;position&#39;) multi_stage_positions_wide = multi_stage_times %&gt;% select(all_of(stage_positions_cols)) %&gt;% group_by(entryId) %&gt;% tidyr::spread(key = stageId, value = position) %&gt;% select(c(&#39;entryId&#39;, as.character(stage_list))) %&gt;% # If we don&#39;t cast, it&#39;s a # non-rankable rowwise df as.data.frame() } multi_stage_positions_wide = get_multi_stage_positions_wide(multi_stage_times, stage_list) multi_stage_positions_wide %&gt;% head(2) ## entryId 1747 1743 ## 1 21530 9 10 ## 2 21531 5 5 2.7.4 Getting Generic Wide Dataframes We can start to work up a function that is able to handle widening data frames more generally, albeit with a potential need to handle exceptions: get_multi_stage_generic_wide = function(multi_stage_generic, stage_list, wide_val, group_key=&#39;entryId&#39;, spread_key=&#39;stageId&#39;){ stage_times_cols = c(group_key, spread_key, wide_val ) if (wide_val==&#39;elapsedDurationMs&#39;) { multi_stage_times_wide = multi_stage_times %&gt;% select(all_of(stage_times_cols)) %&gt;% mutate(elapsedDurationS = elapsedDurationMs / 1000) %&gt;% select(-elapsedDurationMs) wide_val = &#39;elapsedDurationS&#39; } multi_stage_generic_wide = multi_stage_generic %&gt;% select(all_of(stage_times_cols)) %&gt;% # group_by_at lets us pass in the grouping column by variable group_by_at(group_key) %&gt;% tidyr::spread(key = spread_key, value = wide_val) %&gt;% select( c(group_key, as.character(stage_list))) %&gt;% # If we don&#39;t cast, it&#39;s a # non-rankable rowwise df as.data.frame() multi_stage_generic_wide } multi_stage_positions_wide_g = get_multi_stage_generic_wide(multi_stage_times, stage_list, &#39;position&#39;) ## Note: Using an external vector in selections is ambiguous. ## ℹ Use `all_of(group_key)` instead of `group_key` to silence this message. ## ℹ See &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;. ## This message is displayed once per session. multi_stage_positions_wide_g %&gt;% head(2) ## entryId 1747 1743 ## 1 21530 9 10 ## 2 21531 5 5 2.8 Split Times We can get split times and distance into stage data for each stage given the stage identifier: get_splits = function(eventId, stageId){ splits_url=paste0(results_api, &#39;/rally-event/&#39;, eventId, &#39;/split-times/stage-external/&#39;, stageId) jsonlite::fromJSON(splits_url) } splits = get_splits(eventId, stageId) # $splitPoints # $entrySplitPointTimes This includes handy information about split locations, such as distance into stage. This can also be useful for pace calculations: splits$splitPoints ## splitPointId stageId number distance ## 1 3593 1750 5 23.21 ## 2 3601 1750 2 9.02 ## 3 3615 1750 1 4.83 ## 4 3617 1750 4 20.63 ## 5 3621 1750 3 14.87 We can also view the split point times for each driver. This second dataframe contains rows summarising the stage for each driver, and includes the stage start time and duration as well as a column splitPointTimes that itself contains a data frame of elapsed duration split point times: splits$entrySplitPointTimes %&gt;% select(-splitPointTimes) %&gt;% head(2) ## entryId startDateTime startDateTimeLocal stageTimeDurationMs ## 1 21540 2021-02-27T07:08:00 2021-02-27T09:08:00+02:00 844300 ## 2 21541 2021-02-27T07:11:00 2021-02-27T09:11:00+02:00 864400 ## stageTimeDuration ## 1 00:14:04.3000000 ## 2 00:14:24.4000000 To view the split times for a specific driver, we can index into the dataframe using the driver entryId value: splits$entrySplitPointTimes[splits$entrySplitPointTimes[&#39;entryId&#39;]==ogierEntryId,]$splitPointTimes ## [[1]] ## splitPointTimeId splitPointId entryId elapsedDurationMs elapsedDuration ## 1 123492 3615 21530 161700 PT2M41.7S ## 2 123495 3601 21530 272300 PT4M32.3S ## 3 123499 3621 21530 471300 PT7M51.3S ## 4 123505 3617 21530 690400 PT11M30.4S ## 5 123507 3593 21530 789200 PT13M9.2S ## splitDateTime splitDateTimeLocal ## 1 2021-02-27T07:22:41.7 2021-02-27T09:22:41.7+02:00 ## 2 2021-02-27T07:24:32.3 2021-02-27T09:24:32.3+02:00 ## 3 2021-02-27T07:27:51.3 2021-02-27T09:27:51.3+02:00 ## 4 2021-02-27T07:31:30.4 2021-02-27T09:31:30.4+02:00 ## 5 2021-02-27T07:33:09.2 2021-02-27T09:33:09.2+02:00 Each dataframe gives the split times on the stage for a particular driver in a long format. Note that the split point times are strictly increasing and describe the elapsed time into the stage at each split point from the start location and time. 2.8.1 Driver Split Times Detail We can get an unrolled long structure by combining the splitPointTimes dataframes from all drivers, also taking the opportunity to convert the elapsed duration in milliseconds to seconds along the way: #driver_splits = do.call(rbind, entry_splits$splitPointTimes) # The tidyverse approach is to use dplyr::bind_rows() # We can also construct a pipe to streamline the processing get_driver_splits = function(splits){ driver_splits = splits$entrySplitPointTimes$splitPointTimes %&gt;% bind_rows() %&gt;% mutate(elapsedDurationS = elapsedDurationMs / 1000) %&gt;% select(-elapsedDurationMs) driver_splits } driver_splits = get_driver_splits(splits) driver_splits %&gt;% head(2) ## splitPointTimeId splitPointId entryId elapsedDuration splitDateTime ## 1 123482 3615 21540 PT2M41.4S 2021-02-27T07:10:41.4 ## 2 123483 3601 21540 PT4M32.5S 2021-02-27T07:12:32.5 ## splitDateTimeLocal elapsedDurationS ## 1 2021-02-27T09:10:41.4+02:00 161.4 ## 2 2021-02-27T09:12:32.5+02:00 272.5 2.8.2 Wide Driver Split Times We can cast the data into a wide format, with splits ordered by their distance into the stage. Start by creating a function to help get the split point codes in order by distance along the stage: get_split_cols = function(splits){ split_cols = as.character(arrange(splits$splitPoints, distance)$splitPointId) split_cols } Now create a function to get the driver splits in a wide format using the distance-into-stage ordered split point codes as the widened columns: get_driver_splits_wide = function(driver_splits, splits){ split_cols = get_split_cols(splits) splits_cols = c(&#39;entryId&#39;, &#39;splitPointId&#39;, &#39;elapsedDurationS&#39;) driver_splits_wide = driver_splits %&gt;% group_by(entryId) %&gt;% select(all_of(splits_cols)) %&gt;% tidyr::spread(key = splitPointId, value = elapsedDurationS) %&gt;% select(all_of(c(&#39;entryId&#39;, split_cols))) %&gt;% # If we don&#39;t cast, it&#39;s a # non-rankable rowwise df as.data.frame() driver_splits_wide } driver_splits_wide = get_driver_splits_wide(driver_splits, splits) driver_splits_wide %&gt;% head(2) ## entryId 3615 3601 3621 3617 3593 ## 1 21530 161.7 272.3 471.3 690.4 789.2 ## 2 21531 162.3 273.7 472.3 692.1 792.4 2.8.3 Multiple Stage Long Splits Data A convenient way of working with the split times across multiple stages is to put the splits into a long form and then filter out the rows we are interested in. We can generate a long form dataframe using the dlplyr::bind_rows() that we have met before: get_split_times2 = function(stageId, eventId) { splits = get_splits(eventId, stageId) split_times = splits$entrySplitPointTimes names(split_times$splitPointTimes) = splits$splitPoints$splitPointId split_times$splitPointTimes } get_multi_split_times = function(stage_list){ multi_split_times = stage_list %&gt;% map(get_split_times2, eventId=eventId) %&gt;% bind_rows() multi_split_times } stage_list_sample = stage_list[1:2] get_multi_split_times(stage_list[1:2]) %&gt;% head(3) ## splitPointTimeId splitPointId entryId elapsedDurationMs elapsedDuration ## 1 122826 3596 21530 135200 PT2M15.2S ## 2 122828 3608 21530 330100 PT5M30.1S ## 3 122829 3603 21530 473700 PT7M53.7S ## splitDateTime splitDateTimeLocal ## 1 2021-02-26T13:10:15.2 2021-02-26T15:10:15.2+02:00 ## 2 2021-02-26T13:13:30.1 2021-02-26T15:13:30.1+02:00 ## 3 2021-02-26T13:15:53.7 2021-02-26T15:15:53.7+02:00 "],["visualising-results-for-a-single-stage.html", "3 Visualising Results for a Single Stage 3.1 Load Base Data 3.2 Get Stage Results Data 3.3 Previewing Stage Results Data 3.4 Adding Stage Metadata to Table Captions 3.5 Colour Highlighting Stage Results 3.6 An Aside — Calculating DIFF and GAP times 3.7 Rebasing Stage Results 3.8 Colour Highlighting Rebased Values", " 3 Visualising Results for a Single Stage In this chapter, we’ll introduce some basic chart and chartable techniques for displaying stage timing and results data. 3.1 Load Base Data To get the splits data from a standing start, we can load in the current season list, select the rally we want, look up the itinerary from the rally, extract the sections and then the stages and the retrieve the stage ID for the stage we are interested in. To begin with, load in our WRC API helper functions: source(&#39;code/wrc-api.R&#39;) Now let’s grab some data: s = get_active_season() eventId = get_eventId_from_name(s, &#39;arctic&#39;) entries = get_rally_entries(eventId) itinerary = get_itinerary(eventId) sections = get_sections(itinerary) stages = get_stages(sections) stages_lookup = get_stages_lookup(stages) Get a sample stage ID: stageId = stages_lookup[[&#39;SS3&#39;]] 3.2 Get Stage Results Data Start by loading in some stage times data and previewing the columns available to us: stage_times = get_stage_times(eventId, stageId) colnames(stage_times) ## [1] &quot;stageTimeId&quot; &quot;stageId&quot; &quot;entryId&quot; ## [4] &quot;elapsedDurationMs&quot; &quot;elapsedDuration&quot; &quot;status&quot; ## [7] &quot;source&quot; &quot;position&quot; &quot;diffFirstMs&quot; ## [10] &quot;diffFirst&quot; &quot;diffPrevMs&quot; &quot;diffPrev&quot; 3.3 Previewing Stage Results Data Just using the stage results data, how might we display it? Let’s start with a view of the top 10. We can use the knitr::kable() function to provide a styled version of the table that slightly improves its appearance: library(knitr) kable( head(stage_times, 10)) stageTimeId stageId entryId elapsedDurationMs elapsedDuration status source position diffFirstMs diffFirst diffPrevMs diffPrev 96580 1750 21536 834500 00:13:54.5000000 Completed Default 1 0 00:00:00 0 00:00:00 96474 1750 21532 835500 00:13:55.5000000 Completed Default 2 1000 00:00:01 1000 00:00:01 96623 1750 21539 839100 00:13:59.1000000 Completed Default 3 4600 00:00:04.6000000 3600 00:00:03.6000000 96509 1750 21533 840200 00:14:00.2000000 Completed Default 4 5700 00:00:05.7000000 1100 00:00:01.1000000 96656 1750 21538 841900 00:14:01.9000000 Completed Default 5 7400 00:00:07.4000000 1700 00:00:01.7000000 96624 1750 21530 842000 00:14:02 Completed Default 6 7500 00:00:07.5000000 100 00:00:00.1000000 96693 1750 21534 843200 00:14:03.2000000 Completed Default 7 8700 00:00:08.7000000 1200 00:00:01.2000000 96480 1750 21540 844300 00:14:04.3000000 Completed Default 8 9800 00:00:09.8000000 1100 00:00:01.1000000 96523 1750 21531 845800 00:14:05.8000000 Completed Default 9 11300 00:00:11.3000000 1500 00:00:01.5000000 96419 1750 21537 846900 00:14:06.9000000 Completed Default 10 12400 00:00:12.4000000 1100 00:00:01.1000000 An alternative rich table formatter is the formattable (example usage) R package which builds on kable() and provides even more comprehensive support,, including cell colour highlighting, for rendering tables in a stylised way. In interactive HTML environments, the tables are rendered as an HTML widget, which allows for even more customisation, such as the inclusion of interactive HTML sparklines. library(formattable) formattable( head(stage_times, 10) ) stageTimeId stageId entryId elapsedDurationMs elapsedDuration status source position diffFirstMs diffFirst diffPrevMs diffPrev 96580 1750 21536 834500 00:13:54.5000000 Completed Default 1 0 00:00:00 0 00:00:00 96474 1750 21532 835500 00:13:55.5000000 Completed Default 2 1000 00:00:01 1000 00:00:01 96623 1750 21539 839100 00:13:59.1000000 Completed Default 3 4600 00:00:04.6000000 3600 00:00:03.6000000 96509 1750 21533 840200 00:14:00.2000000 Completed Default 4 5700 00:00:05.7000000 1100 00:00:01.1000000 96656 1750 21538 841900 00:14:01.9000000 Completed Default 5 7400 00:00:07.4000000 1700 00:00:01.7000000 96624 1750 21530 842000 00:14:02 Completed Default 6 7500 00:00:07.5000000 100 00:00:00.1000000 96693 1750 21534 843200 00:14:03.2000000 Completed Default 7 8700 00:00:08.7000000 1200 00:00:01.2000000 96480 1750 21540 844300 00:14:04.3000000 Completed Default 8 9800 00:00:09.8000000 1100 00:00:01.1000000 96523 1750 21531 845800 00:14:05.8000000 Completed Default 9 11300 00:00:11.3000000 1500 00:00:01.5000000 96419 1750 21537 846900 00:14:06.9000000 Completed Default 10 12400 00:00:12.4000000 1100 00:00:01.1000000 The data itself looks quite cryptic, so we need to convert it to something a little bit more human readable. To enrich the display, we might want to add in information relating to a stage, rather than just refer to it by stage ID, or to describe each entry in rather more detail than just by the entry ID. The way the table is actually presented may also mean that not all the columns may be displayed, so reducing the number of columns would presumably help address that, in part at least. 3.3.1 Adding Entry Metadata In the first instance, it would probably make sense to pull in some human readable data about each entry: cars = get_car_data(entries) cars %&gt;% head(2) ## entryId driverId codriverId manufacturerId vehicleModel eligibility classname ## 1 21530 670 3027 84 Yaris WRC M RC1 ## 2 21531 534 553 84 Yaris WRC M RC1 ## manufacturer entrantname groupname identifier drivername code ## 1 Toyota TOYOTA GAZOO RACING WRT WRC 1 S. OGIER OGI ## 2 Toyota TOYOTA GAZOO RACING WRT WRC 33 E. EVANS EVA ## driverfullname codrivername codriverfullname ## 1 Sébastien OGIER J. INGRASSIA Julien INGRASSIA ## 2 Elfyn EVANS S. MARTIN Scott MARTIN We can the merge this data into our original table, and filter out some of the less useful columns. Since the driver code may not be unique, we should retain the driver entryId in the table and then suppress its display when we render the dataframe. We’ll also limit ourselves to just the top 10 results. top10_display_cols_base = c(&#39;position&#39;, &#39;identifier&#39;, &#39;code&#39;, #&#39;drivername&#39;, &#39;codrivername&#39;, #&#39;groupname&#39;, &#39;entrantname&#39;, #&#39;classname&#39;, &#39;eligibility&#39;, #&#39;elapsedDuration&#39;, # gap is the time delta between a driver # and the leader; diff (or interval) # is the difference between a driver # and the driver immediately ahead &#39;TimeInS&#39;, &#39;gap&#39;, &#39;diff&#39;) top10_stage_times = stage_times %&gt;% # A minor optimisation step to # limit the amount of merging arrange(position) %&gt;% head(10) %&gt;% # Merge in the entries data merge(cars, by=&#39;entryId&#39;) %&gt;% # Convert milliseconds to seconds mutate(TimeInS = elapsedDurationMs/1000, gap = diffFirstMs/1000, diff = diffPrevMs/1000) %&gt;% # Limit columns and set column order select(all_of(top10_display_cols_base), &#39;entryId&#39;) %&gt;% # The merge may upset the row order # so reset the order again arrange(position) %&gt;% # Improve column names by renaming them rename(Pos=position, Car = identifier, Code = code, `Time (s)` = TimeInS, Gap = gap, Diff = diff) top10_stage_times %&gt;% head(3) %&gt;% formattable() Pos Car Code Time (s) Gap Diff entryId 1 8 TÄN 834.5 0.0 0.0 21536 2 11 NEU 835.5 1.0 1.0 21532 3 2 SOL 839.1 4.6 3.6 21539 We can suppress the display of the entryId colum to keep the table tidy: top10_stage_times %&gt;% head(3) %&gt;% formattable(list(entryId=FALSE)) Pos Car Code Time (s) Gap Diff 1 8 TÄN 834.5 0.0 0.0 2 11 NEU 835.5 1.0 1.0 3 2 SOL 839.1 4.6 3.6 3.4 Adding Stage Metadata to Table Captions To improve the table further, we may want to add a caption to the table describing the stage to which the results actually refer. The caption might include the stage code and the stage name, for example, and perhaps the stage distance. It might also be handy to retrieve the stage number so that if we are displaying several tables, we can check we present the stages in the correct running order: stage_cols = c(&#39;stageId&#39;, &#39;number&#39;, &#39;name&#39;, &#39;distance&#39;, &#39;code&#39;) stage_info = stages %&gt;% select(all_of(stage_cols)) %&gt;% # Tidy up the stage name mutate(name = str_replace(name, &#39; \\\\(Live TV\\\\)&#39;, &#39;&#39;)) stage_info %&gt;% head(2) ## stageId number name distance code ## 1 1747 1 Sarriojärvi 1 31.05 SS1 ## 2 1743 2 Sarriojärvi 2 31.05 SS2 We can create a caption for our selected stage using what essentially amounts to a string template: stage_info_ = stage_info[stage_info[&#39;stageId&#39;]==stageId,] # paste0() ensures there are no separators between substrings caption = paste0(&#39;Stage &#39;, stage_info_$code, &#39;, &#39;, stage_info_$name, &#39; (&#39;, stage_info_$distance, &#39;km)&#39;) caption ## [1] &quot;Stage SS3, Mustalampi 1 (24.43km)&quot; We can add a caption to the table via the caption parameter. Using the %&gt;% pipe operator to pass the dataframe as the first argument of the formattable() function allows us to more clearly see what parameter we need to set in the function to create the caption. The pipe operator also allows us to limit the number of rows in the dataframe passed to the formattable() function via the head() function: top10_stage_times %&gt;% head(3) %&gt;% formattable(caption = caption, list(entryId=FALSE)) Table 3.1: Stage SS3, Mustalampi 1 (24.43km) Pos Car Code Time (s) Gap Diff 1 8 TÄN 834.5 0.0 0.0 2 11 NEU 835.5 1.0 1.0 3 2 SOL 839.1 4.6 3.6 We can also align text within the columns: top10_stage_times %&gt;% head(3) %&gt;% formattable(align=&#39;c&#39;, list(entryId=FALSE)) Pos Car Code Time (s) Gap Diff 1 8 TÄN 834.5 0.0 0.0 2 11 NEU 835.5 1.0 1.0 3 2 SOL 839.1 4.6 3.6 3.5 Colour Highlighting Stage Results The formattable::formattable() function is capable of highlighting cell values in a variety of customisable ways. One straightforward way of highlighting a table is to use colour to emphasise a ranking. Trivially, and perhaps redundantly, we might highlight stage positions for example: top10_stage_times %&gt;% head() %&gt;% formattable(align=&#39;c&#39;, list(Pos = color_tile(&quot;#DeF7E9&quot;, &quot;#71CA97&quot;), entryId=FALSE)) Pos Car Code Time (s) Gap Diff 1 8 TÄN 834.5 0.0 0.0 2 11 NEU 835.5 1.0 1.0 3 2 SOL 839.1 4.6 3.6 4 69 ROV 840.2 5.7 1.1 5 42 BRE 841.9 7.4 1.7 6 1 OGI 842.0 7.5 0.1 This may not make so much sense when the ranking we are highlighting is the sort order of the table, but it makes more sense when we want to compare two columns, such as the stage position and the start order. So let’s also pull in the start order (that is, the road order) and see how it compares to the stage position. TO DO: - get itinerarySectionId from stages (stages$itinerarySectionId) - get startListId (get_startlist_id(itinerary, itinerarySectionId)) - lookup startlist details (get_startlist(eventId, startListId)[,c('entryId','order')]) - merge startlist data into stage result We can also explore highlights based on conditional requirements. For example, we can emphasise differences that exceed a specific amount: large_diff = 2 formattable(top10_stage_times, list(Diff = formatter(&quot;span&quot;, style = x ~ style(font.weight = ifelse(x&gt;=large_diff, &quot;bold&quot;, &#39;normal&#39;))), entryId=FALSE)) Pos Car Code Time (s) Gap Diff 1 8 TÄN 834.5 0.0 0.0 2 11 NEU 835.5 1.0 1.0 3 2 SOL 839.1 4.6 3.6 4 69 ROV 840.2 5.7 1.1 5 42 BRE 841.9 7.4 1.7 6 1 OGI 842.0 7.5 0.1 7 18 KAT 843.2 8.7 1.2 8 7 LOU 844.3 9.8 1.1 9 33 EVA 845.8 11.3 1.5 10 3 SUN 846.9 12.4 1.1 Alternatively, we can add a coloured bar that depicts the increasing gap time down the leaderboard. If we pass an 8 hex digit colour code, rather than a sic digt RGB hex colour code, we can modify the transparency of the colour bar: #https://www.displayr.com/formattable/ unit.scale = function(x) (x - min(x)) / (max(x) - min(x)) formattable(top10_stage_times, list(Gap = color_bar(&quot;#FA614B66&quot;, fun = unit.scale), entryId=FALSE)) Pos Car Code Time (s) Gap Diff 1 8 TÄN 834.5 0.0 0.0 2 11 NEU 835.5 1.0 1.0 3 2 SOL 839.1 4.6 3.6 4 69 ROV 840.2 5.7 1.1 5 42 BRE 841.9 7.4 1.7 6 1 OGI 842.0 7.5 0.1 7 18 KAT 843.2 8.7 1.2 8 7 LOU 844.3 9.8 1.1 9 33 EVA 845.8 11.3 1.5 10 3 SUN 846.9 12.4 1.1 There seems to be an edge effect there for the zero gap value? Let’s see if we can tidy that up a bit: new_color_bar &lt;- function(color = &quot;lightgreen&quot;, ...){ formatter(&quot;span&quot;, style = function(x) style( display = &quot;inline-block&quot;, direction = &quot;rtl&quot;, `unicode-bidi` = &quot;plaintext&quot;, &quot;border-radius&quot; = &quot;4px&quot;, &quot;background-color&quot; = color, width = percent(proportion(abs(as.numeric(x)), ...)) )) } formattable(top10_stage_times, list(Gap = new_color_bar(&quot;#FA614B66&quot;), entryId=FALSE)) Pos Car Code Time (s) Gap Diff 1 8 TÄN 834.5 0.0 0.0 2 11 NEU 835.5 1.0 1.0 3 2 SOL 839.1 4.6 3.6 4 69 ROV 840.2 5.7 1.1 5 42 BRE 841.9 7.4 1.7 6 1 OGI 842.0 7.5 0.1 7 18 KAT 843.2 8.7 1.2 8 7 LOU 844.3 9.8 1.1 9 33 EVA 845.8 11.3 1.5 10 3 SUN 846.9 12.4 1.1 The edge effect is gone, but the default color_bar() function doesn’t seem to render the values very well where the bars is narrow, at least when the table is rendered to HTML using bookdown. If we provide am alternative color bar function that makes use of a CSS linear gradient to create the bar rather than a setting the width of text cell and colouring its background we can decouple the color bar and the size of the text area: bg = function(start, end, color, ...) { paste(&quot;linear-gradient(90deg,transparent &quot;,percent(start),&quot;,&quot;, color, percent(start), &quot;,&quot;, color, percent(end), &quot;, transparent&quot;, percent(end),&quot;)&quot;) } color_bar2 = function (color = &quot;lightgray&quot;, fun = &quot;proportion&quot;, ...) { fun &lt;- match.fun(fun) formatter(&quot;span&quot;, style = function(x) style(display = &quot;inline-block&quot;, `unicode-bidi` = &quot;plaintext&quot;, &quot;background&quot; = bg(1-fun(as.numeric(x), ...), 1, color), &quot;width&quot;=&quot;100%&quot; )) } top10_stage_times %&gt;% formattable(list(Gap = color_bar2(&quot;#FA614B66&quot;), entryId=FALSE)) Pos Car Code Time (s) Gap Diff 1 8 TÄN 834.5 0.0 0.0 2 11 NEU 835.5 1.0 1.0 3 2 SOL 839.1 4.6 3.6 4 69 ROV 840.2 5.7 1.1 5 42 BRE 841.9 7.4 1.7 6 1 OGI 842.0 7.5 0.1 7 18 KAT 843.2 8.7 1.2 8 7 LOU 844.3 9.8 1.1 9 33 EVA 845.8 11.3 1.5 10 3 SUN 846.9 12.4 1.1 3.5.1 Heatmap Style Column Cell Backgrounds As well as in cell bar charts, we can also use more of a heatmap style approach and colour the background down other numerical columns according to value. top10_stage_times %&gt;% formattable(list(Gap = color_bar2(&quot;#FA614B66&quot;), Diff = color_tile(&quot;#DeF7E9&quot;,&quot;#71CA97&quot;), entryId=FALSE)) Pos Car Code Time (s) Gap Diff 1 8 TÄN 834.5 0.0 0.0 2 11 NEU 835.5 1.0 1.0 3 2 SOL 839.1 4.6 3.6 4 69 ROV 840.2 5.7 1.1 5 42 BRE 841.9 7.4 1.7 6 1 OGI 842.0 7.5 0.1 7 18 KAT 843.2 8.7 1.2 8 7 LOU 844.3 9.8 1.1 9 33 EVA 845.8 11.3 1.5 10 3 SUN 846.9 12.4 1.1 3.6 An Aside — Calculating DIFF and GAP times As has previously been mentioned, the GAP to leader and +/- DIFF times to any car placed directly ahead of a particular car, are typical across many forms of motorsport timing screen. In rally terms, these metrics might apply either in overall rally terms or in stage terms; in circuit racing, the measures might apply relative to overall race position or track position. The GAP (time to leader) is calculated as the difference between a time associated with the current leader and a similarly measured time associated with every other driver. The \\(\\textrm{GAP}\\) between driver in first position, \\(i=1\\), and the driver in the \\(j\\)’th position is given in various abuses of the notation as: \\[\\textrm{GAP}{_j}=t_{j,\\textrm{GAP}}=t_{j,1,DIFF}=t_j-t_1\\] Alternatively, we can calculate the gap as the sum of differences between consecutively placed drivers, \\(j\\neq1\\), and the leader. The interval or DIFF between drivers in positions \\(i\\) and \\(j\\), where \\(i\\) is ahead of \\(j\\) (that is, \\(i&lt;j\\)) and the driver in first position has \\(i=1\\) is given as: \\[\\textrm{DIFF}_{j,i}=t_{j,i,\\textrm{DIFF}}=t_{j,i}=t_j-t_i: i&lt;j, t_0=t_1\\] Strictly, \\(\\textrm{GAP}_j=\\textrm{DIFF}_{j,1}\\). To specify a particular stage, we might use \\({_S}\\textrm{GAP}{_j}\\) and \\({_S}\\textrm{DIFF}{_j}\\). The \\(\\textrm{GAP}\\) between a driver in position \\(j=P\\) and the leader \\(i=1\\) is then: \\[\\textrm{GAP}_j=t_{j,\\textrm{GAP}}=\\textrm{DIFF}_{2,1}+\\textrm{DIFF}_{3,2}+..+\\textrm{DIFF}_{P,P-1}\\] We can write this more succinctly as: \\[\\textrm{GAP}{_j}=t_{j,\\textrm{GAP}}=0+\\sum_{m=1}^{j}\\textrm{DIFF}_{m,m-1}=\\sum_{m=1}^{j}\\left ( t_m-t_{m-1} \\right ): j\\ge1, t_0=t_1\\] We can implement these calculations directly as follows: top10_stage_times %&gt;% mutate(DIFF = c(0, diff(`Time (s)`)), GAP = cumsum(DIFF)) %&gt;% select(c(&#39;Car&#39;, &#39;Gap&#39;, &#39;GAP&#39;, &#39;Diff&#39;, &#39;DIFF&#39;)) %&gt;% formattable(caption = caption, list(entryId=FALSE)) Table 3.2: Stage SS3, Mustalampi 1 (24.43km) Car Gap GAP Diff DIFF 8 0.0 0.0 0.0 0.0 11 1.0 1.0 1.0 1.0 2 4.6 4.6 3.6 3.6 69 5.7 5.7 1.1 1.1 42 7.4 7.4 1.7 1.7 1 7.5 7.5 0.1 0.1 18 8.7 8.7 1.2 1.2 7 9.8 9.8 1.1 1.1 33 11.3 11.3 1.5 1.5 3 12.4 12.4 1.1 1.1 3.7 Rebasing Stage Results Simple as they are, the GAP and DIFF times are very powerful: for any driver, we can see how far off the stage winning time they were (the Gap) and by summing appropriate Diff values you can quickly determine the time difference between any two drivers. However, if we are interested in a particular driver, we can “rebase” the table to show the time differences between that driver and the other drivers explicitly. To rebase times, \\(t_i\\) for a set of drivers, \\(i\\), relative to a particular driver, \\(j\\), we set: \\[ t_{i}^{j} = t_i - t_j \\] For a stage \\(S\\), we might extend the notation to write: \\[ {_S}t_{i}^{j} = {_S}t_{i} - {_S}t_{j} \\] using the simpler form with the \\(S\\) prefix where the stage is known. We might also abuse the \\(textrm{GAP}\\) notation to specify a rebased time \\(_S\\textrm{GAP}_{i,j}={_S}t_{i}^{j}\\) noting \\({_S}\\textrm{GAP}_i={_S}\\textrm{GAP}_{i,1}={_S}\\textrm{DIFF}_{i,1}\\). In passing, we note that we can calculate the overall rally time (without penalties) for driver \\(i\\), up to and including stage \\(N\\) as: \\[ {_N}T_{i}=\\sum_{S=1}^{N}{_S}t_{i} \\] The overall time at the end of the rally is then given as: \\[ T_{i}=\\sum_{S=1}^{S{_{max}}}{_S}t_{i} + {penalties}_i \\] Let’s see how the rebasing works. First, get a driver code: ogier = get_person_id(cars, &#39;ogier&#39;, ret=&#39;identifier&#39;) ogier ## [1] &quot;1&quot; Now we can start to build up a rebase function that takes a data frame, an entryId and a set of columns we want to rebase. To begin with, we note that we can rebase a single column simply by finding the value associated with a particular driver in that column and subtracting that value from each row in the column. For example, we can get Ogier’s stage time: ogier_time = top10_stage_times[top10_stage_times[[&#39;Car&#39;]]==ogier, &quot;Time (s)&quot;] ogier_time ## [1] 842 And we can then subtract that time from every other car’s time: top10_stage_times$`Time (s)` - ogier_time ## [1] -7.5 -6.5 -2.9 -1.8 -0.1 0.0 1.2 2.3 3.8 4.9 To rebase more than one column, we can specify a list of columns we want to rebase and then process the response as a named list before subtracting the items in that named list from each of the correspondingly named columns in each row of the dataframe: #https://stackoverflow.com/a/32267785/454773 rebase_cols = c(&#39;Time (s)&#39;, &#39;Gap&#39;) df = top10_stage_times # From each row, select specific columns # From those values subtract correspondingly named items # representing the times in those columns for our specified driver df[,rebase_cols] - c(df[df$Car==ogier, rebase_cols]) ## Time (s) Gap ## 1 -7.5 -7.5 ## 2 -6.5 -6.5 ## 3 -2.9 -2.9 ## 4 -1.8 -1.8 ## 5 -0.1 -0.1 ## 6 0.0 0.0 ## 7 1.2 1.2 ## 8 2.3 2.3 ## 9 3.8 3.8 ## 10 4.9 4.9 Let’s put that into a function, generalised to allow is to specify which column we want to use as a rebasing identifier column. Optionally allow the return of either just the rebased columns (and identifier) or the complete dataframe, including rebased columns, we well as the ability to “flip” the basis of the differences: rebase = function(df, id, rebase_cols, id_col=&#39;entryId&#39;, base=FALSE, base_id=FALSE, flip=FALSE) { df_ = df rebase_cols = as.character(rebase_cols) # The rebase values are the ones # we want to subtract from each row rebase_vals = c(df[df[[id_col]]==id, rebase_cols]) # Do the rebasing df_[,rebase_cols] = df[,rebase_cols] - rebase_vals if (flip) df_[,rebase_cols] = -df_[,rebase_cols] df_[[id_col]] = df[[id_col]] # Return just the rebased and identifier columns or the # whole dataframe cols = rebase_cols if (base_id) cols = c(id_col, cols) if (base) df_ %&gt;% select(cols) else df_ } We can now rebase the stage times across one or more columns relative to a specified driver: rebase_cols = c(&#39;Time (s)&#39;, &#39;Gap&#39;) rov = get_person_id(cars, &#39;rov&#39;, ret=&#39;identifier&#39;) rov_rebased_gap = rebase(top10_stage_times, rov, rebase_cols, id_col=&#39;Car&#39;) rov_rebased_gap ## Pos Car Code Time (s) Gap Diff entryId ## 1 1 8 TÄN -5.7 -5.7 0.0 21536 ## 2 2 11 NEU -4.7 -4.7 1.0 21532 ## 3 3 2 SOL -1.1 -1.1 3.6 21539 ## 4 4 69 ROV 0.0 0.0 1.1 21533 ## 5 5 42 BRE 1.7 1.7 1.7 21538 ## 6 6 1 OGI 1.8 1.8 0.1 21530 ## 7 7 18 KAT 3.0 3.0 1.2 21534 ## 8 8 7 LOU 4.1 4.1 1.1 21540 ## 9 9 33 EVA 5.6 5.6 1.5 21531 ## 10 10 3 SUN 6.7 6.7 1.1 21537 The rebased time dataframe makes it easier to see how a specified driver compares with every other driver. But can we make the differences jump out in a more striking fashion? 3.8 Colour Highlighting Rebased Values In the rebased tables, we are likely to be presented with a range of positive and negative values within a rebased column. We can highlight the positive and negative values using colour. For example: formattable(rov_rebased_gap, list(Gap = formatter(&quot;span&quot;, style = x ~ style(color = ifelse(x&lt;0, &quot;red&quot;, ifelse(x&gt;0, &#39;green&#39;, &#39;grey&#39;)), # Example additional style font.weight = ifelse(abs(x)&gt;=2, &#39;bold&#39;, &#39;normal&#39;) )), entryId=FALSE)) Pos Car Code Time (s) Gap Diff 1 8 TÄN -5.7 -5.7 0.0 2 11 NEU -4.7 -4.7 1.0 3 2 SOL -1.1 -1.1 3.6 4 69 ROV 0.0 0.0 1.1 5 42 BRE 1.7 1.7 1.7 6 1 OGI 1.8 1.8 0.1 7 18 KAT 3.0 3.0 1.2 8 7 LOU 4.1 4.1 1.1 9 33 EVA 5.6 5.6 1.5 10 3 SUN 6.7 6.7 1.1 Although the formattable() function does not directly support divergent colour indicators, we can create a custom formatter that does provide such a view over the data. For example, we can create a mapping that will display coloured backgrounds that diverge around the zero value to give distinct hues for positive and negative values. The easiest way to render such a mapping is to map the rage of value onto the unit range, and map the 0 value in the original range to the 0.5 value in the normalised unit range. The following function will create a normalised range across a set of positive and negative values, mapping the origin (0) to the normalised 0.5 value: xnormalize = function(x){ # Normalise to the full range of values about 0 # O will map to 0.5 in the normalised range x = c(x, -max(abs(x)), max(abs(x))) normalize(x)[1:(length(x)-2)] } Let’s see how it works: xnormalize(c(-1, 0, 2)) ## [1] 0.25 0.50 1.00 We can now define a custom mapping to render red and green palettised backgrounds depending on whether the value is negative or positive. To maintain contrast in the displayed text values, we can render white or black text depending on the likely intensity of the background colour: #https://stackoverflow.com/a/49887341/454773 color_tile2 &lt;- function (...) { formatter(&quot;span&quot;, style = function(x) { style(display = &quot;block&quot;, &#39;text-align&#39; = &#39;center&#39;, padding = &quot;0 4px&quot;, `border-radius` = &quot;4px&quot;, `font.weight` = ifelse(abs(x)&gt; 0.3*max(x), &quot;bold&quot;, &quot;normal&quot;), color = ifelse(abs(x)&gt; 0.3*max(x),&#39;white&#39;, ifelse(x==0,&#39;lightgrey&#39;,&#39;black&#39;)), `background-color` = csscolor(matrix(as.integer(colorRamp(...)(xnormalize(as.numeric(x)))), byrow=TRUE, dimnames=list(c(&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;), NULL), nrow=3))) })} formattable(rov_rebased_gap, align=&#39;c&#39;, list(Gap = color_tile2(c(&quot;red&quot;,&#39;white&#39;, &quot;forestgreen&quot;)), entryId=FALSE)) Pos Car Code Time (s) Gap Diff 1 8 TÄN -5.7 -5.7 0.0 2 11 NEU -4.7 -4.7 1.0 3 2 SOL -1.1 -1.1 3.6 4 69 ROV 0.0 0.0 1.1 5 42 BRE 1.7 1.7 1.7 6 1 OGI 1.8 1.8 0.1 7 18 KAT 3.0 3.0 1.2 8 7 LOU 4.1 4.1 1.1 9 33 EVA 5.6 5.6 1.5 10 3 SUN 6.7 6.7 1.1 For further possible discussions about divergent palette definitions, see here. # Recall the CSS style from previously #bg = function(start, end, color, ...) { # paste(&quot;linear-gradient(90deg,transparent &quot;,percent(start),&quot;,&quot;, # color, percent(start), &quot;,&quot;, color, percent(end), # &quot;, transparent&quot;, percent(end),&quot;)&quot;) #} pm_color_bar2 &lt;- function(color1 = &quot;lightgreen&quot;, color2 = &quot;pink&quot;, ...){ formatter(&quot;span&quot;, style = function(x) style( display = &quot;inline-block&quot;, color = ifelse(x&gt; 0,&#39;green&#39;,ifelse(x&lt;0,&#39;red&#39;,&#39;lightgrey&#39;)), &quot;text-align&quot; = ifelse(x &gt; 0, &#39;left&#39;, ifelse(x&lt;0, &#39;right&#39;, &#39;center&#39;)), &quot;width&quot;=&#39;100%&#39;, &quot;background&quot; = bg(ifelse(x &gt;= 0, 0.5,xnormalize(x)), ifelse(x &gt;= 0,xnormalize(x),0.5), ifelse(x &gt;= 0, color1, color2)) )) } rov_rebased_gap %&gt;% formattable(align=&#39;c&#39;, list(Gap = pm_color_bar2(), entryId=FALSE)) Pos Car Code Time (s) Gap Diff 1 8 TÄN -5.7 -5.7 0.0 2 11 NEU -4.7 -4.7 1.0 3 2 SOL -1.1 -1.1 3.6 4 69 ROV 0.0 0.0 1.1 5 42 BRE 1.7 1.7 1.7 6 1 OGI 1.8 1.8 0.1 7 18 KAT 3.0 3.0 1.2 8 7 LOU 4.1 4.1 1.1 9 33 EVA 5.6 5.6 1.5 10 3 SUN 6.7 6.7 1.1 "],["visualising-results-for-multiple-stages.html", "4 Visualising Results for Multiple Stages 4.1 Load Base Data 4.2 Retrieving Mutliple Stage Results 4.3 Visualising Overall Results 4.4 Retrieving Stage Times and Results 4.5 Visualising Stage Times", " 4 Visualising Results for Multiple Stages As well as visualising the results for a single stage, we might want to visualise the results over multiple stages. The basic overall results can be retrieved from a single call to the WRC results API, but to view the stage times and rankings across multiple stages requires retrieving detailed for each stage and then combining it into a single dataframe. 4.1 Load Base Data To get the splits data from a standing start, we can load in the current season list, select the rally we want, look up the itinerary from the rally, extract the sections and then the stages and the retrieve the stage ID for the stage we are interested in. To begin with, load in our WRC API helper functions: source(&#39;code/wrc-api.R&#39;) library(tidyr) Now let’s grab some data: s = get_active_season() eventId = get_eventId_from_name(s, &#39;arctic&#39;) entries = get_rally_entries(eventId) itinerary = get_itinerary(eventId) sections = get_sections(itinerary) stages = get_stages(sections) stages_lookup = get_stages_lookup(stages) stage_list = get_stage_list(stages) stage_codes = stages$code # To generate stage codes as an ordered factor: # factor(stages$code, levels = stages$code) 4.2 Retrieving Mutliple Stage Results To being with, lets get the overall results at the end of each stage: multi_overall_results = get_multi_overall(stage_list) multi_overall_results %&gt;% tail(2) ## entryId stageTimeMs stageTime penaltyTimeMs penaltyTime totalTimeMs ## 530 21542 11203500 PT3H6M43.5S 0 PT0S 11203500 ## 531 21569 11754200 PT3H15M54.2S 0 PT0S 11754200 ## totalTime position diffFirstMs diffFirst diffPrevMs diffPrev stageId ## 530 PT3H6M43.5S 51 3773900 PT1H2M53.9S 696500 PT11M36.5S 1749 ## 531 PT3H15M54.2S 52 4324600 PT1H12M4.6S 550700 PT9M10.7S 1749 4.2.1 Reshaping Overall Position Data We can reduce the amount of data by casting the long raw result to a wide format, widening the data on a particular field of interest. For example, we can widen generate a wide dataframe describing overall positions, \\({_S}o\\) at the end of each stage, where a particular driver’s position is given as \\({_S}o_i\\): multi_overall_wide_pos = multi_overall_results %&gt;% get_multi_stage_generic_wide(stage_list, &#39;position&#39;) multi_overall_wide_pos %&gt;% head(2) ## entryId 1747 1743 1750 1751 1748 1745 1744 1742 1746 1749 ## 1 21530 9 9 9 8 8 7 6 22 20 20 ## 2 21531 5 5 5 5 5 5 5 5 5 5 4.2.2 Reshaping Overall Rally Time Data We can also create a wide format report of the overall times, where each column gives the overall, accumulated rally time up to and including each stage, \\({_S}T\\); each cell then represents the accumulated time for a particular driver, \\({_S}T_i\\). The times themselves appear in units of milliseconds, so first create a column corresponding to time in seconds, then widen using those values: multi_overall_results = multi_overall_results %&gt;% mutate(totalTimeS = totalTimeMs/1000) multi_overall_wide_time = multi_overall_results %&gt;% get_multi_stage_generic_wide(stage_list, &#39;totalTimeS&#39;) multi_overall_wide_time %&gt;% head(2) ## entryId 1747 1743 1750 1751 1748 1745 1744 1742 1746 1749 ## 1 21530 980.5 1960.5 2802.5 3351.0 4102.2 4955.9 5512.6 6876.6 7491.6 8095.8 ## 2 21531 974.5 1942.7 2788.5 3335.1 4085.3 4938.9 5491.5 6275.6 6883.1 7491.1 We note that with stages presented in order, the rally time is strictly increasing across the rows. We further note that we can derive stage times from the overall rally times by calculating the columnwise differences \\({_S}t={_S}T-{_{S-1}}T: 1&lt;S&lt;N\\) for an \\(N\\) stage rally. 4.2.3 Reshaping Time to First Data Another useful time is the time to first, which is to say, the gap, \\({_S}GAP_i\\). Noting that the overall rally leader may change at the end of each stage, this measure is essentially a rebasing measure relative to a particular position rather than a particular driver: multi_overall_results = multi_overall_results %&gt;% mutate(diffFirstS = diffFirstMs/1000) multi_overall_wide_gap = multi_overall_results %&gt;% get_multi_stage_generic_wide(stage_list, &#39;diffFirstS&#39;) multi_overall_wide_gap %&gt;% head(2) ## entryId 1747 1743 1750 1751 1748 1745 1744 1742 1746 1749 ## 1 21530 22.7 49.8 57.3 53.1 54.2 70.6 76.8 664.5 666.1 666.2 ## 2 21531 16.7 32.0 43.3 37.2 37.3 53.6 55.7 63.5 57.6 61.5 However, we could also calculate the gap to leader from the overall times, first by identifying the minimum accumulated time at each stage (that is, the minimum time, excluding null values, in each overall time column) and then by subtracting those values from each row in the overall times dataframe, which is to say: \\[ \\textrm{GAP}_{i} = {_S}t_i - \\textrm{min}({_S}T) \\] If we try to subtract a list of values (for example, \\(\\forall S \\in [1 \\le S \\le N]: \\textrm{min}({_S}T)\\)) from an R dataframe, we need to tell R how we want that subtraction performed. Internally, the dataframe is represented as a long list of values made up from values in the first column, then the second, and so on. If we subtract a list of N values from the dataframe, the values are selected from the first N items in this long serialised version of the dataframe, then the next N values and so on. So to subtract a “dummy” row of values from the dataframe, we need another approach. The purrr::map2df() function allows us to apply a function, in this case the subtraction - function, with a set of specified values we want to subtract, from each row in the dataframe. So let’s create a set of values representing the minimum overall time in each stage. The matrixStats::colMins() function will find the minimum values by row from a matrix, so cast the stage time columns from the wide dataframe to an appropriately sized matrix and then find the minimum in each column, ignoring null values: overall_m = as.matrix(multi_overall_wide_time[,as.character(stage_list)], ncols=length(stage_list)) mins_overall = matrixStats::colMins(overall_m, na.rm=TRUE) mins_overall ## [1] 957.8 1910.7 2745.2 3297.9 4048.0 4885.3 5435.8 6212.1 6825.5 7429.6 We can now subtract this “dummy row” of values from each row in the dataframe to find the gap to leader for each row on each stage: purrr::map2_df(multi_overall_wide_time[,as.character(stage_list)], mins_overall, `-`) %&gt;% head(2) ## # A tibble: 2 x 10 ## `1747` `1743` `1750` `1751` `1748` `1745` `1744` `1742` `1746` ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 22.7 49.80000 57.3 53.10000 54.20000 70.60000 76.8 664.5 666.1 ## 2 16.7 32 43.3 37.20000 37.3 53.60000 55.70000 63.5 57.6 ## # … with 1 more variable: 1749 &lt;dbl&gt; Comparison with the “diffToFirst” times should show them to be the same. 4.2.4 Mapping Stage and Driver Identifiers to Meaningful Labels To improve the look of the table, we might use stage codes and driver codes to label the columns and identify the rows. To start with, we can map the column names that correspond to stage codes via a lookup list of stage ID to stage code values: map_stage_codes = function(df, stage_list) { # Get stage codes lookup id-&gt;code stages_lookup_code = get_stages_lookup(stages, &#39;stageId&#39;, &#39;code&#39;) #https://stackoverflow.com/a/34299333/454773 plyr::rename(df, replace = stages_lookup_code, warn_missing = FALSE) } multi_overall_wide_time = multi_overall_wide_time %&gt;% map_stage_codes(stage_list) multi_overall_wide_time %&gt;% head(2) ## entryId SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 ## 1 21530 980.5 1960.5 2802.5 3351.0 4102.2 4955.9 5512.6 6876.6 7491.6 8095.8 ## 2 21531 974.5 1942.7 2788.5 3335.1 4085.3 4938.9 5491.5 6275.6 6883.1 7491.1 We can also create a function to replace the entry ID with the driver code. Note also the select statement at the end that puts the columns into a sensible order: cars = get_car_data(entries) map_driver_names = function(df, cars){ df %&gt;% merge(cars[,c(&#39;entryId&#39;,&#39;code&#39;)], by=&#39;entryId&#39;) %&gt;% # Limit columns and set column order select(-&#39;entryId&#39;) %&gt;% # Move last column to first select(&#39;code&#39;, everything()) } multi_overall_wide_time = multi_overall_wide_time %&gt;% map_driver_names(cars) multi_overall_wide_time %&gt;% head(2) ## code SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 ## 1 OGI 980.5 1960.5 2802.5 3351.0 4102.2 4955.9 5512.6 6876.6 7491.6 8095.8 ## 2 EVA 974.5 1942.7 2788.5 3335.1 4085.3 4938.9 5491.5 6275.6 6883.1 7491.1 4.2.5 Rebasing Overall Times We can rebase the overall times with respect to a particular driver in the normal way, calculating the difference between each row and the row corresponding to a specified driver: example_driver = multi_overall_wide_time[2,]$code overall_wide_time_rebased = rebase(multi_overall_wide_time, example_driver, stage_codes, id_col=&#39;code&#39;) overall_wide_time_rebased %&gt;% head(3) ## code SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 ## 1 OGI 6.0 17.8 14.0 15.9 16.9 17.0 21.1 601.0 608.5 604.7 ## 2 EVA 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 ## 3 NEU -4.3 -2.2 -12.5 -8.0 -2.6 -18.7 -17.5 -37.6 -36.5 -41.7 4.2.6 Finding Changes in Rebased Gaps Across Stages The rebasing operation essentially allows us to select a row of times for one particular driver and then subtract that row from every other row to give us a direct comparison of the gap between a specified driver and every other driver. But we can also perform a consecutive column-wise differencing operation on the rebased times that allows to see how much time was gained or relative to a particular driver in going from one stage to the next (observant readers may note that this results in the rebased stage time for each stage…). To subtract one column from the next, create two offset dataframes, one containing all but the first stage (first stage column) and one containing all but the last stage (final stage column). If we subtract one dataframe from the other, it gives us our column differences. Inserting the original first column back in its rightful place gives us the columnwise differences table: #https://stackoverflow.com/a/50411529/454773 df = overall_wide_time_rebased # [-1] drops the first column, [-ncol()] drops the last df_ = df[,stage_codes][-1] - df[,stage_codes][-ncol(df[,stage_codes])] # The split time to the first split is simply the first split time df_[stage_codes[1]] = df[stage_codes[1]] # Return the dataframe in a sensible column order df_ %&gt;% select(stage_codes) %&gt;% head(3) ## Note: Using an external vector in selections is ambiguous. ## ℹ Use `all_of(stage_codes)` instead of `stage_codes` to silence this message. ## ℹ See &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;. ## This message is displayed once per session. ## SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 ## 1 6.0 11.8 -3.8 1.9 1.0 0.1 4.1 579.9 7.5 -3.8 ## 2 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 ## 3 -4.3 2.1 -10.3 4.5 5.4 -16.1 1.2 -20.1 1.1 -5.2 (A similar technique could be used to recreate stage times from the overall times.) 4.3 Visualising Overall Results The overall stage results provides information regarding the overall times and positions at the end of each stage; the rebased overall times provide us with gap information from a specified driver to every other driver. So how might we use exploratory data visualisation techniques to support a conversation with that data or highlight potential stories hidden within it? 4.3.1 Visualising First Position One way of enriching the wide position table might be to highlight the driver in first position at the end of each stage. We can do this using the formattable::formattable() function. First, let’s tidy up the overall position table: multi_overall_wide_pos = multi_overall_wide_pos %&gt;% map_stage_codes(stage_codes) %&gt;% map_driver_names(cars) multi_overall_wide_pos %&gt;% head(2) ## code SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 ## 1 OGI 9 9 9 8 8 7 6 22 20 20 ## 2 EVA 5 5 5 5 5 5 5 5 5 5 We can also reorder the table by the final stage position, as described by the last stage code in the stage_codes list. However, because we want to sort on a column name as provided by a variable, we need to use the !! operator to force the evaluation of the single variable value to the column name symbol (as.symbol()): multi_overall_wide_pos = multi_overall_wide_pos %&gt;% dplyr::arrange(!!as.symbol(stage_codes[length(stage_codes)])) multi_overall_wide_pos %&gt;% head(2) ## code SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 ## 1 TÄN 1 1 1 1 1 1 1 1 1 1 ## 2 ROV 3 3 3 2 2 2 2 2 2 2 Create a function to highlight the first position car: library(formattable) highlight_first = function (...) { formatter(&quot;span&quot;, style = function(x) ifelse(x==1, style(display = &quot;block&quot;, padding = &quot;0 4px&quot;, `color` = &quot;black&quot;, `column-width`=&#39;4em&#39;, `border-radius` = &quot;4px&quot;, `background-color` = &#39;lightgrey&#39;), style())) } And then use that function to help style the table: multi_overall_wide_pos %&gt;% head(3) %&gt;% formattable(# Align values in the center of each column align=&#39;c&#39;, list(area(col = stage_codes) ~ highlight_first())) code SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 TÄN 1 1 1 1 1 1 1 1 1 1 ROV 3 3 3 2 2 2 2 2 2 2 NEU 4 4 4 4 4 3 3 3 3 3 4.3.2 Visualising Position Changes Over a Rally Another useful way of summarising the positions is to chart showing the evolution of position changes. The chart is constructed most straightforwardly from tidy (long format) data: overall_pos_long_top10 &lt;- multi_overall_wide_pos %&gt;% head(10) %&gt;% #gather(key =&quot;Stage&quot;, # value =&quot;Pos&quot;, # stage_codes) # pivot longer replaces gather pivot_longer(c(stage_codes), names_to =&quot;Stage&quot;, values_to =&quot;Pos&quot;) overall_pos_long_top10 %&gt;% head(3) ## # A tibble: 3 x 3 ## code Stage Pos ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 TÄN SS1 1 ## 2 TÄN SS2 1 ## 3 TÄN SS3 1 It will be convenient for the stage codes to be represented as ordered factors: overall_pos_long_top10 = overall_pos_long_top10 %&gt;% mutate(Stage = factor(Stage, levels = stage_codes)) overall_pos_long_top10$Stage[1] ## [1] SS1 ## Levels: SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 We can then create a bump chart style plot showing how each driver’s positioned changed across stages: library(ggplot2) pos_range = 1:max(overall_pos_long_top10$Pos) g_pos = ggplot(overall_pos_long_top10, aes(x=Stage, y=Pos)) + geom_line(aes(group = code)) + # Invert scale and relabel y-axis # https://stackoverflow.com/a/28392170/454773 scale_y_continuous(trans = &quot;reverse&quot;, breaks = pos_range) + theme_classic() g_pos We can producing a cleaner chart by adding driver labels to the start and end of each line using the directlabels:geom_dl() function, as well as dropping the axes: library(directlabels) g_pos + geom_dl(aes(label = paste0(&#39; &#39;,code)), # Add space before label # Add label at end of line method = list(&#39;last.bumpup&#39;, # cex is text label size cex = 0.5)) + geom_dl(aes(label = paste0(code, &#39; &#39;)), # Add space before label # Add label at start of line method = list(&#39;first.points&#39;, cex = 0.5)) + theme_void() In the above chart, you may notice a gap at first stage position 6 where Ogier was originally placed. A more robust way to prepare the data for this sort of charts is to filter the data by class, for example limiting the data to cars in the WRC group/class, and then reranking the position by group/class. A finished position chart can then position the drivers by class ranking and use labels to overplot actual overall rally positions on stages where the overall stage position differs from the class rank. 4.3.3 Visualising Position Gains/Losses To visualise position changes for a driver from one driver to the next, we can create a table of position differences. Let’s abstract out the code we used to find differences between columns in to a function: coldiffs = function(df, cols, dropfirst=FALSE, firstcol=NULL){ cols = as.character(cols) # [-1] drops the first column, [-ncol()] drops the last df_ = df[,cols][-1] - df[,cols][-ncol(df[,cols])] # The split time to the first split is simply the first split time df_[cols[1]] = df[cols[1]] # Return the dataframe in a sensible column order df_ = df_ %&gt;% select(cols) if (!is.null(firstcol)) df_[, cols[1]] = firstcol if (dropfirst) df_[,cols][-1] else df_ } Let’s put that function through its paces. First, we can drop the first column: coldiffs(multi_overall_wide_pos, stage_codes, dropfirst=TRUE) %&gt;% head(2) ## Note: Using an external vector in selections is ambiguous. ## ℹ Use `all_of(cols)` instead of `cols` to silence this message. ## ℹ See &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;. ## This message is displayed once per session. ## SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 ## 1 0 0 0 0 0 0 0 0 0 ## 2 0 0 -1 0 0 0 0 0 0 Then we can retain the first column and replace it with a specified value: coldiffs(multi_overall_wide_pos, stage_codes, firstcol=999) %&gt;% head(2) ## SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 ## 1 999 0 0 0 0 0 0 0 0 0 ## 2 999 0 0 -1 0 0 0 0 0 0 We can now fund the position changes from stage to stage as well as tidying up the identifiers: pos_diffs = multi_overall_wide_pos %&gt;% coldiffs(stage_codes, firstcol=0) pos_diffs$code = multi_overall_wide_pos$code # Reorder the columns by moving last column to first pos_diffs = pos_diffs %&gt;% select(&#39;code&#39;, everything()) pos_diffs %&gt;% head(3) ## code SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 ## 1 TÄN 0 0 0 0 0 0 0 0 0 0 ## 2 ROV 0 0 0 -1 0 0 0 0 0 0 ## 3 NEU 0 0 0 0 0 -1 0 0 0 0 Note that we need to be careful with the sense of how we read this table: a negative position change means the driver has improved their position. It might be more meaningful to have position gain/loss, rather than strict position difference columns, where a positive value denotes an improved position: pos_gains = pos_diffs pos_gains[,stage_codes] = -pos_gains[,stage_codes[-1]] pos_gains %&gt;% head(3) ## code SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 ## 1 TÄN 0 0 0 0 0 0 0 0 0 0 ## 2 ROV 0 0 1 0 0 0 0 0 0 0 ## 3 NEU 0 0 0 0 1 0 0 0 0 0 One way of highlighting position changes is to use coloured up/down arrows: updown = function(...){ formatter(&quot;span&quot;, style = function(x) style(color = ifelse(x&gt;0, &quot;green&quot;, ifelse(x&lt;0, &quot;red&quot;, &quot;lightgrey&quot;))), function(x) icontext(ifelse (x &gt;0, # i.e. gained position &quot;arrow-up&quot;, ifelse (x &lt; 0, # Lost position &quot;arrow-down&quot; , # No position change &quot;resize-horizontal&quot;)))) } Let’s see how that works (note that we need to cast the table as.htmlwidget() in order to render the arrows appropriately : pos_gains %&gt;% head(3) %&gt;% formattable(list( area(col = stage_codes) ~ updown())) %&gt;% as.htmlwidget() We can extend the formatter to also display the number of positions gained or lost: updown2 = function(...){ formatter(&quot;span&quot;, style = function(x) style(color = ifelse(x&gt;0, &quot;green&quot;, ifelse(x&lt;0, &quot;red&quot;, &quot;lightgrey&quot;))), function(x) icontext(ifelse (x &gt;0, # i.e. gained position &quot;arrow-up&quot;, ifelse (x &lt; 0, &quot;arrow-down&quot; , &quot;resize-horizontal&quot;)), # Add in the pos change value ifelse (x!=0, paste0(&#39;(&#39;,abs(x),&#39;)&#39;),&#39;&#39;))) } Let’s see how it looks: pos_gains %&gt;% head(3) %&gt;% formattable(list( area(col = stage_codes) ~ updown2())) %&gt;% as.htmlwidget() Another way of visualising position changes is to create a simple summarising sparkline using the sparkline::spk_chr() function. This requires us first to cast the data into a long format: library(sparkline) pos_gain_long_top10 &lt;- pos_gains %&gt;% head(10) %&gt;% gather(key =&quot;Stage&quot;, value =&quot;PosChange&quot;, stage_codes) pos_gain_long_top10 %&gt;% head(3) ## code Stage PosChange ## 1 TÄN SS1 0 ## 2 ROV SS1 0 ## 3 NEU SS1 0 We can then generate sparklines showing position changes: pos_gain_sparkline_top10 &lt;- pos_gain_long_top10 %&gt;% group_by(code) %&gt;% summarize(spk_ = spk_chr(PosChange, type =&quot;bar&quot;)) # We need to create an htmlwidget form of the table out = as.htmlwidget(formattable(pos_gain_sparkline_top10)) # The table also has a requirement on the sparkline package out$dependencies = c(out$dependencies, htmlwidgets:::widget_dependencies(&quot;sparkline&quot;, &quot;sparkline&quot;)) out Note that to render the sparkline, we need to cast the formatted table to an htmlwidget and also ensure that the required sparkline Javascript package is loaded into the widget. One issue with the sparkline bars is that the scales may differ. For example, across different drivers, a position change of +1 for one driver may have the same height as a position change of +2 for another driver. 4.3.4 Per Driver Position Charts As well as generating summary chapters over a set of drivers, we can also generate charts on a per driver basis, cf. sparkline charts. For example, we can create a simple chart that captures a single driver’s position over several stages, optionally using the gt::ggplot_image() function to create an HTML embeddable image tag with the chart encoded as a data URI: rovCode = get_person_id(cars, &#39;rov&#39;, ret=&#39;code&#39;) get_pos_chart = function(df_long, code, embed=FALSE, height=30, aspect_ratio=1, size=5) { # Get the data for the specified driver subdf = df_long[df_long[&#39;code&#39;]==code,] ymax = max(10.6, max(subdf$Pos)+0.1) g = ggplot(subdf, aes(x=as.integer(Stage), y=Pos, group=code)) + geom_step(direction=&#39;mid&#39;, color=&#39;blue&#39;, size=size) + geom_hline(yintercept=0.8, linetype=&#39;dotted&#39;, size=size, color=&#39;black&#39;) + geom_hline(yintercept=3.35, linetype=&#39;dotted&#39;, size=size, color=&#39;black&#39;) + geom_hline(yintercept=10.5, color=&#39;darkgrey&#39;, size=size) + #scale_y_continuous(trans = &quot;reverse&quot;) + scale_y_reverse( lim=c(ymax, 0.8)) + theme_void() + scale_x_continuous(expand=c(0,0)) #+ #theme(aspect.ratio=0.1) if (embed) gt::ggplot_image(g, height = height, aspect_ratio=aspect_ratio) else g } get_pos_chart(overall_pos_long_top10, rovCode) If we generate an image for each driver, we can then create a column of images to showing the change in position over the rally for each one on a row by row basis: overall_wide_pos_top5 = multi_overall_wide_pos %&gt;% head(5) top5codes = overall_wide_pos_top5$code gt_pos_plots = list() # Iterate through each driver in the top 5 for (c in 1:length(top5codes)){ # Add each plot to the plot list # The split is generated for the top 5 gt_pos_plots[[length(gt_pos_plots) + 1]] &lt;- get_pos_chart(overall_pos_long_top10, top5codes[c], embed=T, aspect_ratio=3, size=5) } We can then add the charts to the wide timing results dataframe as an extra column: overall_wide_pos_top5$poschart = gt_pos_plots formattable(overall_wide_pos_top5) code SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 poschart TÄN 1 1 1 1 1 1 1 1 1 1 ROV 3 3 3 2 2 2 2 2 2 2 NEU 4 4 4 4 4 3 3 3 3 3 BRE 2 2 2 3 3 4 4 4 4 4 EVA 5 5 5 5 5 5 5 5 5 5 # How do we suppress stripes in formattable tables? 4.3.5 Visualising Time to First A convenient way of visualising the gap to leader across stages is to create a sparkline using the sparkline::spk_chr() function. This function requires data in a tidy (long) format which is then grouped for each driver. Let’s remind ourselves of what the data looks like: multi_overall_wide_gap_top10 = multi_overall_wide_gap %&gt;% map_stage_codes(stage_list) %&gt;% map_driver_names(cars) %&gt;% dplyr::arrange(!!as.symbol(stage_codes[length(stage_codes)])) %&gt;% head(10) multi_overall_wide_gap_top10 ## code SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 ## 1 TÄN 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 ## 2 ROV 10.6 20.4 26.1 21.2 23.6 25.0 23.3 24.1 19.2 17.5 ## 3 NEU 12.4 29.8 30.8 29.2 34.7 34.9 38.2 25.9 21.1 19.8 ## 4 BRE 3.6 16.2 23.6 22.4 28.9 42.8 50.6 53.4 54.0 52.6 ## 5 EVA 16.7 32.0 43.3 37.2 37.3 53.6 55.7 63.5 57.6 61.5 ## 6 KAT 19.9 38.8 47.5 46.6 52.4 74.5 83.8 94.4 93.2 97.8 ## 7 SOL 31.1 45.9 50.5 49.4 51.3 62.7 80.4 86.8 84.2 99.0 ## 8 SUN 18.8 34.5 46.9 54.1 70.9 82.1 98.2 109.3 117.3 129.0 ## 9 GRE 41.8 65.8 84.7 94.6 112.1 134.3 156.5 181.8 200.5 219.4 ## 10 LAP 42.8 88.2 123.4 146.9 186.2 215.8 239.3 288.8 327.1 367.0 We can create the required long form data from the wide gap table as follows, retrieving just the top 10 drivers based on the gap on the final stage, for convenience: overall_long_gap_top10 &lt;- multi_overall_wide_gap_top10 %&gt;% gather(key =&quot;Stage&quot;, value =&quot;Gap&quot;, stage_codes) overall_long_gap_top10 %&gt;% head(3) ## code Stage Gap ## 1 TÄN SS1 0.0 ## 2 ROV SS1 10.6 ## 3 NEU SS1 12.4 With the data in the appropriate form, we can create the sparkline, using a bar chart format: overall_long_gap_top10 &lt;- overall_long_gap_top10 %&gt;% group_by(code) %&gt;% summarize(spk_ = spk_chr(-Gap, type =&quot;bar&quot;)) spark_df = function(df){ # We need to create an htmlwidget form of the table out = as.htmlwidget(formattable(df)) # The table also has a requirement on the sparkline package out$dependencies = c(out$dependencies, htmlwidgets:::widget_dependencies(&quot;sparkline&quot;, &quot;sparkline&quot;)) out } spark_df(overall_long_gap_top10) 4.3.6 Visualising Rebased Gaps As well as using the sparkline bar chart to visualise the gap to leader, we can use a similar approach to visualise the gap to other drivers following a rebasing step. overall_wide_gap_rebased = rebase(multi_overall_wide_gap_top10, example_driver, stage_codes, id_col=&#39;code&#39;) overall_wide_gap_rebased ## code SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 ## 1 TÄN -16.7 -32.0 -43.3 -37.2 -37.3 -53.6 -55.7 -63.5 -57.6 -61.5 ## 2 ROV -6.1 -11.6 -17.2 -16.0 -13.7 -28.6 -32.4 -39.4 -38.4 -44.0 ## 3 NEU -4.3 -2.2 -12.5 -8.0 -2.6 -18.7 -17.5 -37.6 -36.5 -41.7 ## 4 BRE -13.1 -15.8 -19.7 -14.8 -8.4 -10.8 -5.1 -10.1 -3.6 -8.9 ## 5 EVA 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 ## 6 KAT 3.2 6.8 4.2 9.4 15.1 20.9 28.1 30.9 35.6 36.3 ## 7 SOL 14.4 13.9 7.2 12.2 14.0 9.1 24.7 23.3 26.6 37.5 ## 8 SUN 2.1 2.5 3.6 16.9 33.6 28.5 42.5 45.8 59.7 67.5 ## 9 GRE 25.1 33.8 41.4 57.4 74.8 80.7 100.8 118.3 142.9 157.9 ## 10 LAP 26.1 56.2 80.1 109.7 148.9 162.2 183.6 225.3 269.5 305.5 And now generate the sparklines: overall_spark_gap_rebased &lt;- overall_wide_gap_rebased %&gt;% gather(key =&quot;Stage&quot;, value =&quot;Gap&quot;, stage_codes) %&gt;% group_by(code) %&gt;% summarize(spk_ = spk_chr(Gap, type =&quot;bar&quot;)) spark_df(overall_spark_gap_rebased) 4.4 Retrieving Stage Times and Results This far, we have focused on exploring the overall results data. If required, we can also retrieve detailed results for multiple stages by requesting stage results for a specified list of stages: multi_stage_times = get_multi_stage_times(stage_list) multi_stage_times %&gt;% tail(2) ## stageTimeId stageId entryId elapsedDurationMs elapsedDuration status ## 539 96810 1749 21571 1301693 00:21:41.6930000 Completed ## 540 96793 1749 21541 NA &lt;NA&gt; DNS ## source position diffFirstMs diffFirst diffPrevMs diffPrev ## 539 Default 52 699224 00:11:39.2240000 153590 00:02:33.5900000 ## 540 Default NA NA &lt;NA&gt; NA &lt;NA&gt; We can then cast the data to a wide format and relabel the resulting dataframe. One recipe for doing this is pretty well proven now, so let’s make it more convenient: relabel_times_df = function(df, stage_list, cars) { df %&gt;% map_stage_codes(stage_list) %&gt;% map_driver_names(cars) } And let’s create another function to relabel a dataframe and grab the top 10: clean_top10 = function(df) { df %&gt;% relabel_times_df(stage_list, cars) %&gt;% dplyr::arrange(!!as.symbol(stage_codes[length(stage_codes)])) %&gt;% head(10) } We can now get a wide format dataframe containing individual stage times cleaned and reduced to the top 10: multi_stage_times_wide = multi_stage_times %&gt;% get_multi_stage_times_wide(stage_list) %&gt;% clean_top10() multi_stage_times_wide ## code SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 ## 1 ROV 968.4 962.7 840.2 547.8 752.5 838.7 548.8 777.1 608.5 602.469 ## 2 BRE 961.4 965.5 841.9 551.5 756.6 851.2 558.3 779.1 614.0 602.731 ## 3 NEU 970.2 970.3 835.5 551.1 755.6 837.5 553.8 764.0 608.6 602.834 ## 4 TÄN 957.8 952.9 834.5 552.7 750.1 837.3 550.5 776.3 613.4 604.114 ## 5 OGI 980.5 980.0 842.0 548.5 751.2 853.7 556.7 1364.0 615.0 604.272 ## 6 EVA 974.5 968.2 845.8 546.6 750.2 853.6 552.6 784.1 607.5 608.028 ## 7 KAT 977.7 971.8 843.2 551.8 755.9 859.4 559.8 786.9 612.2 608.774 ## 8 SUN 976.6 968.6 846.9 559.9 766.9 848.5 566.6 787.4 621.4 615.819 ## 9 SOL 988.9 967.7 839.1 551.6 752.0 848.7 568.2 782.7 610.8 618.976 ## 10 GRE 999.6 976.9 853.4 562.6 767.6 859.5 572.7 801.6 632.1 623.075 Or we can get the stage rankings for each stage: multi_stage_wide_pos = multi_stage_times %&gt;% get_multi_stage_generic_wide(stage_list, &#39;position&#39;) %&gt;% clean_top10() multi_stage_wide_pos %&gt;% head(2) ## code SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 ## 1 ROV 3 2 4 2 5 3 1 3 2 1 ## 2 BRE 2 3 5 5 8 6 6 4 7 2 Or the gap to stage winner: multi_stage_wide_gap = multi_stage_times %&gt;% mutate(diffFirstS = diffFirstMs/1000) %&gt;% get_multi_stage_generic_wide(stage_list, &#39;diffFirstS&#39;) %&gt;% clean_top10() multi_stage_wide_gap %&gt;% head(2) ## code SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 ## 1 ROV 10.6 9.8 5.7 1.2 2.4 1.4 0.0 13.1 1.0 0.000 ## 2 BRE 3.6 12.6 7.4 4.9 6.5 13.9 9.5 15.1 6.5 0.262 4.5 Visualising Stage Times Two of the most useful chart types, at least in terms of glanceable displays, that we can generate from the detailed stage times over the course of the rally are at the individual level: sparklines showing the individual stage positions and the gap to stage winner. So let’s start off with those before looking at grouped and individual stage position charts. 4.5.1 Stage Position Sparklines Our pattern is now pretty well proven so we can routinise our sparkline production: generate_spark_bar = function(df, col, typ=&#39;Gap&#39;){ df %&gt;% gather(key =&quot;Stage&quot;, value =!!typ, stage_codes) %&gt;% group_by(code) %&gt;% summarize(spk_ = spk_chr(-!!as.symbol(typ), type =&quot;bar&quot;)) } Let’s see how it works: multi_stage_long_pos = generate_spark_bar(multi_stage_wide_pos) spark_df(multi_stage_long_pos) 4.5.2 Gap to Stage Winner Sparklines For the gap to stage winner, multi_stage_long_gap = generate_spark_bar(multi_stage_wide_gap) spark_df(multi_stage_long_gap) 4.5.3 Stage Position Charts Let’s reuse the approach we used before for generating the position chart: multi_stage_long_pos = multi_stage_wide_pos %&gt;% pivot_longer(c(stage_codes), names_to =&quot;Stage&quot;, values_to =&quot;Pos&quot;) %&gt;% mutate(Stage = factor(Stage, levels = stage_codes)) pos_range = 1:max(multi_stage_long_pos$Pos) ggplot(multi_stage_long_pos, aes(x=Stage, y=Pos)) + geom_line(aes(group = code)) + # Invert scale and relabel y-axis # https://stackoverflow.com/a/28392170/454773 scale_y_continuous(trans = &quot;reverse&quot;, breaks = pos_range) + geom_dl(aes(label = paste0(&#39; &#39;,code)), # Add space before label # Add label at end of line method = list(&#39;last.bumpup&#39;, # cex is text label size cex = 0.5)) + geom_dl(aes(label = paste0(code, &#39; &#39;)), # Add space before label # Add label at start of line method = list(&#39;first.points&#39;, cex = 0.5)) + theme_void() In this case we see the very obvious problem presented by drivers falling outside the typical position range. We really do need to organise this chart by group rank! 4.5.4 Individual Stage position Charts At the individual level, we can also reuse the approach we developed for charting overall stage positions at an individual level: get_pos_chart(multi_stage_long_pos, rovCode) top10_codes = multi_stage_wide_pos$code gt_stage_pos_plots = list() # Iterate through each driver in the top 5 for (c in 1:length(top10_codes)){ # Add each plot to the plot list gt_stage_pos_plots[[length(gt_stage_pos_plots) + 1]] &lt;- get_pos_chart(multi_stage_long_pos, top10_codes[c], embed=T, aspect_ratio=3, size=5) } multi_stage_wide_pos$poschart = gt_stage_pos_plots formattable(multi_stage_wide_pos) code SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 poschart ROV 3 2 4 2 5 3 1 3 2 1 BRE 2 3 5 5 8 6 6 4 7 2 NEU 4 7 2 4 6 2 4 1 3 3 TÄN 1 1 1 8 1 1 2 2 6 4 OGI 9 10 6 3 3 8 5 47 8 5 EVA 5 5 9 1 2 7 3 6 1 6 KAT 8 8 7 7 7 9 7 7 5 7 SUN 7 6 10 9 10 4 8 8 10 8 SOL 10 4 3 6 4 5 9 5 4 9 GRE 11 9 11 11 11 10 10 9 11 10 "],["finding-pace-across-stages.html", "5 Finding Pace Across Stages 5.1 Load Base Data 5.2 Defining Pace 5.3 Calculating Stage Pace 5.4 Rebasing Stage Pace 5.5 The Ultimate Rally", " 5 Finding Pace Across Stages Average speed on a rally is all very well, but it’s not the most useful of metrics for making sense of what’s actually going on in a rally. Far more useful is the notion of pace the reciprocal of a speed like measure, that tells you how many seconds it’s taking each driver to cover one kilometer. Knowing the pace allows you to make more direct comparisons between drivers, as well as simplifying rule of thumb calculations, like what sort of pace advantage a driver needs to make up the 2s to the leader over the remaining 100 kilometers available in the final four stages… In this chapter, we look at some simple pace calculations, rebase pace values relative to a specified driver, and explore a couple of ways of visualising differential pace over the course of a rally in the form of pace maps and off-the-pace charts. 5.1 Load Base Data To get the stage data from a standing start, we can load in the current season list, select the rally we want, look up the itinerary from the rally, extract the sections and then the stages, and from that access the stage ID for the stage or stages we are interested in. Load in the helper functions: source(&#39;code/wrc-api.R&#39;) And get the base data: s = get_active_season() eventId = get_eventId_from_name(s, &#39;arctic&#39;) itinerary = get_itinerary(eventId) sections = get_sections(itinerary) stages = get_stages(sections) stages_lookup = get_stages_lookup(stages) # Driver details entries = get_rally_entries(eventId) cars = get_car_data(entries) Get a sample stage ID: stageId = stages_lookup[[&#39;SS3&#39;]] 5.2 Defining Pace With variable stage distances on a stage rally, metrics such as average speed provide one way of comparing performances across stage, calculated as \\(\\textrm{stage_time}/\\textrm{stage_distance}\\) with units of kilometers or miles per hour. A more useful measure, particularly in rally terms, is the notion of pace, typically given with units of seconds per kilometer. Speed tells us much quickly a car covers distance in unit time; pace gives us an indication of how much time is required to travel a unit distance. When used as a rebased difference measure between drivers, pace difference allows us to rapidly calculate how much time a driver is likely to gain or lose over a particular stage distance as per the word equation \\(\\textrm{time_gain}=\\textrm{stage_distance}\\cdot\\textrm{pace_difference}\\). Basic pace itself is given as \\(\\textrm{pace}=\\textrm{time}/\\textrm{distance}\\). Developing our rally algebra, we might identify the stage distance for stage \\(S\\) as \\(d_S\\). For a stage time by driver \\(i\\) of \\({_S}t_i\\) the stage pace \\({_S}p_i\\) for driver \\(i\\) on stage \\(S\\) is then given as: \\[ {_S}p_i = \\frac{{_S}t_i}{d_S} \\] 5.3 Calculating Stage Pace We can calculate stage pace from stage times and stage distances. We can find stages distances directly from the stages dataframe: stages %&gt;% select(c(&#39;code&#39;,&#39;distance&#39;)) %&gt;% head(3) ## code distance ## 1 SS1 31.05 ## 2 SS2 31.05 ## 3 SS3 24.43 5.3.1 Calculating Pace for a Single Stage Let’s start by looking a single stage using a recipe we have used before: # Example stage code stage_code = &#39;SS3&#39; stageId = stages_lookup[[stage_code]] # Get the stage distance stage_distance = stages[stages[&#39;code&#39;]==stage_code, &#39;distance&#39;] # Get driver metadata cars = get_car_data(entries) # Create stage times with merged in driver metadata stage_times = get_stage_times(eventId, stageId) %&gt;% arrange(position) %&gt;% head(10) %&gt;% # Merge in the entries data merge(cars, by=&#39;entryId&#39;) %&gt;% # Convert milliseconds to seconds mutate(TimeInS = elapsedDurationMs/1000) %&gt;% # Limit columns and set column order select(c(&#39;position&#39;, &#39;identifier&#39;, &#39;code&#39;, &#39;TimeInS&#39;)) %&gt;% # The merge may upset the row order # so reset the order again arrange(position) %&gt;% # Improve column names by renaming them rename(Pos=position, Car = identifier, Code = code, `Time (s)` = TimeInS) formattable(stage_times ) Pos Car Code Time (s) 1 8 TÄN 834.5 2 11 NEU 835.5 3 2 SOL 839.1 4 69 ROV 840.2 5 42 BRE 841.9 6 1 OGI 842.0 7 18 KAT 843.2 8 7 LOU 844.3 9 33 EVA 845.8 10 3 SUN 846.9 We can now calculate pace as the stage time divided by the stage distance: stage_times$pace = stage_times$&#39;Time (s)&#39; / stage_distance stage_times ## Pos Car Code Time (s) pace ## 1 1 8 TÄN 834.5 34.15882 ## 2 2 11 NEU 835.5 34.19975 ## 3 3 2 SOL 839.1 34.34711 ## 4 4 69 ROV 840.2 34.39214 ## 5 5 42 BRE 841.9 34.46173 ## 6 6 1 OGI 842.0 34.46582 ## 7 7 18 KAT 843.2 34.51494 ## 8 8 7 LOU 844.3 34.55997 ## 9 9 33 EVA 845.8 34.62137 ## 10 10 3 SUN 846.9 34.66639 5.3.2 Calculating Pace for Multiple Stages First, let’s get the data for all the stages: stage_list = get_stage_list(stages) multi_stage_times = get_multi_stage_times(stage_list) multi_stage_times %&gt;% tail(2) ## stageTimeId stageId entryId elapsedDurationMs elapsedDuration status ## 539 96810 1749 21571 1301693 00:21:41.6930000 Completed ## 540 96793 1749 21541 NA &lt;NA&gt; DNS ## source position diffFirstMs diffFirst diffPrevMs diffPrev ## 539 Default 52 699224 00:11:39.2240000 153590 00:02:33.5900000 ## 540 Default NA NA &lt;NA&gt; NA &lt;NA&gt; We can generate the pace by adding the stage distance as an extra column and performing the pace calculation. We’ll also take the opportunity to merge in driver metadata and limit cars to WRC group entries: get_multi_stage_pace = function(multi_stage_times, cars) { multi_stage_times %&gt;% merge(stages[,c(&#39;stageId&#39; ,&#39;distance&#39;, &#39;number&#39;, &#39;code&#39;)], by=&#39;stageId&#39;) %&gt;% mutate(elapsedDurationS = elapsedDurationMs / 1000, pace = elapsedDurationS / distance) %&gt;% merge(cars[,c(&#39;entryId&#39;,&#39;drivername&#39;, &#39;code&#39;, &#39;groupname&#39;)], by=&#39;entryId&#39;, suffixes=c(&#39;&#39;,&#39;_driver&#39;)) %&gt;% filter(groupname==&#39;WRC&#39;) %&gt;% select(c(&#39;stageId&#39;, &#39;number&#39;, &#39;code_driver&#39;, &#39;elapsedDurationS&#39;, &#39;pace&#39;, &#39;code&#39;)) %&gt;% arrange(number, elapsedDurationS) } multi_stage_pace = get_multi_stage_pace(multi_stage_times, cars) multi_stage_pace %&gt;% head(3) ## stageId number code_driver elapsedDurationS pace code ## 1 1747 1 TÄN 957.8 30.84702 SS1 ## 2 1747 1 BRE 961.4 30.96296 SS1 ## 3 1747 1 ROV 968.4 31.18841 SS1 Create a mapping from stage ID to stage codes and cast the ordered list of stage Ids to an ordered list of stage codes: get_stage_codes = function(stages){ # Create a stage code mapping function stages_lookup_code = get_stages_lookup(stages, &#39;stageId&#39;, &#39;code&#39;) stage_code_map = function(stageId) stages_lookup_code[[as.character(stageId)]] # Map stage ID column names to stage codes stage_codes = unlist(purrr::map(stage_list, function (x) stage_code_map(x))) stage_codes } stage_codes = get_stage_codes(stages) Use the generic widener function to widen the pace dataframe to give the pace for each driver on each stage: pace_wide = get_multi_stage_generic_wide(multi_stage_pace, stage_codes, &#39;pace&#39;, # Unique group keys required # Driver code not guaranteed unique group_key=c(&#39;code_driver&#39;), spread_key=&#39;code&#39;) pace_wide %&gt;% head(3) ## code_driver SS1 SS2 SS3 SS4 SS5 SS6 SS7 ## 1 BER 32.66345 32.84380 58.71879 57.58915 48.77529 58.83340 57.69965 ## 2 BRE 30.96296 31.09501 34.46173 27.69965 27.33382 34.84241 28.04119 ## 3 EVA 31.38486 31.18196 34.62137 27.45354 27.10260 34.94065 27.75490 ## SS8 SS9 SS10 ## 1 49.27746 28.69159 28.64174 ## 2 28.14668 27.32532 26.82381 ## 3 28.32731 27.03605 27.05955 5.4 Rebasing Stage Pace We can rebase the stage pace according to a specific driver: example_driver = pace_wide[2,]$code_driver pace_wide_rebased = rebase(pace_wide, example_driver, stage_codes, id_col=&#39;code_driver&#39;) pace_wide_rebased %&gt;% head(3) ## code_driver SS1 SS2 SS3 SS4 SS5 SS6 ## 1 BER 1.7004831 1.74879227 24.2570610 29.8895028 21.4414740 23.99099468 ## 2 BRE 0.0000000 0.00000000 0.0000000 0.0000000 0.0000000 0.00000000 ## 3 EVA 0.4219002 0.08695652 0.1596398 -0.2461075 -0.2312139 0.09823987 ## SS7 SS8 SS9 SS10 ## 1 29.6584631 21.1307803 1.3662661 1.8179350 ## 2 0.0000000 0.0000000 0.0000000 0.0000000 ## 3 -0.2862883 0.1806358 -0.2892746 0.2357365 More abstractly, the rebased pace, \\({_S}p_i^j\\), for driver \\(i\\) relative to driver \\(j\\) on stage \\(S\\) is given as: \\[ {_S}p_i^j = {_S}p_i - {_S}p_j = \\frac{{_S}t_i - {_S}t_j}{d_S} = \\frac{{_S}t_i^j}{d_S} \\] 5.5 The Ultimate Rally Finally, in passing, it is worth noting that we can calculate an “ultimate rally” time from the sum of th fastest stage times completed on the rally, by any driver. This gives us the fastest possible rally time from recorded stage times against which we can compare the performance of the rally winner. (Of course, it might be that a particularly fast time on one stage by a particular driver ruined the rest of their loop!) Furthermore, when split times are available, we can go even further and construct and ultimate ultimate (sic) rally time from ultimate stage times that have themselves been constructed from ultimate split times on the stage. "],["visualising-stage-pace.html", "6 Visualising Stage Pace 6.1 Load Base Data 6.2 Pace Maps 6.3 A Pace Map Function 6.4 Off-the-Pace Charts 6.5 Comparing Pace Across Stages", " 6 Visualising Stage Pace In this chapter, we’ll start to explore various ways in which we might visualise pace data. 6.1 Load Base Data To get the stage data from a standing start, we can load in the current season list, select the rally we want, look up the itinerary from the rally, extract the sections and then the stages, and from that access the stage ID for the stage or stages we are interested in. Load in the helper functions: source(&#39;code/wrc-api.R&#39;) source(&#39;code/wrc-wrangling.R&#39;) source(&#39;code/wrc-charts.R&#39;) And get the base data: s = get_active_season() eventId = get_eventId_from_name(s, &#39;arctic&#39;) itinerary = get_itinerary(eventId) sections = get_sections(itinerary) stages = get_stages(sections) stages_lookup = get_stages_lookup(stages) stage_list = get_stage_list(stages) stage_codes = get_stage_codes(stages) # Driver details entries = get_rally_entries(eventId) cars = get_car_data(entries) Get a sample stage ID: stageId = stages_lookup[[&#39;SS3&#39;]] Let’s also get some pace data: multi_stage_times = get_multi_stage_times(stage_list) multi_stage_pace = get_multi_stage_pace(multi_stage_times, cars) pace_wide = get_multi_stage_generic_wide(multi_stage_pace, stage_codes, &#39;pace&#39;, # Unique group keys required # Driver code not guaranteed unique group_key=c(&#39;code_driver&#39;), spread_key=&#39;code&#39;) example_driver = pace_wide[2,]$code_driver pace_wide_rebased = rebase(pace_wide, example_driver, stage_codes, id_col=&#39;code_driver&#39;) 6.2 Pace Maps To compare pace, it is useful to look at rebased pace times relative to a particular driver and also indicate the length of stage with which particular pace levels are associated. We can do this with a chart that presents distance into stage along the horizontal x-axis and relative pace on the y axis, using a line to indicate the pace for each driver relative to a specified driver. One of the easiest way of plotting charts is to plot from a tidy dataframe, so let’s cast the rebased wide pace dataframe back to a long form and also add in the distance into stage at the start and end of each stage: library(tidyr) stage_range = c(start=stage_codes[1], end=stage_codes[length(stage_codes)]) stages$cum_dist = cumsum(stages$distance) stages$start_dist = c(0, stages$cum_dist[-length(stages$cum_dist)]) pace_stage = pace_wide_rebased %&gt;% gather(code, pace, stage_range[&#39;start&#39;]:stage_range[&#39;end&#39;]) %&gt;% merge(stages[,c(&#39;code&#39;, &#39;start_dist&#39;, &#39;cum_dist&#39;)], by=&#39;code&#39;) pace_stage %&gt;% head(3) ## code code_driver pace start_dist cum_dist ## 1 SS1 BER 1.7004831 0 31.05 ## 2 SS1 BRE 0.0000000 0 31.05 ## 3 SS1 EVA 0.4219002 0 31.05 We can now construct a chart using line segments to represent the pace for each driver on each stage: library(ggplot2) g0 = ggplot(pace_stage, aes(group=code_driver)) + geom_hline(yintercept = 0, colour=&#39;lightgrey&#39;, linetype=&#39;dotted&#39;) + geom_segment(aes(x=start_dist, xend=cum_dist, y=pace, yend=pace), color = &#39;lightgrey&#39;) g = g0 + geom_text(aes(x=(start_dist+cum_dist)/2,y=pace+0.03, label=code_driver,group=code_driver), position = position_dodge(15), size=1) + coord_cartesian(ylim=c(-0.5,2)) + theme_classic() g We could highlight positive and negative differences in the label colourings: g0 + geom_text(aes(x=(start_dist+cum_dist)/2, y=ifelse(pace&gt;0,pace+0.03,pace-0.03), label=code_driver,group=code_driver, color=pace&gt;0), position = position_dodge(15), size=1) + coord_cartesian(ylim=c(-0.5,2)) + theme_classic() + theme(legend.position=&quot;none&quot;) We can also highlight values for a particular driver: g + geom_segment(data=pace_stage[pace_stage$code_driver==&#39;EVA&#39;,], aes(x=start_dist, xend=cum_dist, y=pace, yend=pace, color = pace&gt;0)) + theme(legend.position=&quot;none&quot;) Or abuse the gghiglight package to modify the aesthetics of unselected items: g + gghighlight::gghighlight(code_driver==&#39;EVA&#39;, unhighlighted_params=list(alpha=0.1)) Alternatively, abuse gghighlight() again with a negative form of selection to highlight items: g + gghighlight::gghighlight(code_driver!=&#39;EVA&#39;,label_key=code_driver, unhighlighted_params=list(color=&#39;blue&#39;)) We could even add a transparency layer bar to highlight the pace difference compared to a particular driver: g + geom_rect(data=pace_stage[pace_stage$code_driver==&#39;EVA&#39;,], aes(xmin=start_dist, xmax=cum_dist, ymin = ifelse(pace&gt;0,0,pace), ymax = ifelse(pace&gt;0,pace,0), fill = pace&gt;0, alpha=0.7)) + theme(legend.position=&quot;none&quot;) Could we perhaps also extend that a little to allow us to compare more drivers? pace_map_highlight = function(sub_df, m, n){ # If we don&#39;t grab the actual value # the referenced value is used... m_ = m geom_rect(data=sub_df, aes(xmin= start_dist + (m_-1) * (cum_dist - start_dist)/n, xmax= start_dist + m_ * (cum_dist - start_dist)/n, ymin = ifelse(pace&gt;0,0,pace), ymax = ifelse(pace&gt;0,pace,0), fill = pace&gt;0, alpha=0.7)) } pace_map_highlight_many = function(df, g, codes, idcol=&#39;code_driver&#39;){ n = length(codes) for (m in 1:n){ sub_df = df[df[idcol]==codes[m],] g = g + pace_map_highlight(sub_df, m, n) } g } Let’s try it with two drivers: pace_map_highlight_many(pace_stage, g, c(&#39;EVA&#39;, &#39;ROV&#39; )) + theme(legend.position=&quot;none&quot;) With multiple drivers, it may get difficult to see where the stages are delimited, so we might add separators to delimit them: g + geom_vline(data = stages, aes(xintercept = cum_dist), color=&#39;lightgrey&#39;, linetype=&#39;dotted&#39;) To highlight stages further, we could add a “banner” to the chart: g + geom_rect(data=pace_stage[pace_stage$code_driver==example_driver,], aes(xmin=0, xmax=max(cum_dist), ymin = 1.8, ymax = 2.0, alpha=0), fill = &#39;black&#39;) + geom_text(data=pace_stage[pace_stage$code_driver==example_driver,], aes(x=(cum_dist + start_dist)/2, label=code), y=1.9, color=&#39;yellow&#39;, size=3) + geom_segment(data=pace_stage[pace_stage$code_driver==example_driver,], aes(x=cum_dist, xend=cum_dist, y=1.8, yend=2.0), color=&#39;yellow&#39;) + theme(legend.position=&quot;none&quot;) 6.3 A Pace Map Function Let’s start to work up a function based on the above sketches that will generate a pace map for us directly from a long format pace dataframe. pace_map = function(pace_long, limits=c(-0.5,2), labels=TRUE, drivers=NULL, lines=TRUE, xstart=&#39;start_dist&#39;, xend=&#39;cum_dist&#39;, pace=&#39;pace&#39;, typ=&#39;bar&#39;, pace_label_offset=0.03, label_dodge=15, idcol=&#39;code_driver&#39;){ # There are downstream dependencies with colnames baked in atm... pace_long$start_dist = pace_long[[xstart]] pace_long$cum_dist = pace_long[[xend]] pace_long$pace = pace_long[[pace]] g0 = ggplot(pace_long, aes_string(group=idcol, label=idcol)) + geom_hline(yintercept = 0, colour=&#39;lightgrey&#39;, linetype=&#39;dotted&#39;) + geom_segment(aes(x=start_dist, xend=cum_dist, y=pace, yend=pace), color = &#39;lightgrey&#39;) if (lines) { lines_df = data.frame(cum_dist=unique(pace_long$cum_dist)) g0 =g0 + geom_vline(data=lines_df, aes(xintercept = cum_dist), color=&#39;lightgrey&#39;, linetype=&#39;dotted&#39;) } if (labels){ g0 = g0 + geom_text(aes(x= (start_dist+cum_dist)/2, y=pace+pace_label_offset), position = position_dodge(label_dodge), size=1) } if (!is.null(drivers) ){ if (typ==&#39;bar&#39;){ g0 = pace_map_highlight_many(pace_long, g0, c(drivers), idcol=idcol) } else if (typ==&#39;highlight&#39;) { focus = pace_long[pace_long[idcol] %in% c(drivers),] g0 = g0 + geom_segment(data=focus, aes(x=start_dist, xend=cum_dist, y=pace, yend=pace, color = pace&gt;0)) } } g0 = g0 + coord_cartesian(ylim=limits) g0 + theme_classic() + theme(legend.position=&quot;none&quot;) } Let’s try it: pace_map(pace_stage, drivers=c(&#39;EVA&#39;, &#39;ROV&#39;)) 6.4 Off-the-Pace Charts Another way or reviewing pace is to consider the gap to leader, or rebased gap to a particular driver across the stages, using distance into stage along the x-axis to locate the x-value and gap (measured in seconds) along the y-axis. A moment’s consideration suggests that the gradient (\\(\\textrm{change_in_gap}/\\textrm{change_in_distance}\\)) is a measure of pace. The slope of the line thus indicates relative pace between the focal driver and the other drivers. As with the pace map, if we have the data in a long, tidy form, we can create charts from it quite straightforwardly. So let’s add in the accumulated distance into stage and accumulated stage time for each time: off_the_pace = multi_stage_pace %&gt;% merge(stages[,c(&#39;stageId&#39;, &#39;cum_dist&#39;)], by=&#39;stageId&#39;) %&gt;% arrange(number) %&gt;% group_by(code_driver) %&gt;% mutate(totalDurationS = cumsum(elapsedDurationS)) off_the_pace %&gt;% head(3) ## # A tibble: 3 x 8 ## # Groups: code_driver [3] ## stageId number code_driver elapsedDurationS pace code cum_dist ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1747 1 TÄN 957.8 30.84702 SS1 31.05 ## 2 1747 1 BRE 961.4 30.96296 SS1 31.05 ## 3 1747 1 ROV 968.4 31.18841 SS1 31.05 ## # … with 1 more variable: totalDurationS &lt;dbl&gt; Now we can create a basic off-the pace chart: ggplot(off_the_pace, aes(x=cum_dist, y=totalDurationS, color=code_driver)) + geom_line() As with the pace map, the chart is often most informative if we rebase it relative to a particular driver. Let’s create a wide dataframe to simplify the rebasing process: off_the_pace_wide = get_multi_stage_generic_wide(off_the_pace, stage_codes, &#39;totalDurationS&#39;, group_key=c(&#39;code_driver&#39;), spread_key=&#39;code&#39;) off_the_pace_wide %&gt;% head(3) ## code_driver SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 ## 1 BER 1014.2 2034.0 3468.5 4615.1 5965.2 7402.5 8551.3 9915.3 10560.0 ## 2 BRE 961.4 1926.9 2768.8 3320.3 4076.9 4928.1 5486.4 6265.5 6879.5 ## 3 EVA 974.5 1942.7 2788.5 3335.1 4085.3 4938.9 5491.5 6275.6 6883.1 ## SS10 ## 1 11203.580 ## 2 7482.231 ## 3 7491.128 Now we can rebase: off_the_pace_wide_rebased = rebase(off_the_pace_wide, example_driver, stage_codes, id_col=&#39;code_driver&#39;) off_the_pace_wide_rebased %&gt;% head(3) ## code_driver SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 ## 1 BER 52.8 107.1 699.7 1294.8 1888.3 2474.4 3064.9 3649.8 3680.5 ## 2 BRE 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 ## 3 EVA 13.1 15.8 19.7 14.8 8.4 10.8 5.1 10.1 3.6 ## SS10 ## 1 3721.349 ## 2 0.000 ## 3 8.897 And cast back to the long, tidy form: off_the_pace_long = off_the_pace_wide_rebased %&gt;% gather(code, totalDurationGapS, stage_range[&#39;start&#39;]:stage_range[&#39;end&#39;]) %&gt;% merge(stages[,c(&#39;code&#39;, &#39;cum_dist&#39;)], by=&#39;code&#39;) off_the_pace_long %&gt;% head(3) ## code code_driver totalDurationGapS cum_dist ## 1 SS1 BER 52.8 31.05 ## 2 SS1 BRE 0.0 31.05 ## 3 SS1 EVA 13.1 31.05 And now we can plot the simple rebased off-the-pace chart: g_otp = ggplot(off_the_pace_long, aes(x=cum_dist, y=totalDurationGapS, color=code_driver)) + geom_line() + # Retain the points outside the limits # by using coord_cartesian() # We can also flip the coordinate axis coord_cartesian(ylim=c(100, -100)) + theme_classic() g_otp We might also want to zero the origin, for example by adding a row for each driver with a zeroed distance and gap. Let’s create some dummy data to represent that: zero_df = data.frame(code_driver=unique(off_the_pace_long$code_driver)) zero_df$cum_dist = 0 zero_df$totalDurationGapS = 0 zero_df$code = &#39;SS0&#39; We can then bind that data into our long form splits data and view the result: g_otp = bind_rows(off_the_pace_long, zero_df) %&gt;% ggplot(aes(x=cum_dist, y=totalDurationGapS, color=code_driver)) + geom_line() + # Retain the points outside the limits # by using coord_cartesian() # We can also flip the coordinate axis coord_cartesian(ylim=c(100, -100)) + theme_classic() g_otp Trivially, we might try to add labels at the end of each line: off_the_pace_end = off_the_pace_long %&gt;% filter(cum_dist == max(cum_dist)) g_otp + geom_text(data = off_the_pace_end, aes(x = cum_dist+ 10, y = totalDurationGapS, label = code_driver, color = code_driver)) + theme(legend.position=&quot;none&quot;) However, there are various other packages that provide alternative ways of doing this, including directlabels and ggrepel. For example, using directlabels: library(directlabels) g_otp + geom_dl(aes(label = code_driver, x=cum_dist+2), # cex is text label size method = list(&#39;last.bumpup&#39;, cex = 0.5)) + theme(legend.position=&quot;none&quot;) And using ggrepel, which also has the advantage of adding labels for drivers who curves are really of the pace, albeit not in an obviously natural order: g_otp + ggrepel::geom_text_repel(data = off_the_pace_end, aes(label = code_driver), size = 3) + theme(legend.position=&quot;none&quot;) The gghighlight package is also useful in highlighting traces, as well as usefully automatically labeling highlighted lines: g_otp + gghighlight::gghighlight(code_driver %in% c(&#39;EVA&#39;,&#39;ROV&#39;), unhighlighted_params=list(alpha=0.1)) + theme(legend.position=&quot;none&quot;) Again, let’s routinise the process of chart production with the beginnings of a function to generate the off-the-pace chart directly from an appropriate form dataframe: off_the_pace_chart = function(pace_long, highlight=NULL, label_typ=&#39;dl&#39;, dist=&#39;cum_dist&#39;, t=&#39;totalDurationGapS&#39;, code=&#39;code_driver&#39;, ylim=NULL){ g_otp = ggplot(pace_long, aes_string(x=dist, y=t, color=code)) + geom_line() + # Retain the points outside the limits # by using coord_cartesian() # We can also flip the coordinate axis coord_cartesian(ylim=ylim) + theme_classic() off_the_pace_end = pace_long[pace_long[dist] == max(pace_long[dist]),] if (!is.null(highlight)) g_otp = g_otp + gghighlight::gghighlight(code_driver %in% c(highlight), unhighlighted_params=list(alpha=0.1)) else if (label_typ==&#39;dl&#39;) g_otp = g_otp + geom_dl(aes_string(label = code, x=dist), # cex is text label size method = list(&#39;last.bumpup&#39;, cex = 0.5)) else g_otp = g_otp + ggrepel::geom_text_repel(data = off_the_pace_end, aes_string(label = code), size = 3) g_otp + theme(legend.position=&quot;none&quot;) } Let’s quickly test it, noting how we cast the limits to an inverted y-axis to show the leaders above the x-axis: off_the_pace_chart(off_the_pace_long, ylim=c(50,-50)) And with highlighting: off_the_pace_chart(off_the_pace_long, highlight=c(&#39;EVA&#39;, &#39;ROV&#39;), ylim=c(50,-50)) 6.5 Comparing Pace Across Stages One way of characterising stages is based on pace As a quick guide to possible pace variations over the stages of a rally, we might review the average pace. For example, here’s a look at pace over the course of the rally using a box plot to summarise the (non-outlier) pace values for each stage (we should probably use an ordered categorical stageId basis for the x-axis): ggplot(off_the_pace[off_the_pace$pace&lt;40,], aes(x=cum_dist, y=pace)) + geom_boxplot(aes(group=cum_dist)) "],["working-with-split-times.html", "7 Working With Split Times 7.1 Load Base Data 7.2 Get Splits Data 7.3 Rebasing Split Times 7.4 Visualising Rebased Split Times Using Sparklines 7.5 Finding the Rank Position at Each Split Point 7.6 Finding Split Section Durations 7.7 Adding Overall Stage Time to the Split Times 7.8 Calculating the Ultimate Stage from Ultimate Split Times 7.9 Visualising Rebased Times", " 7 Working With Split Times In this chapter we’ll explore some of the ways in which we might start to work with split times data from a particular stage. On the one hand, we can consider split times purely on a time basis; on the other, we can explore the split times in terms of pace differences calculated by normalising the split times over split distances. As with stage times, we can rebase split times to compare a specified driver directly with other drivers, not just the stage winner. We can also calculate how much time was spent on each split section by finding the difference between consecutive split times for a particular driver. From the split section times, we can also calculate various derived measures, such as the ultimate possible stage time, based on the sum of fastest times to complete each split section. Having access to split times also sets up the potential for rating the performance of a driver on each split against various stage and stage route metrics, such as road order or route metrics such as the “wiggliness” of the split section, although these will not be covered here. 7.1 Load Base Data To get the splits data from a standing start, we can load in the current season list, select the rally we want, look up the itinerary from the rally, extract the sections and then the stages and the retrieve the stage ID for the stage we are interested in. Let’s start by loading in key helper libraries: source(&#39;code/wrc-api.R&#39;) source(&#39;code/wrc-wrangling.R&#39;) source(&#39;code/wrc-charts.R&#39;) And getting some initial data: s = get_active_season() eventId = get_eventId_from_name(s, &#39;arctic&#39;) itinerary = get_itinerary(eventId) sections = get_sections(itinerary) stages = get_stages(sections) stages_lookup = get_stages_lookup(stages) # For driver details entries = get_rally_entries(eventId) cars = get_car_data(entries) As a working example, let’s define an example stage by its code: stage_code = &#39;SS3&#39; Get a sample stage ID: stageId = stages_lookup[[stage_code]] 7.2 Get Splits Data The split times represented the accumulated time going the the stage at each split point. The split times do not include the overall stage time, so we need to be mindful that if we want to report on a stage the split times in and of themselves do not contain any information about the final section of the stage between the final split point and the stage finish line. We can load the splits data if we know the event and stage ID: splits = get_splits(eventId, stageId) The splits data actually comprises two dataframes in columns splitPoints and entrySplitPointTimes. 7.2.1 Split Locations The splitPoints dataframe contains information about the splits locations: splits_locations = splits$splitPoints splits_locations %&gt;% arrange(number) %&gt;% head(2) ## splitPointId stageId number distance ## 1 3615 1750 1 4.83 ## 2 3601 1750 2 9.02 We can also generate a list of the split IDs: splits_list = splits_locations$splitPointId splits_list ## [1] 3593 3601 3615 3617 3621 We can retrieve the split codes ordered by the distance into the stage of each split point from a lookup on the split points: get_split_cols = function(splits){ split_cols = as.character(arrange(splits$splitPoints, distance)$splitPointId) split_cols } split_cols = get_split_cols(splits) split_cols ## [1] &quot;3615&quot; &quot;3601&quot; &quot;3621&quot; &quot;3617&quot; &quot;3593&quot; Since the the split points dataframe does not including the final timing point location (i.e. the stage finish), we can get the full stage distance from the stages dataframe: stages[stages[&#39;code&#39;]==stage_code, &#39;distance&#39;] ## [1] 24.43 7.2.2 Mapping Split Codes to Split Numbers To provide a human readable version of the split identifiers, let’s map them onto a more meaningful label: get_split_label = function(x){ paste0(&#39;split_&#39;, splits_locations[splits_locations$splitPointId==x, &#39;number&#39;]) } splits_locations$splitname = sapply(splits_locations$splitPointId, get_split_label) splits_locations %&gt;% head(3) ## splitPointId stageId number distance splitname ## 1 3593 1750 5 23.21 split_5 ## 2 3601 1750 2 9.02 split_2 ## 3 3615 1750 1 4.83 split_1 We can generate a lookup list of split point names and IDs as: get_stages_lookup(splits_locations, &#39;splitPointId&#39;, &#39;splitname&#39;) ## 3593 3601 3615 3617 3621 ## &quot;split_5&quot; &quot;split_2&quot; &quot;split_1&quot; &quot;split_4&quot; &quot;split_3&quot; We can use this in a function that provides an annotated and ordered form of the split locations dataframe: get_split_locations = function(splits){ splits_locations = splits$splitPoints splits_locations$splitname = sapply(splits_locations$splitPointId, get_split_label) splits_locations %&gt;% arrange(number) } splits_locations = get_split_locations(splits) splits_locations ## splitPointId stageId number distance splitname ## 1 3615 1750 1 4.83 split_1 ## 2 3601 1750 2 9.02 split_2 ## 3 3621 1750 3 14.87 split_3 ## 4 3617 1750 4 20.63 split_4 ## 5 3593 1750 5 23.21 split_5 Create a convenience list of splits names: # We could create these as ordered factors? split_names = splits_locations$splitname split_names ## [1] &quot;split_1&quot; &quot;split_2&quot; &quot;split_3&quot; &quot;split_4&quot; &quot;split_5&quot; 7.2.3 Split Times The second dataframe returned from the splits API call contains the splits times, accessed via the get_driver_splits() function defined previously and imported from the wrc-api.R file. The data is returned in a long format, with each row describing a single split time for a particular driver on the single stage the split times were retrieved for. driver_splits = get_driver_splits(splits) driver_splits %&gt;% head(2) ## splitPointTimeId splitPointId entryId elapsedDuration splitDateTime ## 1 123482 3615 21540 PT2M41.4S 2021-02-27T07:10:41.4 ## 2 123483 3601 21540 PT4M32.5S 2021-02-27T07:12:32.5 ## splitDateTimeLocal elapsedDurationS ## 1 2021-02-27T09:10:41.4+02:00 161.4 ## 2 2021-02-27T09:12:32.5+02:00 272.5 The get_multi_split_times(stage_list) function can also provide us the long form data for multiple stages given one or more stage IDs. 7.2.4 Wide Driver Split Times We can cast the the driver split points into a wide format using the split point codes, ordered by split distance into the stage, as the widened column names: get_splits_wide = function(splits){ driver_splits = get_driver_splits(splits) split_cols = get_split_cols(splits) splits_cols = c(&#39;entryId&#39;, &#39;splitPointId&#39;, &#39;elapsedDurationS&#39;) splits_wide = driver_splits %&gt;% group_by(entryId) %&gt;% select(all_of(splits_cols)) %&gt;% tidyr::spread(key = splitPointId, value = elapsedDurationS) %&gt;% select(all_of(c(&#39;entryId&#39;, split_cols))) %&gt;% # If we don&#39;t cast, it&#39;s a # non-rankable rowwise df as.data.frame() splits_wide } Rather than retrieve the split times into a long format, with one row per driver split, we can now retrieve the data into a wide form with one row per driver and a column for each split on the stage: splits_wide = get_splits_wide(splits) splits_wide %&gt;% head(2) ## entryId 3615 3601 3621 3617 3593 ## 1 21530 161.7 272.3 471.3 690.4 789.2 ## 2 21531 162.3 273.7 472.3 692.1 792.4 The following function, which closely resembles a similar function function for relabeling stage codes, allows us to rename the split points with more meaningful splits names: map_split_codes = function(df, splits_list) { # Get stage codes lookup id-&gt;code splits_lookup_code = get_stages_lookup(splits_locations, &#39;splitPointId&#39;, &#39;splitname&#39;) #https://stackoverflow.com/a/34299333/454773 plyr::rename(df, replace = splits_lookup_code, warn_missing = FALSE) } For example: splits_wide = get_splits_wide(splits) %&gt;% map_split_codes(splits_list) %&gt;% map_driver_names(cars) splits_wide %&gt;% head(10) ## code split_1 split_2 split_3 split_4 split_5 ## 1 OGI 161.7 272.3 471.3 690.4 789.2 ## 2 EVA 162.3 273.7 472.3 692.1 792.4 ## 3 NEU 159.1 268.6 465.8 682.7 782.7 ## 4 ROV 159.6 270.6 468.3 686.6 786.9 ## 5 KAT 161.4 270.3 469.8 689.5 789.9 ## 6 GRE 165.8 278.3 479.3 700.4 800.4 ## 7 TÄN 157.5 267.3 463.8 681.2 781.6 ## 8 SUN 161.8 274.5 474.3 694.2 794.2 ## 9 BRE 158.4 270.3 471.2 688.4 788.5 ## 10 SOL 163.6 275.1 471.3 688.3 786.7 We can also update our helper function to relabel stages with a more general function: relabel_times_df2 = function(df, s_list, cars, typ=&#39;stage&#39;) { if (typ==&#39;split&#39;) df = df %&gt;% map_split_codes(s_list) else df = df %&gt;% map_stage_codes(s_list) df %&gt;% map_driver_names(cars) } 7.3 Rebasing Split Times The split times describe the split times recorded for each driver, but in many situations we may be interested in knowing the difference in split times for a specific driver relative to every other driver. More formally, for drivers \\(j\\) on stage \\(S\\) and split \\(s\\), we find the rebased stage times relative to driver \\(j\\) as: \\[ {_{S,s}}t_{i}^{j} = {_{S,s}}t_{i} - {_{S,s}}t_{j} \\] although we may want to negate that value depending on the sense of whether we want to focus on times from the selected driver’s perspective, or from the perspective of the field of drivers they are being rebased against. . To calculate the rebased times, we note that the wide dataframe format gives rows containing the split times for each driver, which is to say \\({_{S,*}}t_i\\). To calculate the rebased times, we can simply subtract the row corresponding to the driver we want to rebase relative to, from the other driver rows. Recall the heart of the rebase function we have previously defined: #https://stackoverflow.com/a/32267785/454773 rebase_essence = function(df, id, rebase_cols, id_col=&#39;entryId&#39;) { df_ = df # The rebase values are the ones # we want to subtract from each row rebase_vals = c(df[df[[id_col]]==id, rebase_cols]) # Do the rebasing df_[,rebase_cols] = df[,rebase_cols] - rebase_vals df_ } Let’s try the original function with an example driver: ogierEntryId = get_person_id(cars, &#39;ogier&#39;, ret=&#39;code&#39;) ogier_rebased = rebase(splits_wide, ogierEntryId, split_names, id_col=&#39;code&#39;) ogier_rebased %&gt;% head(10) ## code split_1 split_2 split_3 split_4 split_5 ## 1 OGI 0.0 0.0 0.0 0.0 0.0 ## 2 EVA 0.6 1.4 1.0 1.7 3.2 ## 3 NEU -2.6 -3.7 -5.5 -7.7 -6.5 ## 4 ROV -2.1 -1.7 -3.0 -3.8 -2.3 ## 5 KAT -0.3 -2.0 -1.5 -0.9 0.7 ## 6 GRE 4.1 6.0 8.0 10.0 11.2 ## 7 TÄN -4.2 -5.0 -7.5 -9.2 -7.6 ## 8 SUN 0.1 2.2 3.0 3.8 5.0 ## 9 BRE -3.3 -2.0 -0.1 -2.0 -0.7 ## 10 SOL 1.9 2.8 0.0 -2.1 -2.5 7.4 Visualising Rebased Split Times Using Sparklines If we cast the data back to a tidy long form data, we can easily generate a graphical summary from the long form data: library(tidyr) ogier_rebased_long &lt;- ogier_rebased %&gt;% gather(key =&quot;Split&quot;, value =&quot;TimeInS&quot;, all_of(split_names)) ogier_rebased_long %&gt;% head(10) ## code Split TimeInS ## 1 OGI split_1 0.0 ## 2 EVA split_1 0.6 ## 3 NEU split_1 -2.6 ## 4 ROV split_1 -2.1 ## 5 KAT split_1 -0.3 ## 6 GRE split_1 4.1 ## 7 TÄN split_1 -4.2 ## 8 SUN split_1 0.1 ## 9 BRE split_1 -3.3 ## 10 SOL split_1 1.9 For example, we can use the sparkline::spk_chr() function to generate an HTML sparkline widget that we can embed in a formattable::formattable() generated table: library(formattable) library(sparkline) ogier_sparkline &lt;- ogier_rebased_long %&gt;% group_by(code) %&gt;% summarize(spk_ = spk_chr(TimeInS, type =&quot;bar&quot;)) # We need to create an htmlwidget form of the table out = as.htmlwidget(formattable(head(ogier_sparkline, 5))) # The table also has a requirement on the sparkline package out$dependencies = c(out$dependencies, htmlwidgets:::widget_dependencies(&quot;sparkline&quot;, &quot;sparkline&quot;)) out 7.5 Finding the Rank Position at Each Split Point It can often be tricky to work out the rank at each split by eye, so let’s create a simple function to display the rank at each split for us: get_split_rank = function(df, split_cols){ # We need to drop any list names split_names = as.character(split_names) df %&gt;% mutate(across( split_cols, dense_rank )) } get_split_rank(splits_wide, split_names) %&gt;% head(5) ## Note: Using an external vector in selections is ambiguous. ## ℹ Use `all_of(split_cols)` instead of `split_cols` to silence this message. ## ℹ See &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;. ## This message is displayed once per session. ## code split_1 split_2 split_3 split_4 split_5 ## 1 OGI 6 5 6 7 6 ## 2 EVA 8 7 8 8 9 ## 3 NEU 3 2 2 2 2 ## 4 ROV 4 4 3 3 4 ## 5 KAT 5 3 4 6 7 7.6 Finding Split Section Durations Inspection of the split times data show the split times to be a strictly increasing function over the ordered in-stage split locations. That is, the times represent the time in stage up to that split point, rather than the fractional time taken to get from one split timing point to another. In many cases, it will be convenient to know how much time a driver took to get from one split point to the next, not least because this allows us to identify sections of the stage where a driver may have particularly gained or lost time, or to identify where a driver may be making or losing time consistently across different parts of the stage. In abstract terms, then, what we want to calculate is the time taken for a driver \\(i\\) on stage \\(S\\) to go between two split points, \\(m\\) and \\(n\\), where \\(m=0\\) is the start, \\(m={_S}s_{max}+1\\) is the stage end, and \\({_S}s_{max}\\) is the number of split points on stage \\(S\\): \\[ {_{S,m,n}}t_{i} = {_{S,n}}t_{i} - {_{S,m}}t_{i}: 0{\\le}m&lt;n{\\le}{_S}s_{max} \\] For a specific, known stage, we might write the simpler: \\[ S={stagenum}; {_{m,n}}t_{i} = {_{n}}t_{i} - {_{m}}t_{i}: 0{\\le}m&lt;n{\\le}s_{max} \\] For a driver, i, we note that the accumulated stage time on stage \\(S\\) as given by the split times is: \\[ S={stagenum};t_{i}=\\sum_{s=0}^{s{_{max}}}{_{s,s+1}}t_{i}: \\] To get the duration between two split points, we can create two temporary dataframes, one representing the original split times without the first split \\({_{{s+1},s_{max}}}t\\), one representing the split times without the last split, \\({_{s,s_{max}-1}}t\\). Subtracting one dataframe from the other this finds the difference across all consecutive columns: \\[ {_{{s+1},s_{max}}}t - {_{s,s_{max}-1}}t \\] Let’s see how that works in practice: #https://stackoverflow.com/a/50411529/454773 get_split_duration = function(df, split_cols, retId=TRUE, id_col=&#39;entryId&#39;) { # Drop names if they are set split_cols = as.character(split_cols) # [-1] drops the first column, [-ncol()] drops the last df_ = df[,split_cols][-1] - df[,split_cols][-ncol(df[,split_cols])] # The split time to the first split is simply the first split time df_[split_cols[1]] = df[split_cols[1]] if (retId) { # Add in the entryId column df_[[id_col]] = df[[id_col]] # Return the dataframe in a sensible column order df_ %&gt;% select(c(id_col, all_of(split_cols))) } else { df_ } } Let’s see how that works: split_durations_wide = get_split_duration(splits_wide, split_names, id_col=&#39;code&#39;) ## Note: Using an external vector in selections is ambiguous. ## ℹ Use `all_of(id_col)` instead of `id_col` to silence this message. ## ℹ See &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;. ## This message is displayed once per session. split_durations_wide %&gt;% head(5) ## code split_1 split_2 split_3 split_4 split_5 ## 1 OGI 161.7 110.6 199.0 219.1 98.8 ## 2 EVA 162.3 111.4 198.6 219.8 100.3 ## 3 NEU 159.1 109.5 197.2 216.9 100.0 ## 4 ROV 159.6 111.0 197.7 218.3 100.3 ## 5 KAT 161.4 108.9 199.5 219.7 100.4 7.6.1 Finding Split Section Ranks To find the rank in terms of which driver completed each stage section in the quickest time, we can simply pass the split_durations_wide dataframe rather than the split_durations dataframe to the get_split_rank() function: get_split_rank(split_durations_wide, split_names) %&gt;% head(5) ## code split_1 split_2 split_3 split_4 split_5 ## 1 OGI 6 4 6 6 3 ## 2 EVA 8 7 5 8 7 ## 3 NEU 3 2 3 1 4 ## 4 ROV 4 5 4 5 7 ## 5 KAT 5 1 8 7 8 7.7 Adding Overall Stage Time to the Split Times It is important to note that the split times data does not contain all the timing data for the stage, just the times relating to split points along the stage route. For a complete summary of stage timing data, we also need to add in the overall stage time from the stage results table: stage_times = get_stage_times(eventId, stageId) stage_times %&gt;% head(2) ## stageTimeId stageId entryId elapsedDurationMs elapsedDuration status ## 1 96580 1750 21536 834500 00:13:54.5000000 Completed ## 2 96474 1750 21532 835500 00:13:55.5000000 Completed ## source position diffFirstMs diffFirst diffPrevMs diffPrev ## 1 Default 1 0 00:00:00 0 00:00:00 ## 2 Default 2 1000 00:00:01 1000 00:00:01 Recall that if required we can also retrieve stage time for multiple stages using the get_multi_stage_times(stagelist) function. The get_stage_list(stages) function will return a list of all stage IDs. If we merge each driver’s stage times as an extra, final column to the wide split times dataframe, we can calculate the split section durations over the whole stage, including the time taken to get from the final split to the stage end. Recalling that driver codes may not be unique, we should use the unique entryId values to create the extended dataframe: widen_splits_stage_times = function(splits_wide, stage_times, id_col=&#39;entryId&#39;){ results_cols = c(&#39;elapsedDurationMs&#39;, id_col, &#39;diffFirstMs&#39;, &#39;position&#39;) splits_wide = splits_wide %&gt;% merge(stage_times[,results_cols], by = &#39;entryId&#39;) %&gt;% mutate(split_N = elapsedDurationMs/1000) splits_wide } full_splits_wide = get_splits_wide(splits) %&gt;% widen_splits_stage_times(stage_times) %&gt;% map_split_codes(splits_list) %&gt;% map_driver_names(cars) full_splits_wide %&gt;% head(2) ## code split_1 split_2 split_3 split_4 split_5 elapsedDurationMs diffFirstMs ## 1 OGI 161.7 272.3 471.3 690.4 789.2 842000 7500 ## 2 EVA 162.3 273.7 472.3 692.1 792.4 845800 11300 ## position split_N ## 1 6 842.0 ## 2 9 845.8 To make further processing easier, we add the overall stage time to the list of split time column names. The “final split” is now the completed stage time: split_names = c(split_names, &#39;split_N&#39;) split_names ## [1] &quot;split_1&quot; &quot;split_2&quot; &quot;split_3&quot; &quot;split_4&quot; &quot;split_5&quot; &quot;split_N&quot; 7.8 Calculating the Ultimate Stage from Ultimate Split Times The ultimate stage time for a stage is the sum of the fastest sectional split times on the stage as recorded by any driver. Rebasing the stage winner’s time against the ultimate stage time shows whether the driver potentially left time on the stage. (Of course, it might be that a very fast sectional time recorded by one driver may have wiped out their tyres and led to a relatively poor overall stage time, or risk taking that ended their stage prematurely…) So how can we calculate the ultimate splits? For split section times \\({_{S,s}}t_{i}\\), the ultimate section time \\({_{S,s}}u\\) is given as: \\[ {_{S,s}}u = \\forall i: min({_{S,s}}t_i) \\] We can calculate the times by case the wide split section duration dataframe to a long form, grouping by the splitPointId and then summarising the minimum time in each group. Here’s how we can create the long form dataset: full_splits_wide %&gt;% #gather() is deprecated / retired... #gather(splitPointId, sectionDurationS, # as.character(split_names)) select(all_of(as.character(split_names)), code) %&gt;% pivot_longer(as.character(split_names), names_to = &quot;splitname&quot;, values_to = &quot;sectionDurationS&quot;) %&gt;% head(3) ## # A tibble: 3 x 3 ## code splitname sectionDurationS ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 OGI split_1 161.700 ## 2 OGI split_2 272.3 ## 3 OGI split_3 471.3 We can also get the duration of each section: full_durations_wide = get_split_duration(full_splits_wide, split_names, id_col=&#39;code&#39;) full_durations_wide %&gt;% head() ## code split_1 split_2 split_3 split_4 split_5 split_N ## 1 OGI 161.7 110.6 199.0 219.1 98.8 52.8 ## 2 EVA 162.3 111.4 198.6 219.8 100.3 53.4 ## 3 NEU 159.1 109.5 197.2 216.9 100.0 52.8 ## 4 ROV 159.6 111.0 197.7 218.3 100.3 53.3 ## 5 KAT 161.4 108.9 199.5 219.7 100.4 53.3 ## 6 GRE 165.8 112.5 201.0 221.1 100.0 53.0 To rebase on on an ultimate time basis, it helps to think of an ultimate driver whom we define as having a time equivalent to the fastest split duration time between two split points. If we group by splitPointId, we can summarise on sectionDurationS to find the minimum duration at each split; we can also take the opportunity to add an accumulated stage time column at each split point as well: ultimate_splits_long = full_durations_wide %&gt;% pivot_longer(all_of(split_names), names_to = &quot;splitname&quot;, values_to = &quot;sectionDurationS&quot;) %&gt;% select(splitname, sectionDurationS) %&gt;% # Defensive measure filter(!is.na(sectionDurationS) &amp; sectionDurationS&gt;0) %&gt;% group_by(splitname) %&gt;% summarise(ultimate = min(sectionDurationS, na.rm = TRUE)) %&gt;% mutate(ultimateElapsed = cumsum(ultimate)) ultimate_splits_long ## # A tibble: 6 x 3 ## splitname ultimate ultimateElapsed ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 split_1 157.5 157.5 ## 2 split_2 108.9 266.400 ## 3 split_3 196.2 462.6 ## 4 split_4 216.9 679.5 ## 5 split_5 98.4 777.9 ## 6 split_N 52.40000 830.3 Rebasing arbitrary drivers against the ultimate stage (and the distribution of times recorded by other drivers) may give an idea of which drivers were pushing on what parts of a stage and where they were being more cautious. Note that ultimate split times can be used to create an ultimate stage time time that can itself contribute to the ultimate ultimate rally time (sic). 7.8.1 Rebasing to Ultimate Split Times We can rebase to the ultimate split times in three senses: on an ideal, ultimate per split basis; on an ideal elapsed time basis (the cumulative sum of ideal ultimate split durations); on an actual best elapsed (stage) time basis at each split, rebasing relative to the minimum actual recorded elapsed time at each split. 7.8.2 Per Split Ultimate Rebasing To rebase on a per split basis, we can simply rebase durations relative to the minimum split duration at each split. Let’s reshape the ultimate driver durations to a wide format: ultimate_wide_durations = ultimate_splits_long %&gt;% select(splitname, ultimate) %&gt;% pivot_wider(names_from = splitname, values_from = ultimate) %&gt;% mutate(code=&#39;ultimate&#39;) ultimate_wide_durations ## # A tibble: 1 x 7 ## split_1 split_2 split_3 split_4 split_5 split_N code ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 157.5 108.9 196.2 216.9 98.4 52.40000 ultimate We can now add the ultimate driver split durations to the full_durations_wide data and rebase against this dummy driver: ultimate_between_split = full_durations_wide %&gt;% select(code, all_of(split_names)) %&gt;% bind_rows(ultimate_wide_durations) %&gt;% rebase(&#39;ultimate&#39;, split_names, id_col=&#39;code&#39;) %&gt;% head(10) ultimate_between_split ## code split_1 split_2 split_3 split_4 split_5 split_N ## 1 OGI 4.2 1.7 2.8 2.2 0.4 0.4 ## 2 EVA 4.8 2.5 2.4 2.9 1.9 1.0 ## 3 NEU 1.6 0.6 1.0 0.0 1.6 0.4 ## 4 ROV 2.1 2.1 1.5 1.4 1.9 0.9 ## 5 KAT 3.9 0.0 3.3 2.8 2.0 0.9 ## 6 GRE 8.3 3.6 4.8 4.2 1.6 0.6 ## 7 TÄN 0.0 0.9 0.3 0.5 2.0 0.5 ## 8 SUN 4.3 3.8 3.6 3.0 1.6 0.3 ## 9 BRE 0.9 3.0 4.7 0.3 1.7 1.0 ## 10 SOL 6.1 2.6 0.0 0.1 0.0 0.0 In this case we note there is at least one driver in each column with a zero gap to the ultimate driver, specifically, the driver(s) who made it between two consecutive split points in the fastest time, and no driver with a negative gap. 7.8.3 Ultimate Stage Rebasing We can add an “ultimate” driver to the wide splits dataframe and then rebase as normal. The following function routinises the widening recipe we used above: ultimate_widen = function(df, col, valname){ df %&gt;% select(splitname, all_of(col)) %&gt;% pivot_wider(names_from = splitname, values_from = col) %&gt;% mutate(code=valname) } We can get the wide form as: ultimate_wide_elapsed = ultimate_widen(ultimate_splits_long, &#39;ultimateElapsed&#39;, &#39;ultimate&#39;) ## Note: Using an external vector in selections is ambiguous. ## ℹ Use `all_of(col)` instead of `col` to silence this message. ## ℹ See &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;. ## This message is displayed once per session. ultimate_wide_elapsed ## # A tibble: 1 x 7 ## split_1 split_2 split_3 split_4 split_5 split_N code ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 157.5 266.400 462.6 679.5 777.9 830.3 ultimate We can now add that to our original dataframe and rebase against the ultimate stage to show how far off the ultimate stage pace each driver was. Again, let’s make a routine of the process: ultimate_rebaser = function(df, ultimate_df, split_names, ultimate_col ){ df %&gt;% select(code, all_of(split_names)) %&gt;% bind_rows(ultimate_df) %&gt;% rebase(ultimate_col, split_names, id_col=&#39;code&#39;) } And let’s use that routine: ultimate_accumulated = full_splits_wide %&gt;% ultimate_rebaser(ultimate_wide_elapsed, split_names, &#39;ultimate&#39;) %&gt;% head(10) ultimate_accumulated ## code split_1 split_2 split_3 split_4 split_5 split_N ## 1 OGI 4.2 5.9 8.7 10.9 11.3 11.7 ## 2 EVA 4.8 7.3 9.7 12.6 14.5 15.5 ## 3 NEU 1.6 2.2 3.2 3.2 4.8 5.2 ## 4 ROV 2.1 4.2 5.7 7.1 9.0 9.9 ## 5 KAT 3.9 3.9 7.2 10.0 12.0 12.9 ## 6 GRE 8.3 11.9 16.7 20.9 22.5 23.1 ## 7 TÄN 0.0 0.9 1.2 1.7 3.7 4.2 ## 8 SUN 4.3 8.1 11.7 14.7 16.3 16.6 ## 9 BRE 0.9 3.9 8.6 8.9 10.6 11.6 ## 10 SOL 6.1 8.7 8.7 8.8 8.8 8.8 We note there there is only one guaranteed difference of 0.0, from the driver with the fastest time at the first split, and that no times will be less than zero. 7.8.4 Actual Best Elapsed Time Rebasing The full_splits_wide dataframe contains the elapsed times for each driver at each split so we can summarise the long form of that data to get the best actual recorded elapsed times: actual_ultimate = full_splits_wide %&gt;% select(code, all_of(split_names)) %&gt;% # Make long select(all_of(as.character(split_names)), code) %&gt;% pivot_longer(as.character(split_names), names_to = &quot;splitname&quot;, values_to = &quot;sectionDurationS&quot;) %&gt;% group_by(splitname) %&gt;% summarise(actualUltimate = min(sectionDurationS, na.rm=TRUE)) actual_ultimate ## # A tibble: 6 x 2 ## splitname actualUltimate ## &lt;chr&gt; &lt;dbl&gt; ## 1 split_1 157.5 ## 2 split_2 267.3 ## 3 split_3 463.8 ## 4 split_4 681.2 ## 5 split_5 781.6 ## 6 split_N 834.5 We can add this time to out ultimate times dataframe to provide an immediate point of reference between the actual best accumulated split times and the ultimate accumulated ideal split times: ultimate_splits_long$actual = actual_ultimate$actualUltimate ultimate_splits_long ## # A tibble: 6 x 4 ## splitname ultimate ultimateElapsed actual ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 split_1 157.5 157.5 157.5 ## 2 split_2 108.9 266.400 267.3 ## 3 split_3 196.2 462.6 463.8 ## 4 split_4 216.9 679.5 681.2 ## 5 split_5 98.4 777.9 781.6 ## 6 split_N 52.40000 830.3 834.5 Let’s cast the data to a long format in readiness for rebasing it: ultimate_wide_actual = ultimate_widen(ultimate_splits_long, &#39;actual&#39;, &#39;ultimate&#39;) ultimate_wide_actual ## # A tibble: 1 x 7 ## split_1 split_2 split_3 split_4 split_5 split_N code ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 157.5 267.3 463.8 681.2 781.6 834.5 ultimate And then rebase: ultimate_actual = full_splits_wide %&gt;% ultimate_rebaser(ultimate_wide_actual, split_names, &#39;ultimate&#39;) %&gt;% head(10) ultimate_actual ## code split_1 split_2 split_3 split_4 split_5 split_N ## 1 OGI 4.2 5.0 7.5 9.2 7.6 7.5 ## 2 EVA 4.8 6.4 8.5 10.9 10.8 11.3 ## 3 NEU 1.6 1.3 2.0 1.5 1.1 1.0 ## 4 ROV 2.1 3.3 4.5 5.4 5.3 5.7 ## 5 KAT 3.9 3.0 6.0 8.3 8.3 8.7 ## 6 GRE 8.3 11.0 15.5 19.2 18.8 18.9 ## 7 TÄN 0.0 0.0 0.0 0.0 0.0 0.0 ## 8 SUN 4.3 7.2 10.5 13.0 12.6 12.4 ## 9 BRE 0.9 3.0 7.4 7.2 6.9 7.4 ## 10 SOL 6.1 7.8 7.5 7.1 5.1 4.6 In this case, there is at least one zero value per split corresponding to the drive(s) who recorded the fastest elapsed time up to each split point. 7.9 Visualising Rebased Times There are various quick techniques we can use to help visualise the rebased split times and try to highlight significant patterns or peculiarities. For example, we can use coloured backgrounds to highlight each cell in a table, or sparklines to summarise each row. 7.9.1 Context Sensitive Cell Colouring As a quick example, let’s first look at the split duration rebasing where we compare each driver’s time in getting from one split point to the next against the fastest completion of that distance: Recall the divergent color tile formatter we met previously, reused here with a different colour sense: xnormalize = function(x){ # Normalise to the full range of values about 0 # O will map to 0.5 in the normalised range x = c(x, -max(abs(x)), max(abs(x))) normalize(x)[1:(length(x)-2)] } color_tile2 &lt;- function (...) { formatter(&quot;span&quot;, style = function(x) { style(display = &quot;block&quot;, &#39;text-align&#39; = &#39;center&#39;, padding = &quot;0 4px&quot;, `border-radius` = &quot;4px&quot;, `font.weight` = ifelse(abs(x)&gt; 0.3*max(x), &quot;bold&quot;, &quot;normal&quot;), color = ifelse(abs(x)&gt; 0.3*max(x),&#39;white&#39;, ifelse(x==0,&#39;lightgrey&#39;,&#39;black&#39;)), `background-color` = csscolor(matrix(as.integer(colorRamp(...)(xnormalize(as.numeric(x)))), byrow=TRUE, dimnames=list(c(&quot;green&quot;,&quot;red&quot;,&quot;blue&quot;), NULL), nrow=3))) })} We can use that to colour cells as a block (although we note that for ultimately rebased values we can never go below a zero value…). Pale colors are better (closer to the ultimate): formattable(ultimate_between_split, align=&#39;c&#39;, list(area(col = 2:7) ~ color_tile2(c(&quot;red&quot;,&#39;white&#39;, &quot;forestgreen&quot;)), entryId=FALSE)) code split_1 split_2 split_3 split_4 split_5 split_N OGI 4.2 1.7 2.8 2.2 0.4 0.4 EVA 4.8 2.5 2.4 2.9 1.9 1.0 NEU 1.6 0.6 1.0 0.0 1.6 0.4 ROV 2.1 2.1 1.5 1.4 1.9 0.9 KAT 3.9 0.0 3.3 2.8 2.0 0.9 GRE 8.3 3.6 4.8 4.2 1.6 0.6 TÄN 0.0 0.9 0.3 0.5 2.0 0.5 SUN 4.3 3.8 3.6 3.0 1.6 0.3 BRE 0.9 3.0 4.7 0.3 1.7 1.0 SOL 6.1 2.6 0.0 0.1 0.0 0.0 Let’s compare that chart with how the accumulated stage time of each driver compares with the accumulated ultimate section times: formattable(ultimate_accumulated, align=&#39;c&#39;, list(area(col = 2:7) ~ color_tile2(c(&quot;red&quot;,&#39;white&#39;, &quot;forestgreen&quot;)), entryId=FALSE)) code split_1 split_2 split_3 split_4 split_5 split_N OGI 4.2 5.9 8.7 10.9 11.3 11.7 EVA 4.8 7.3 9.7 12.6 14.5 15.5 NEU 1.6 2.2 3.2 3.2 4.8 5.2 ROV 2.1 4.2 5.7 7.1 9.0 9.9 KAT 3.9 3.9 7.2 10.0 12.0 12.9 GRE 8.3 11.9 16.7 20.9 22.5 23.1 TÄN 0.0 0.9 1.2 1.7 3.7 4.2 SUN 4.3 8.1 11.7 14.7 16.3 16.6 BRE 0.9 3.9 8.6 8.9 10.6 11.6 SOL 6.1 8.7 8.7 8.8 8.8 8.8 Finally, let’s see how the driver’s actual split times varied against the best recorded split time at each split: formattable(ultimate_actual, align=&#39;c&#39;, list(area(col = 2:7) ~ color_tile2(c(&quot;red&quot;,&#39;white&#39;, &quot;forestgreen&quot;)), entryId=FALSE)) code split_1 split_2 split_3 split_4 split_5 split_N OGI 4.2 5.0 7.5 9.2 7.6 7.5 EVA 4.8 6.4 8.5 10.9 10.8 11.3 NEU 1.6 1.3 2.0 1.5 1.1 1.0 ROV 2.1 3.3 4.5 5.4 5.3 5.7 KAT 3.9 3.0 6.0 8.3 8.3 8.7 GRE 8.3 11.0 15.5 19.2 18.8 18.9 TÄN 0.0 0.0 0.0 0.0 0.0 0.0 SUN 4.3 7.2 10.5 13.0 12.6 12.4 BRE 0.9 3.0 7.4 7.2 6.9 7.4 SOL 6.1 7.8 7.5 7.1 5.1 4.6 7.9.2 Using Sparklines to Summarise Rebased Deltas A quick way of summarising rebased times in a more space efficient way is to us a sparkline. As we have seen previously, these can be used added as an extra column alongside a row of data, or could be used to as a quick visual indicative summary of a row of values. Let’s create a sparkline summarising each of the above tables. First, the ultimate between split rebase: ultimate_between_split_spk = ultimate_between_split %&gt;% gather(key =&quot;Stage&quot;, value =&quot;Gap&quot;, split_names) %&gt;% group_by(code) %&gt;% summarize(spk_ = spk_chr(-Gap, type =&quot;bar&quot;)) ## Note: Using an external vector in selections is ambiguous. ## ℹ Use `all_of(split_names)` instead of `split_names` to silence this message. ## ℹ See &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;. ## This message is displayed once per session. spark_df(ultimate_between_split_spk) How about for the accumulated ultimate split durations? ultimate_accumulated_spk = ultimate_accumulated %&gt;% gather(key =&quot;Stage&quot;, value =&quot;Gap&quot;, split_names) %&gt;% group_by(code) %&gt;% summarize(spk_ = spk_chr(-Gap, type =&quot;bar&quot;)) spark_df(ultimate_accumulated_spk) And finally, compared to actual recorded best split time: ultimate_actual_spk = ultimate_actual %&gt;% gather(key =&quot;Stage&quot;, value =&quot;Gap&quot;, split_names) %&gt;% group_by(code) %&gt;% summarize(spk_ = spk_chr(-Gap, type =&quot;bar&quot;)) spark_df(ultimate_actual_spk) "],["visualising-pace-across-splits.html", "8 Visualising Pace Across Splits 8.1 Load Base Data 8.2 Calculating Splits Pace 8.3 Visualising the Splits Pace", " 8 Visualising Pace Across Splits We have already seen how we can perform pace calculations on stage level data and use pace maps and off-the-pace charts to visualise pace over the course of a rally. But in WRC rallies at least, the stages are often long enough, and the promoter well resourced enough, to merit the collection of split data data at various split points along a stage. So in this chapter, we’ll review how we can create pace charts and apply the techniques to plotting progress within a stage, across stage splits. 8.1 Load Base Data As ever, load in the helper functions: source(&#39;code/wrc-api.R&#39;) source(&#39;code/wrc-wrangling.R&#39;) source(&#39;code/wrc-charts.R&#39;) And get the base data: s = get_active_season() eventId = get_eventId_from_name(s, &#39;arctic&#39;) itinerary = get_itinerary(eventId) sections = get_sections(itinerary) stages = get_stages(sections) stages_lookup = get_stages_lookup(stages) # Quick Lookups stage_list = get_stage_list(stages) stage_codes = stages$code # Driver details entries = get_rally_entries(eventId) cars = get_car_data(entries) Get a sample stage ID and associated splits: # Get example stage ID stageId = stages_lookup[[&#39;SS3&#39;]] # Get splits for the stage splits = get_splits(eventId, stageId) splits_locations = get_split_locations(splits) splits_list = splits_locations$splitPointId # Get wide format data splits_wide = get_splits_wide(splits) %&gt;% relabel_times_df2(splits_list, cars, typ=&#39;split&#39;) splits_wide %&gt;% head(2) ## code split_1 split_2 split_3 split_4 split_5 ## 1 OGI 161.7 272.3 471.3 690.4 789.2 ## 2 EVA 162.3 273.7 472.3 692.1 792.4 Get long form splits data for one or more stages, in this case, just a single stage: splits_long = get_multi_split_times(stageId) 8.1.1 Obtaining Split Distances We can find the distance between each split as the difference between consecutive values. Let’s augment the splits_locations with these values as well as with section start distances: splits_locations$start_dist = lag(splits_locations$distance, default=0) splits_locations$section_dist = c(splits_locations$distance[1], diff(splits_locations$distance)) splits_locations ## splitPointId stageId number distance splitname start_dist section_dist ## 1 3615 1750 1 4.83 split_1 0.00 4.83 ## 2 3601 1750 2 9.02 split_2 4.83 4.19 ## 3 3621 1750 3 14.87 split_3 9.02 5.85 ## 4 3617 1750 4 20.63 split_4 14.87 5.76 ## 5 3593 1750 5 23.21 split_5 20.63 2.58 We can also retrieve these section distances into a splitPointId named list: split_distances = splits_locations$section_dist # Label the values names(split_distances) = splits_locations$splitPointId split_distances ## 3615 3601 3621 3617 3593 ## 4.83 4.19 5.85 5.76 2.58 We recall that the split points do not include the final timing line (the finish), so a complete set of distances also means we need to access the overall stage distance and account for that: stage_dist = stages[stages[&#39;stageId&#39;]==stageId,&#39;distance&#39;] stage_dist ## [1] 24.43 The complete set of intermediate distances is then: full_split_distances = c(split_distances, stage_dist-sum(split_distances)) names(full_split_distances) = c(names(split_distances), &#39;total&#39;) full_split_distances ## 3615 3601 3621 3617 3593 total ## 4.83 4.19 5.85 5.76 2.58 1.22 8.2 Calculating Splits Pace To calculate pace between two split points we need to get the elapsed time between those two points as well as the distance between split points. We can obtain the split differences by finding differences between the columns of the wide format dataframe using the get_split_duration() function we created previously: split_cols = get_split_cols(splits) split_durations_wide = get_split_duration(splits_wide, split_cols, id_col=&#39;code&#39;) ## Error in `[.data.frame`(df, , split_cols): undefined columns selected split_durations_wide %&gt;% head(3) ## code split_1 split_2 split_3 split_4 split_5 ## 1 OGI 161.7 110.6 199.0 219.1 98.8 ## 2 EVA 162.3 111.4 198.6 219.8 100.3 ## 3 NEU 159.1 109.5 197.2 216.9 100.0 We can then find the pace by dividing the split section times through by the split distances: section_pace_wide = split_durations_wide for (s in splits_list) { s_ = as.character(s) section_pace_wide[,s_] = section_pace_wide[,s_] / split_distances[s_] } ## Error in `[.data.frame`(section_pace_wide, , s_): undefined columns selected section_pace_wide %&gt;% head(2) ## code split_1 split_2 split_3 split_4 split_5 ## 1 OGI 161.7 110.6 199.0 219.1 98.8 ## 2 EVA 162.3 111.4 198.6 219.8 100.3 8.3 Visualising the Splits Pace To visualise the pace over each of the split sections, we can use exactly the same techniques that we used to visualise the stage pace, including pace maps and off-the-pace charts. There are several different ways in which we might try to visualise pace. First, we can visualise absolute or rebased pace. Second, we can visualise pace within sections, using the times taken to get one split point to the next, or across the stage as a whole using the accumulated stage time. 8.3.1 Pace Over Each Section One quick way of inspecting the pace over each section is to use a box plot: section_pace_long = section_pace_wide %&gt;% head(10) %&gt;% gather(splitPointId, pace, as.character(splits_list)) %&gt;% merge(splits_locations[,c(&#39;splitPointId&#39;, &#39;start_dist&#39;, &#39;distance&#39;)], by=&#39;splitPointId&#39;) ## Error: Can&#39;t subset columns that don&#39;t exist. ## x Columns `3615`, `3601`, `3621`, `3617`, and `3593` don&#39;t exist. section_pace_long %&gt;% head(3) ## splitPointId code pace start_dist distance ## 1 3593 OGI 38.29457 20.63 23.21 ## 2 3593 EVA 38.87597 20.63 23.21 ## 3 3593 NEU 38.75969 20.63 23.21 ggplot(section_pace_long[section_pace_long$pace&lt;40,], aes(x=distance, y=pace)) + geom_boxplot(aes(group=distance)) This suggests that the section between the first and second split may be quite technical, and the final sections much faster. Comparing section times against route metrics as described in Visualising Rally Stages will be the focus of a future unbook. Comparing manufacturer performance against different section and stage route types might also be worth further investigation. 8.3.2 Splits Sections Pace Maps To generate the pace map, let’s first rebase the split times with respect to a specified driver: example_driver = section_pace_wide[2,]$code section_pace_wide_rebased = rebase(section_pace_wide, example_driver, splits_list, id_col=&#39;code&#39;) ## Error in `[.data.frame`(df, df[[id_col]] == id, rebase_cols): undefined columns selected section_pace_wide_rebased %&gt;% head(3) ## code 3615 3601 3621 3617 3593 ## 1 OGI -0.1242236 -0.1909308 0.06837607 -0.1215278 -0.5813953 ## 2 EVA 0.0000000 0.0000000 0.00000000 0.0000000 0.0000000 ## 3 NEU -0.6625259 -0.4534606 -0.23931624 -0.5034722 -0.1162791 To plot the pace map, we need to get the data into a long format: section_pace_long_rebased = section_pace_wide_rebased %&gt;% head(10) %&gt;% gather(splitPointId, pace, as.character(splits_list)) %&gt;% merge(splits_locations[,c(&#39;splitPointId&#39;, &#39;start_dist&#39;, &#39;distance&#39;)], by=&#39;splitPointId&#39;) section_pace_long_rebased %&gt;% head() ## splitPointId code pace start_dist distance ## 1 3593 OGI -0.58139535 20.63 23.21 ## 2 3593 EVA 0.00000000 20.63 23.21 ## 3 3593 NEU -0.11627907 20.63 23.21 ## 4 3593 ROV 0.00000000 20.63 23.21 ## 5 3593 KAT 0.03875969 20.63 23.21 ## 6 3593 GRE -0.11627907 20.63 23.21 We can now view the rebased pace over the splits: section_pace_long_rebased %&gt;% pace_map( xstart=&#39;start_dist&#39;, drivers=c(&#39;KAT&#39;,&#39;ROV&#39;), xend=&#39;distance&#39;, id_col=&#39;code&#39;, lines=FALSE, label_dodge=2) 8.3.3 Off-the-Pace Splits Pace Mapping To review the off-the-pace performance over the splits on a stage, we can use the off-the-pace chart function applied to rebased elapsed times data.. Let’s get some rebased data using the accumulated stage time at each split, hackfix flipping the basis of the rebase for now until such a time as the off-the-pace chart is better behaved: wide_splits_rebased = splits_wide %&gt;% head(10) %&gt;% rebase(example_driver, splits_locations$splitname, id_col=&#39;code&#39;, flip=TRUE) wide_splits_rebased %&gt;% head(3) ## code split_1 split_2 split_3 split_4 split_5 ## 1 OGI 0.6 1.4 1.0 1.7 3.2 ## 2 EVA 0.0 0.0 0.0 0.0 0.0 ## 3 NEU 3.2 5.1 6.5 9.4 9.7 We can convert this to long form and add in distance information: long_splits_rebased = wide_splits_rebased %&gt;% pivot_longer(splits_locations$splitname, names_to = &quot;splitname&quot;, values_to = &quot;sectionDurationS&quot;) %&gt;% merge(splits_locations[,c(&#39;splitname&#39;,&#39;distance&#39;)], by=&#39;splitname&#39;) long_splits_rebased %&gt;% head(3) ## splitname code sectionDurationS distance ## 1 split_1 OGI 0.6 4.83 ## 2 split_1 BRE 3.9 4.83 ## 3 split_1 ROV 2.7 4.83 At the start of the chart, it’s convenient to add some zeroed values, so let’s create a dataframe to help us add those data points: zero_df = data.frame(code=unique(long_splits_rebased$code)) zero_df$distance = 0 zero_df$sectionDurationS=0 zero_df$splitname = &#39;split_0&#39; And add them in: long_splits_rebased = bind_rows(long_splits_rebased, zero_df) The off-the-pace chart is intended to show how much time is lost over the course of a stage, the gradient of the slope in each section being an indicator of the pace differential within that section (i.e. between two consecutive split points). The off-the-pace chart is most easily generated from a long dataframe containing the accumulated stage time rather than the sectional times. For example, we can cast the wide form data to a long form and co-opt the pace chart to render the times for us: long_splits_rebased %&gt;% off_the_pace_chart(dist=&#39;distance&#39;, t=&#39;sectionDurationS&#39;, label_typ=&#39;ggrepel&#39;, code=&#39;code&#39;) "]]
