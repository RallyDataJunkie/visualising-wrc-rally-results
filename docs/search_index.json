[["index.html", "Visualising WRC Rally Timing and Results Data A RallyDataJunkie Adventure Index", " Visualising WRC Rally Timing and Results Data A RallyDataJunkie Adventure Tony Hirst Index "],["introduction.html", "1 Introduction", " 1 Introduction For fans of WRC, the live timing data screens as well as results from ewrc-results.com provide up-to-date information about timing and results over the course of an event weekend, as well as a historical results for the current season (WRC) as well as back into the mists of time (ewrc-results). In this recipe collection, I’ll describe various ways of visualising WRC rally results and timing data using data retrieved from the WRC results API. Many of the techniques should also apply directly to data retrieved from other services, such as ewrc-results.com if the data is appropriately represented. "],["accessing-data-from-the-wrc-live-timing-api.html", "2 Accessing Data from the WRC Live Timing API 2.1 Current Season Rallies 2.2 Itinerary Lookup 2.3 Competitor Details 2.4 Penalties and Retirements 2.5 Results and Stage Winner 2.6 Stage Result 2.7 Stage Times 2.8 Split Times", " 2 Accessing Data from the WRC Live Timing API We can get rally details, timing and results data from the WRC live timing service JSON API. 2.1 Current Season Rallies To start with, let’s see what rallies are scheduled for the current, active season. The jsonlite::fromJSON() will retrieve a JSON (JavaScript Object Notation) file from a URL and attempt to unpack it into an R dataframe: library(jsonlite) library(stringr) library(dplyr) get_active_season = function(active_season_url=&quot;https://api.wrc.com/contel-page/83388/calendar/active-season/&quot;) { jsonlite::fromJSON(active_season_url)$rallyEvents$items } s = get_active_season() # Preview the column names of the resulting dataframe colnames(s) ## [1] &quot;id&quot; &quot;name&quot; &quot;active&quot; &quot;jwrc&quot; &quot;deleted&quot; ## [6] &quot;rally&quot; &quot;status&quot; &quot;pageInfo&quot; &quot;pageResult&quot; &quot;eventDays&quot; ## [11] &quot;winner&quot; Let’s preview the contents of a couple of those columns: # The tidyr / magrittr pipe syntax makes things easier to read s %&gt;% select(c(&#39;id&#39;, &#39;name&#39;)) %&gt;% head() ## id name ## 1 1695 WRC Rallye Monte-Carlo ## 2 1745 WRC Arctic Rally Finland Powered by CapitalBox ## 3 1696 WRC Croatia Rally ## 4 1698 WRC Vodafone Rally de Portugal ## 5 1704 WRC Rally Italia Sardegna ## 6 1709 WRC Safari Rally Kenya We can search the name column to find the unique identifier value for a particular event: eventId = s[s[&#39;name&#39;]==&#39;WRC Arctic Rally Finland Powered by CapitalBox&#39;,&#39;id&#39;] eventId ## [1] 1745 Or we can be more generic with a regular expression lookup: get_eventId_from_name = function(season, name){ season[str_detect(season$name, regex(name, ignore_case = T)), &#39;id&#39;] } get_eventId_from_name(s, &#39;arctic&#39;) ## [1] 1745 2.2 Itinerary Lookup We can make another call to the WRC API to look up the itinerary for the event. Each leg of the event corresponds to a particular day: results_api = &#39;https://api.wrc.com/results-api&#39; get_itinerary = function(eventId) { jsonlite::fromJSON(paste0(results_api,&quot;/rally-event/&quot;, eventId, &quot;/itinerary&quot;))$itineraryLegs } itinerary = get_itinerary(eventId) itinerary ## itinerarySections ## 1 7527, 7564, 7563, 7562, 7531, 170, 170, 170, 170, 170, NA, 1747, 1747, 1747, NA, TimeControl, TimeControl, StageStart, FlyingFinish, RegroupIn, TC0, TC1, SS1, SF1, TC1A, Start ( Santasport, Rovaniemi ), Sarriojärvi, Sarriojärvi 1 (Live TV), Sarriojärvi 1 (Live TV), Regroup IN, Minute, Minute, Minute, Tenth, Minute, NA, 77.79, 31.05, NA, 31.57, NA, 01:32:00, 00:06:00, NA, 01:20:00, NA, 5520000, 360000, NA, 4800000, 2021-02-26T11:30:00, 2021-02-26T13:02:00, 2021-02-26T13:08:00, NA, 2021-02-26T14:28:00, 2021-02-26T13:30:00+02:00, 2021-02-26T15:02:00+02:00, 2021-02-26T15:08:00+02:00, NA, 2021-02-26T16:28:00+02:00, Completed, Completed, Completed, Completed, Completed, All, All, None, None, All, NoRounding, NoRounding, RoundToClosestMinute, NoRounding, NoRounding, TRUE, TRUE, TRUE, TRUE, TRUE, 7532, 7561, 7560, 7559, 7533, 7526, 7535, 7534, 170, 170, 170, 170, 170, 170, 170, 170, NA, 1743, 1743, 1743, NA, NA, NA, NA, RegroupOut, TimeControl, StageStart, FlyingFinish, TimeControl, TimeControl, TimeControl, TimeControl, TC1B, TC2, SS2, SF2, TC2A, TC2B, TC2C, TC2D, Regroup OUT, Sarriojärvi, Sarriojärvi 2 (Live TV), Sarriojärvi 2 (Live TV), Parc Fermé &amp; Technical Zone IN, Parc Fermé &amp; Technical Zone Santasport, Service OUT, Finish DAY 1 /Parc Fermé 1 Sampokeskus, Minute, Minute, Minute, Tenth, Minute, Minute, Minute, Minute, 0, 10.23, 31.05, NA, 64.62, 0, 0, 2.83, 01:40:00, 00:24:00, 00:06:00, NA, 01:30:00, 00:10:00, 00:45:00, 00:30:00, 6000000, 1440000, 360000, NA, 5400000, 600000, 2700000, 1800000, 2021-02-26T16:08:00, 2021-02-26T16:32:00, 2021-02-26T16:38:00, NA, 2021-02-26T18:08:00, 2021-02-26T18:18:00, 2021-02-26T19:03:00, 2021-02-26T19:33:00, 2021-02-26T18:08:00+02:00, 2021-02-26T18:32:00+02:00, 2021-02-26T18:38:00+02:00, NA, 2021-02-26T20:08:00+02:00, 2021-02-26T20:18:00+02:00, 2021-02-26T21:03:00+02:00, 2021-02-26T21:33:00+02:00, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, None, All, None, None, All, None, None, None, NoRounding, NoRounding, RoundToClosestMinute, NoRounding, NoRounding, NoRounding, NoRounding, NoRounding, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, 1747, 170, 1, Sarriojärvi 1 (Live TV), 31.05, Completed, SpecialStage, Tenth, TRUE, SS1, 1743, 170, 2, Sarriojärvi 2 (Live TV), 31.05, Completed, SpecialStage, Tenth, TRUE, SS2, 733, 734, 320, 320, 1, 2, Section 1, Section 2 ## 2 7530, 7529, 7528, 7558, 7557, 7556, 7555, 7554, 7553, 7565, 7536, 7550, 7524, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, NA, NA, NA, 1750, 1750, 1750, 1751, 1751, 1751, 1748, 1748, 1748, NA, TimeControl, TimeControl, TimeControl, TimeControl, StageStart, FlyingFinish, TimeControl, StageStart, FlyingFinish, TimeControl, StageStart, FlyingFinish, RegroupIn, TC2E, TC2F, TC2G, TC3, SS3, SF3, TC4, SS4, SF4, TC5, SS5, SF5, TC5A, Parc Fermé OUT, Service IN, Service OUT , Mustalampi, Mustalampi 1, Mustalampi 1, Kaihuavaara, Kaihuavaara 1 (Live TV), Kaihuavaara 1 (Live TV), Siikakämä, Siikakämä 1, Siikakämä 1, Regroup &amp; Technical Zone IN, Minute, Minute, Minute, Minute, Minute, Tenth, Minute, Minute, Tenth, Minute, Minute, Tenth, Minute, 0, 2.7, 0, 37.03, 24.43, NA, 28.96, 19.91, NA, 50.79, 27.68, NA, 37.57, NA, 00:15:00, 00:15:00, 01:00:00, 00:03:00, NA, 01:24:00, 00:06:00, NA, 01:27:00, 00:03:00, NA, 01:12:00, NA, 900000, 900000, 3600000, 180000, NA, 5040000, 360000, NA, 5220000, 180000, NA, 4320000, 2021-02-27T05:35:00, 2021-02-27T05:50:00, 2021-02-27T06:05:00, 2021-02-27T07:05:00, 2021-02-27T07:08:00, NA, 2021-02-27T08:32:00, 2021-02-27T08:38:00, NA, 2021-02-27T10:05:00, 2021-02-27T10:08:00, NA, 2021-02-27T11:20:00, 2021-02-27T07:35:00+02:00, 2021-02-27T07:50:00+02:00, 2021-02-27T08:05:00+02:00, 2021-02-27T09:05:00+02:00, 2021-02-27T09:08:00+02:00, NA, 2021-02-27T10:32:00+02:00, 2021-02-27T10:38:00+02:00, NA, 2021-02-27T12:05:00+02:00, 2021-02-27T12:08:00+02:00, NA, 2021-02-27T13:20:00+02:00, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Late, All, All, All, None, None, All, None, None, All, None, None, All, NoRounding, NoRounding, NoRounding, NoRounding, RoundToClosestMinute, NoRounding, NoRounding, RoundToClosestMinute, NoRounding, NoRounding, RoundToClosestMinute, NoRounding, NoRounding, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, 7512, 7522, 7549, 7548, 7547, 7546, 7545, 7544, 7543, 7542, 7541, 7521, 7520, 7519, 7518, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, NA, NA, 1745, 1745, 1745, 1744, 1744, 1744, 1742, 1742, 1742, NA, NA, NA, NA, RegroupOut, TimeControl, TimeControl, StageStart, FlyingFinish, TimeControl, StageStart, FlyingFinish, TimeControl, StageStart, FlyingFinish, TimeControl, TimeControl, TimeControl, TimeControl, TC5B, TC5C, TC6, SS6, SF6, TC7, SS7, SF7, TC8, SS8, SF8, TC8A, TC8B, TC8C, TC8D, Regroup &amp; Technical Zone OUT - Service IN, Service OUT, Mustalampi, Mustalampi 2, Mustalampi 2, Kaihuavaara, Kaihuavaara 2 (Live TV), Kaihuavaara 2 (Live TV), Siikakämä, Siikakämä 2, Siikakämä 2, Parc Fermé &amp; Technical Zone IN, Parc Fermé &amp; Technical Zone Santasport, Service Out , Finish DAY 2 /Parc Fermé 2 Sampokeskus, Minute, Minute, Minute, Minute, Tenth, Minute, Minute, Tenth, Minute, Minute, Tenth, Minute, Minute, Minute, Minute, 0, NA, 37.03, 24.43, NA, 28.96, 19.91, NA, 50.79, 27.68, NA, 37.57, 0, 0, 2.83, 00:45:00, 00:30:00, 01:00:00, 00:03:00, NA, 01:24:00, 00:06:00, NA, 01:27:00, 00:03:00, NA, 01:20:00, 00:10:00, 00:45:00, 00:30:00, 2700000, 1800000, 3600000, 180000, NA, 5040000, 360000, NA, 5220000, 180000, NA, 4800000, 600000, 2700000, 1800000, 2021-02-27T12:05:00, 2021-02-27T12:35:00, 2021-02-27T13:35:00, 2021-02-27T13:38:00, NA, 2021-02-27T15:02:00, 2021-02-27T15:08:00, NA, 2021-02-27T16:35:00, 2021-02-27T16:38:00, NA, 2021-02-27T17:58:00, 2021-02-27T18:08:00, 2021-02-27T18:53:00, 2021-02-27T19:23:00, 2021-02-27T14:05:00+02:00, 2021-02-27T14:35:00+02:00, 2021-02-27T15:35:00+02:00, 2021-02-27T15:38:00+02:00, NA, 2021-02-27T17:02:00+02:00, 2021-02-27T17:08:00+02:00, NA, 2021-02-27T18:35:00+02:00, 2021-02-27T18:38:00+02:00, NA, 2021-02-27T19:58:00+02:00, 2021-02-27T20:08:00+02:00, 2021-02-27T20:53:00+02:00, 2021-02-27T21:23:00+02:00, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, None, None, All, None, None, All, None, None, All, None, None, All, None, None, None, NoRounding, NoRounding, NoRounding, RoundToClosestMinute, NoRounding, NoRounding, NoRounding, NoRounding, NoRounding, RoundToClosestMinute, NoRounding, NoRounding, NoRounding, NoRounding, NoRounding, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, 1750, 1751, 1748, 170, 170, 170, 3, 4, 5, Mustalampi 1, Kaihuavaara 1 (Live TV), Siikakämä 1, 24.43, 19.91, 27.68, Completed, Completed, Completed, SpecialStage, SpecialStage, SpecialStage, Tenth, Tenth, Tenth, TRUE, TRUE, TRUE, SS3, SS4, SS5, 1745, 1744, 1742, 170, 170, 170, 6, 7, 8, Mustalampi 2, Kaihuavaara 2 (Live TV), Siikakämä 2, 24.43, 19.91, 27.68, Completed, Completed, Completed, SpecialStage, SpecialStage, SpecialStage, Tenth, Tenth, Tenth, TRUE, TRUE, TRUE, SS6, SS7, SS8, 735, 736, 319, 319, 3, 4, Section 3, Section 4 ## 3 7517, 7516, 7515, 7540, 7539, 7538, 7514, 170, 170, 170, 170, 170, 170, 170, NA, NA, NA, 1746, 1746, 1746, NA, TimeControl, TimeControl, TimeControl, TimeControl, StageStart, FlyingFinish, RegroupIn, TC8E, TC8F, TC8G, TC9, SS9, SF9, TC9A, Parc Fermé OUT, Service IN, Service OUT, Aittajärvi, Aittajärvi 1 (Live TV), Aittajärvi 1 (Live TV), Regroup &amp; Technical Zone IN, Minute, Minute, Minute, Minute, Minute, Tenth, Minute, 0, 2.7, 0, 29.5, 22.47, NA, 21, NA, 00:15:00, 00:15:00, 00:47:00, 00:06:00, NA, 01:00:00, NA, 900000, 900000, 2820000, 360000, NA, 3600000, 2021-02-28T06:45:00, 2021-02-28T07:00:00, 2021-02-28T07:15:00, 2021-02-28T08:02:00, 2021-02-28T08:08:00, NA, 2021-02-28T09:08:00, 2021-02-28T08:45:00+02:00, 2021-02-28T09:00:00+02:00, 2021-02-28T09:15:00+02:00, 2021-02-28T10:02:00+02:00, 2021-02-28T10:08:00+02:00, NA, 2021-02-28T11:08:00+02:00, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Late, All, All, All, None, None, All, NoRounding, NoRounding, NoRounding, NoRounding, RoundToClosestMinute, NoRounding, NoRounding, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, 7513, 7537, 7551, 7552, 7523, 7525, 170, 170, 170, 170, 170, 170, NA, 1749, 1749, 1749, NA, NA, RegroupOut, TimeControl, StageStart, FlyingFinish, TimeControl, TimeControl, TC9B, TC10, SS10, SF10, TC10A, TC10B, Regroup OUT, Aittajärvi, Aittajärvi 2 (Wolf Power Stage), Aittajärvi 2 (Wolf Power Stage), Holding Area OUT, Finish - Technical Zone/Parc Fermé IN Santasport, Minute, Minute, Minute, Thousandth, Minute, Minute, 0, 29.5, 22.47, NA, NA, 21, 01:17:00, 00:47:00, 00:06:00, NA, NA, 00:50:00, 4620000, 2820000, 360000, NA, NA, 3000000, 2021-02-28T10:25:00, 2021-02-28T11:12:00, 2021-02-28T11:18:00, NA, NA, NA, 2021-02-28T12:25:00+02:00, 2021-02-28T13:12:00+02:00, 2021-02-28T13:18:00+02:00, NA, NA, NA, Completed, Completed, Completed, Completed, Completed, Completed, None, All, None, None, None, Late, NoRounding, NoRounding, RoundToClosestMinute, NoRounding, NoRounding, NoRounding, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, 1746, 170, 9, Aittajärvi 1 (Live TV), 22.47, Completed, SpecialStage, Tenth, FALSE, SS9, 1749, 170, 10, Aittajärvi 2 (Wolf Power Stage), 22.47, Completed, PowerStage, Thousandth, FALSE, SS10, 737, 738, 318, 318, 5, 6, Section 5, Section 6 ## itineraryLegId itineraryId startListId name legDate ## 1 320 266 523 Friday 26th February 2021-02-26 ## 2 319 266 524 Saturday 27th February 2021-02-27 ## 3 318 266 525 Sunday 28th February 2021-02-28 ## order status ## 1 1 Completed ## 2 2 Completed ## 3 3 Running The startListId can be used alongside the event ID to look up the startlist for a leg. We can order the startlist by start order: get_startlist = function(eventId, startListId) { startlist_url = paste0(results_api, &#39;/rally-event/&#39;, eventId,&#39;/start-list-external/&#39;, startListId) startlist = jsonlite::fromJSON(startlist_url)$startListItems # Order the startlist dataframe by start order startlist %&gt;% arrange(order) } # Example startlist ID # Use a regular expression to find the startlist ID by day startListId = itinerary[str_detect(itinerary$name, regex(&#39;Friday&#39;, ignore_case = T)), &#39;startListId&#39;] startlist = get_startlist(eventId, startListId) startlist %&gt;% head() ## startListItemId startListId entryId startDateTime ## 1 24435 523 21530 2021-02-26T11:30:00 ## 2 24409 523 21531 2021-02-26T11:33:00 ## 3 24410 523 21532 2021-02-26T11:36:00 ## 4 24411 523 21533 2021-02-26T11:39:00 ## 5 24412 523 21534 2021-02-26T11:42:00 ## 6 24413 523 21535 2021-02-26T11:45:00 ## startDateTimeLocal order ## 1 2021-02-26T13:30:00+02:00 1 ## 2 2021-02-26T13:33:00+02:00 2 ## 3 2021-02-26T13:36:00+02:00 3 ## 4 2021-02-26T13:39:00+02:00 4 ## 5 2021-02-26T13:42:00+02:00 5 ## 6 2021-02-26T13:45:00+02:00 6 2.2.1 Leg Sections Within each leg, the itinerary provides information about each section (that is, each “loop”) of the rally. This information is retrieved in form of a dataframe in a standard format. We can use the base R do.call() to call the rbind() function against each row of the dataframe and bind all the dataframes in a specified column into a single dataframe: get_sections = function(itinerary){ sections = do.call(rbind, itinerary$itinerarySections) sections } sections = get_sections(itinerary) sections %&gt;% head() ## controls ## 1 7527, 7564, 7563, 7562, 7531, 170, 170, 170, 170, 170, NA, 1747, 1747, 1747, NA, TimeControl, TimeControl, StageStart, FlyingFinish, RegroupIn, TC0, TC1, SS1, SF1, TC1A, Start ( Santasport, Rovaniemi ), Sarriojärvi, Sarriojärvi 1 (Live TV), Sarriojärvi 1 (Live TV), Regroup IN, Minute, Minute, Minute, Tenth, Minute, NA, 77.79, 31.05, NA, 31.57, NA, 01:32:00, 00:06:00, NA, 01:20:00, NA, 5520000, 360000, NA, 4800000, 2021-02-26T11:30:00, 2021-02-26T13:02:00, 2021-02-26T13:08:00, NA, 2021-02-26T14:28:00, 2021-02-26T13:30:00+02:00, 2021-02-26T15:02:00+02:00, 2021-02-26T15:08:00+02:00, NA, 2021-02-26T16:28:00+02:00, Completed, Completed, Completed, Completed, Completed, All, All, None, None, All, NoRounding, NoRounding, RoundToClosestMinute, NoRounding, NoRounding, TRUE, TRUE, TRUE, TRUE, TRUE ## 2 7532, 7561, 7560, 7559, 7533, 7526, 7535, 7534, 170, 170, 170, 170, 170, 170, 170, 170, NA, 1743, 1743, 1743, NA, NA, NA, NA, RegroupOut, TimeControl, StageStart, FlyingFinish, TimeControl, TimeControl, TimeControl, TimeControl, TC1B, TC2, SS2, SF2, TC2A, TC2B, TC2C, TC2D, Regroup OUT, Sarriojärvi, Sarriojärvi 2 (Live TV), Sarriojärvi 2 (Live TV), Parc Fermé &amp; Technical Zone IN, Parc Fermé &amp; Technical Zone Santasport, Service OUT, Finish DAY 1 /Parc Fermé 1 Sampokeskus, Minute, Minute, Minute, Tenth, Minute, Minute, Minute, Minute, 0, 10.23, 31.05, NA, 64.62, 0, 0, 2.83, 01:40:00, 00:24:00, 00:06:00, NA, 01:30:00, 00:10:00, 00:45:00, 00:30:00, 6000000, 1440000, 360000, NA, 5400000, 600000, 2700000, 1800000, 2021-02-26T16:08:00, 2021-02-26T16:32:00, 2021-02-26T16:38:00, NA, 2021-02-26T18:08:00, 2021-02-26T18:18:00, 2021-02-26T19:03:00, 2021-02-26T19:33:00, 2021-02-26T18:08:00+02:00, 2021-02-26T18:32:00+02:00, 2021-02-26T18:38:00+02:00, NA, 2021-02-26T20:08:00+02:00, 2021-02-26T20:18:00+02:00, 2021-02-26T21:03:00+02:00, 2021-02-26T21:33:00+02:00, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, None, All, None, None, All, None, None, None, NoRounding, NoRounding, RoundToClosestMinute, NoRounding, NoRounding, NoRounding, NoRounding, NoRounding, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE ## 3 7530, 7529, 7528, 7558, 7557, 7556, 7555, 7554, 7553, 7565, 7536, 7550, 7524, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, NA, NA, NA, 1750, 1750, 1750, 1751, 1751, 1751, 1748, 1748, 1748, NA, TimeControl, TimeControl, TimeControl, TimeControl, StageStart, FlyingFinish, TimeControl, StageStart, FlyingFinish, TimeControl, StageStart, FlyingFinish, RegroupIn, TC2E, TC2F, TC2G, TC3, SS3, SF3, TC4, SS4, SF4, TC5, SS5, SF5, TC5A, Parc Fermé OUT, Service IN, Service OUT , Mustalampi, Mustalampi 1, Mustalampi 1, Kaihuavaara, Kaihuavaara 1 (Live TV), Kaihuavaara 1 (Live TV), Siikakämä, Siikakämä 1, Siikakämä 1, Regroup &amp; Technical Zone IN, Minute, Minute, Minute, Minute, Minute, Tenth, Minute, Minute, Tenth, Minute, Minute, Tenth, Minute, 0, 2.7, 0, 37.03, 24.43, NA, 28.96, 19.91, NA, 50.79, 27.68, NA, 37.57, NA, 00:15:00, 00:15:00, 01:00:00, 00:03:00, NA, 01:24:00, 00:06:00, NA, 01:27:00, 00:03:00, NA, 01:12:00, NA, 900000, 900000, 3600000, 180000, NA, 5040000, 360000, NA, 5220000, 180000, NA, 4320000, 2021-02-27T05:35:00, 2021-02-27T05:50:00, 2021-02-27T06:05:00, 2021-02-27T07:05:00, 2021-02-27T07:08:00, NA, 2021-02-27T08:32:00, 2021-02-27T08:38:00, NA, 2021-02-27T10:05:00, 2021-02-27T10:08:00, NA, 2021-02-27T11:20:00, 2021-02-27T07:35:00+02:00, 2021-02-27T07:50:00+02:00, 2021-02-27T08:05:00+02:00, 2021-02-27T09:05:00+02:00, 2021-02-27T09:08:00+02:00, NA, 2021-02-27T10:32:00+02:00, 2021-02-27T10:38:00+02:00, NA, 2021-02-27T12:05:00+02:00, 2021-02-27T12:08:00+02:00, NA, 2021-02-27T13:20:00+02:00, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Late, All, All, All, None, None, All, None, None, All, None, None, All, NoRounding, NoRounding, NoRounding, NoRounding, RoundToClosestMinute, NoRounding, NoRounding, RoundToClosestMinute, NoRounding, NoRounding, RoundToClosestMinute, NoRounding, NoRounding, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE ## 4 7512, 7522, 7549, 7548, 7547, 7546, 7545, 7544, 7543, 7542, 7541, 7521, 7520, 7519, 7518, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, NA, NA, 1745, 1745, 1745, 1744, 1744, 1744, 1742, 1742, 1742, NA, NA, NA, NA, RegroupOut, TimeControl, TimeControl, StageStart, FlyingFinish, TimeControl, StageStart, FlyingFinish, TimeControl, StageStart, FlyingFinish, TimeControl, TimeControl, TimeControl, TimeControl, TC5B, TC5C, TC6, SS6, SF6, TC7, SS7, SF7, TC8, SS8, SF8, TC8A, TC8B, TC8C, TC8D, Regroup &amp; Technical Zone OUT - Service IN, Service OUT, Mustalampi, Mustalampi 2, Mustalampi 2, Kaihuavaara, Kaihuavaara 2 (Live TV), Kaihuavaara 2 (Live TV), Siikakämä, Siikakämä 2, Siikakämä 2, Parc Fermé &amp; Technical Zone IN, Parc Fermé &amp; Technical Zone Santasport, Service Out , Finish DAY 2 /Parc Fermé 2 Sampokeskus, Minute, Minute, Minute, Minute, Tenth, Minute, Minute, Tenth, Minute, Minute, Tenth, Minute, Minute, Minute, Minute, 0, NA, 37.03, 24.43, NA, 28.96, 19.91, NA, 50.79, 27.68, NA, 37.57, 0, 0, 2.83, 00:45:00, 00:30:00, 01:00:00, 00:03:00, NA, 01:24:00, 00:06:00, NA, 01:27:00, 00:03:00, NA, 01:20:00, 00:10:00, 00:45:00, 00:30:00, 2700000, 1800000, 3600000, 180000, NA, 5040000, 360000, NA, 5220000, 180000, NA, 4800000, 600000, 2700000, 1800000, 2021-02-27T12:05:00, 2021-02-27T12:35:00, 2021-02-27T13:35:00, 2021-02-27T13:38:00, NA, 2021-02-27T15:02:00, 2021-02-27T15:08:00, NA, 2021-02-27T16:35:00, 2021-02-27T16:38:00, NA, 2021-02-27T17:58:00, 2021-02-27T18:08:00, 2021-02-27T18:53:00, 2021-02-27T19:23:00, 2021-02-27T14:05:00+02:00, 2021-02-27T14:35:00+02:00, 2021-02-27T15:35:00+02:00, 2021-02-27T15:38:00+02:00, NA, 2021-02-27T17:02:00+02:00, 2021-02-27T17:08:00+02:00, NA, 2021-02-27T18:35:00+02:00, 2021-02-27T18:38:00+02:00, NA, 2021-02-27T19:58:00+02:00, 2021-02-27T20:08:00+02:00, 2021-02-27T20:53:00+02:00, 2021-02-27T21:23:00+02:00, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Completed, None, None, All, None, None, All, None, None, All, None, None, All, None, None, None, NoRounding, NoRounding, NoRounding, RoundToClosestMinute, NoRounding, NoRounding, NoRounding, NoRounding, NoRounding, RoundToClosestMinute, NoRounding, NoRounding, NoRounding, NoRounding, NoRounding, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE ## 5 7517, 7516, 7515, 7540, 7539, 7538, 7514, 170, 170, 170, 170, 170, 170, 170, NA, NA, NA, 1746, 1746, 1746, NA, TimeControl, TimeControl, TimeControl, TimeControl, StageStart, FlyingFinish, RegroupIn, TC8E, TC8F, TC8G, TC9, SS9, SF9, TC9A, Parc Fermé OUT, Service IN, Service OUT, Aittajärvi, Aittajärvi 1 (Live TV), Aittajärvi 1 (Live TV), Regroup &amp; Technical Zone IN, Minute, Minute, Minute, Minute, Minute, Tenth, Minute, 0, 2.7, 0, 29.5, 22.47, NA, 21, NA, 00:15:00, 00:15:00, 00:47:00, 00:06:00, NA, 01:00:00, NA, 900000, 900000, 2820000, 360000, NA, 3600000, 2021-02-28T06:45:00, 2021-02-28T07:00:00, 2021-02-28T07:15:00, 2021-02-28T08:02:00, 2021-02-28T08:08:00, NA, 2021-02-28T09:08:00, 2021-02-28T08:45:00+02:00, 2021-02-28T09:00:00+02:00, 2021-02-28T09:15:00+02:00, 2021-02-28T10:02:00+02:00, 2021-02-28T10:08:00+02:00, NA, 2021-02-28T11:08:00+02:00, Completed, Completed, Completed, Completed, Completed, Completed, Completed, Late, All, All, All, None, None, All, NoRounding, NoRounding, NoRounding, NoRounding, RoundToClosestMinute, NoRounding, NoRounding, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE ## 6 7513, 7537, 7551, 7552, 7523, 7525, 170, 170, 170, 170, 170, 170, NA, 1749, 1749, 1749, NA, NA, RegroupOut, TimeControl, StageStart, FlyingFinish, TimeControl, TimeControl, TC9B, TC10, SS10, SF10, TC10A, TC10B, Regroup OUT, Aittajärvi, Aittajärvi 2 (Wolf Power Stage), Aittajärvi 2 (Wolf Power Stage), Holding Area OUT, Finish - Technical Zone/Parc Fermé IN Santasport, Minute, Minute, Minute, Thousandth, Minute, Minute, 0, 29.5, 22.47, NA, NA, 21, 01:17:00, 00:47:00, 00:06:00, NA, NA, 00:50:00, 4620000, 2820000, 360000, NA, NA, 3000000, 2021-02-28T10:25:00, 2021-02-28T11:12:00, 2021-02-28T11:18:00, NA, NA, NA, 2021-02-28T12:25:00+02:00, 2021-02-28T13:12:00+02:00, 2021-02-28T13:18:00+02:00, NA, NA, NA, Completed, Completed, Completed, Completed, Completed, Completed, None, All, None, None, None, Late, NoRounding, NoRounding, RoundToClosestMinute, NoRounding, NoRounding, NoRounding, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE ## stages ## 1 1747, 170, 1, Sarriojärvi 1 (Live TV), 31.05, Completed, SpecialStage, Tenth, TRUE, SS1 ## 2 1743, 170, 2, Sarriojärvi 2 (Live TV), 31.05, Completed, SpecialStage, Tenth, TRUE, SS2 ## 3 1750, 1751, 1748, 170, 170, 170, 3, 4, 5, Mustalampi 1, Kaihuavaara 1 (Live TV), Siikakämä 1, 24.43, 19.91, 27.68, Completed, Completed, Completed, SpecialStage, SpecialStage, SpecialStage, Tenth, Tenth, Tenth, TRUE, TRUE, TRUE, SS3, SS4, SS5 ## 4 1745, 1744, 1742, 170, 170, 170, 6, 7, 8, Mustalampi 2, Kaihuavaara 2 (Live TV), Siikakämä 2, 24.43, 19.91, 27.68, Completed, Completed, Completed, SpecialStage, SpecialStage, SpecialStage, Tenth, Tenth, Tenth, TRUE, TRUE, TRUE, SS6, SS7, SS8 ## 5 1746, 170, 9, Aittajärvi 1 (Live TV), 22.47, Completed, SpecialStage, Tenth, FALSE, SS9 ## 6 1749, 170, 10, Aittajärvi 2 (Wolf Power Stage), 22.47, Completed, PowerStage, Thousandth, FALSE, SS10 ## itinerarySectionId itineraryLegId order name ## 1 733 320 1 Section 1 ## 2 734 320 2 Section 2 ## 3 735 319 3 Section 3 ## 4 736 319 4 Section 4 ## 5 737 318 5 Section 5 ## 6 738 318 6 Section 6 In the sections dataframe we have one row per section. We notice again the presence of columns that use dataframes to “nest” subdataframes within each row relating to to timing controls and stages associated with each leg. 2.2.2 Time Controls We can look up information about each time control from data provided as part of the itinerary lookup using the same trick as before to “unroll” the contents of each dataframe in a specified column into a single dataframe. An alternative to the do.call() approach is to use a tidy approach and use the dplyr::bind_rows() function on the sections$controls column values via a pipe: get_controls = function(sections){ controls = sections$controls %&gt;% bind_rows() controls } controls = get_controls(sections) controls %&gt;% head(2) ## controlId eventId stageId type code location ## 1 7527 170 NA TimeControl TC0 Start ( Santasport, Rovaniemi ) ## 2 7564 170 1747 TimeControl TC1 Sarriojärvi ## timingPrecision distance targetDuration targetDurationMs firstCarDueDateTime ## 1 Minute NA &lt;NA&gt; NA 2021-02-26T11:30:00 ## 2 Minute 77.79 01:32:00 5520000 2021-02-26T13:02:00 ## firstCarDueDateTimeLocal status controlPenalties roundingPolicy locked ## 1 2021-02-26T13:30:00+02:00 Completed All NoRounding TRUE ## 2 2021-02-26T15:02:00+02:00 Completed All NoRounding TRUE 2.2.3 Stage Details We can pull stage details from the dataframes contained in the sections dataframe from the itinerary lookup: get_stages = function(sections){ stages = sections$stages %&gt;% bind_rows() stages } stages = get_stages(sections) stages %&gt;% head() ## stageId eventId number name distance status ## 1 1747 170 1 Sarriojärvi 1 (Live TV) 31.05 Completed ## 2 1743 170 2 Sarriojärvi 2 (Live TV) 31.05 Completed ## 3 1750 170 3 Mustalampi 1 24.43 Completed ## 4 1751 170 4 Kaihuavaara 1 (Live TV) 19.91 Completed ## 5 1748 170 5 Siikakämä 1 27.68 Completed ## 6 1745 170 6 Mustalampi 2 24.43 Completed ## stageType timingPrecision locked code ## 1 SpecialStage Tenth TRUE SS1 ## 2 SpecialStage Tenth TRUE SS2 ## 3 SpecialStage Tenth TRUE SS3 ## 4 SpecialStage Tenth TRUE SS4 ## 5 SpecialStage Tenth TRUE SS5 ## 6 SpecialStage Tenth TRUE SS6 We can get a list of stage IDs from the stageId column (stages$stageId): get_stage_list = function(stages){ stage_list = stages$stageId stage_list } get_stage_list(stages) ## [1] 1747 1743 1750 1751 1748 1745 1744 1742 1746 1749 Perhaps more conveniently, we can create a lookup from code to stage ID: # https://stackoverflow.com/a/19265431/454773 get_stages_lookup = function(stages, fromCol=&#39;code&#39;, toCol=&#39;stageId&#39;){ stages_lookup = stages[[toCol]] names(stages_lookup) = stages[[fromCol]] stages_lookup } stages_lookup = get_stages_lookup(stages) stages_lookup ## SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 SS10 ## 1747 1743 1750 1751 1748 1745 1744 1742 1746 1749 # Lookup particular stage ID by stage code #stages_lookup[[&#39;SS2&#39;]] From the stages table, we can get the identifier for a particular stage, either by code (for example, “SS3”) or by (partial) name match: ssnum = &#39;SS3&#39; get_stage_id = function(stages, sname, typ=&#39;code&#39;){ # code, name if (typ==&#39;code&#39;) stageId = stages[stages[typ] == sname, &#39;stageId&#39;] else stageId = stages[stringr::str_detect(stages[[typ]], sname), &#39;stageId&#39;] stageId } stageId = get_stage_id(stages, &#39;Mustalampi 1&#39;, &#39;name&#39;) stageId ## [1] 1750 And the stage distance and name: get_stage_info = function(stages, sid, typ=&#39;stageId&#39;, clean=TRUE){ # stageId, code name=stages[stages[typ] == sid, &#39;name&#39;] distance=stages[stages[typ] == sid, &#39;distance&#39;] if (clean) stringr::str_replace(name, &#39; (Live TV)&#39;, &#39;&#39;) c(name=name, distance=distance) } get_stage_info(stages, stageId) ## name distance ## &quot;Mustalampi 1&quot; &quot;24.43&quot; 2.3 Competitor Details Details of car entries for each event can be retrieved from the WRC live timing API given an event ID. get_rally_entries = function(eventId) { cars_url = paste0(results_api, &#39;/rally-event/&#39;, eventId,&#39;/cars&#39;) jsonlite::fromJSON(cars_url) } entries = get_rally_entries(eventId) # $driver, $codriver, $manufacturer, $entrant, $group, $eventClasses # $identifier, $vehicleModel, $eligibility, $status entries %&gt;% head(2) ## driver.personId driver.countryId driver.country.countryId ## 1 670 76 76 ## 2 534 235 235 ## driver.country.name driver.country.iso2 ## 1 France FR ## 2 United Kingdom of Great Britain and Northern Ireland GB ## driver.country.iso3 driver.firstName driver.lastName driver.abbvName ## 1 FRA Sébastien OGIER S. OGIER ## 2 GBR Elfyn EVANS E. EVANS ## driver.fullName driver.code codriver.personId codriver.countryId ## 1 Sébastien OGIER OGI 3027 76 ## 2 Elfyn EVANS EVA 553 235 ## codriver.country.countryId ## 1 76 ## 2 235 ## codriver.country.name codriver.country.iso2 ## 1 France FR ## 2 United Kingdom of Great Britain and Northern Ireland GB ## codriver.country.iso3 codriver.firstName codriver.lastName codriver.abbvName ## 1 FRA Julien INGRASSIA J. INGRASSIA ## 2 GBR Scott MARTIN S. MARTIN ## codriver.fullName codriver.code manufacturer.manufacturerId manufacturer.name ## 1 Julien INGRASSIA ING 84 Toyota ## 2 Scott MARTIN MAR 84 Toyota ## manufacturer.logoFilename entrant.entrantId entrant.name ## 1 toyota 91 TOYOTA GAZOO RACING WRT ## 2 toyota 91 TOYOTA GAZOO RACING WRT ## entrant.logoFilename group.groupId group.name eventClasses tags entryId ## 1 &lt;NA&gt; 10 WRC 640, 170, RC1 NULL 21530 ## 2 &lt;NA&gt; 10 WRC 640, 170, RC1 NULL 21531 ## eventId driverId codriverId manufacturerId entrantId groupId entryListOrder ## 1 170 670 3027 84 91 10 1 ## 2 170 534 553 84 91 10 2 ## identifier vehicleModel eligibility priority status tyreManufacturer ## 1 1 Yaris WRC M P1 Rejoined None ## 2 33 Yaris WRC M P1 Entry None We can index the entries by group to find all the WRC car entryId values: entries[entries$group$name==&#39;WRC&#39;, &#39;entryId&#39;] ## [1] 21530 21531 21532 21533 21534 21535 21536 21537 21538 21539 21540 21541 ## [13] 21542 Detailed information for each driver and codriver can be found in the corresponding sub-dataframes. For example, we can look up the details for each driver, noting in this case that we need to column bind (cbind()) the subdataframes to produce the collated dataframe of driver details: get_drivers = function(entries){ drivers = do.call(cbind, entries$driver) drivers } drivers = get_drivers(entries) drivers %&gt;% head(2) ## personId countryId country.countryId ## 1 670 76 76 ## 2 534 235 235 ## country.name country.iso2 ## 1 France FR ## 2 United Kingdom of Great Britain and Northern Ireland GB ## country.iso3 firstName lastName abbvName fullName code ## 1 FRA Sébastien OGIER S. OGIER Sébastien OGIER OGI ## 2 GBR Elfyn EVANS E. EVANS Elfyn EVANS EVA We can similarly obtain data for the codrivers: #codrivers = do.call(cbind, entries$codriver) # Again, there is a tidyverse approach with dplyr::bind_cols() get_codrivers = function(entries){ codrivers = bind_cols(entries$codriver) codrivers } codrivers = get_codrivers(entries) codrivers %&gt;% head(2) ## personId countryId country.countryId ## 1 3027 76 76 ## 2 553 235 235 ## country.name country.iso2 ## 1 France FR ## 2 United Kingdom of Great Britain and Northern Ireland GB ## country.iso3 firstName lastName abbvName fullName code ## 1 FRA Julien INGRASSIA J. INGRASSIA Julien INGRASSIA ING ## 2 GBR Scott MARTIN S. MARTIN Scott MARTIN MAR We can conveniently obtain the identifier for a particular driver or codriver by searching against their name or three letter code, although note that the three letter code may not be a unique identifier: get_person_id = function(persons, sname, typ=&#39;fullName&#39;){ # code, fullName if (typ==&#39;code&#39;) personsId = persons[persons[typ]==sname, &#39;personId&#39;] else personId = persons[str_detect(persons[[typ]], regex(sname, ignore_case = T)), &#39;personId&#39;] personId } ogierDriverId = get_person_id(drivers, &#39;ogier&#39;) ogierDriverId ## [1] 670 From the driver person identifier we can get the entry identifier for the rally we’re exploring: ogierEntryId = entries[entries[&#39;driverId&#39;]==ogierDriverId, &#39;entryId&#39;] ogierEntryId ## [1] 21530 We can manually create a dataframe containing essential fields from the original cars dataframe and the dataframes contained within it: get_car_data = function(entries){ cols = c(&#39;entryId&#39;, &#39;driverId&#39;, &#39;codriverId&#39;,&#39;manufacturerId&#39;, &#39;vehicleModel&#39;,&#39;eligibility&#39;, &#39;classname&#39;,&#39;manufacturer&#39;, &#39;entrantname&#39;, &#39;groupname&#39;, &#39;drivername&#39;, &#39;code&#39;, &#39;driverfullname&#39;, &#39;codrivername&#39;,&#39;codriverfullname&#39; ) entries = entries %&gt;% rowwise() %&gt;% mutate(classname = eventClasses$name) %&gt;% mutate(manufacturer = manufacturer$name) %&gt;% mutate(entrantname = entrant$name) %&gt;% mutate(groupname = group$name) %&gt;% mutate(drivername = driver$abbvName) %&gt;% mutate(driverfullname = driver$fullName) %&gt;% mutate(codrivername = codriver$abbvName) %&gt;% mutate(codriverfullname = codriver$fullName) %&gt;% mutate(code = driver$code) %&gt;% select(all_of(cols)) # If we don&#39;t cast, it&#39;s a non-rankable rowwise df as.data.frame(entries) } get_car_data(entries) %&gt;% head(2) ## entryId driverId codriverId manufacturerId vehicleModel eligibility classname ## 1 21530 670 3027 84 Yaris WRC M RC1 ## 2 21531 534 553 84 Yaris WRC M RC1 ## manufacturer entrantname groupname drivername code ## 1 Toyota TOYOTA GAZOO RACING WRT WRC S. OGIER OGI ## 2 Toyota TOYOTA GAZOO RACING WRT WRC E. EVANS EVA ## driverfullname codrivername codriverfullname ## 1 Sébastien OGIER J. INGRASSIA Julien INGRASSIA ## 2 Elfyn EVANS S. MARTIN Scott MARTIN 2.4 Penalties and Retirements We can look up penalties from an event ID: get_penalties = function(eventId) { penalties_url = paste0(results_api, &#39;/rally-event/&#39;, eventId, &#39;/penalties&#39;) jsonlite::fromJSON(penalties_url) } get_penalties(eventId) %&gt;% head(2) ## penaltyId controlId entryId penaltyDurationMs penaltyDuration reason ## 1 959 7546 21559 10000 PT10S 1 MIN LATE ## 2 956 7533 21568 10000 PT10S 1 MIN LATE The event ID is also all we need to request a list of retirements: get_retirements = function(eventId) { retirements_url = paste0(results_api, &#39;/rally-event/&#39;, eventId, &#39;/retirements&#39;) jsonlite::fromJSON(retirements_url) } get_retirements(eventId) %&gt;% head(2) ## retirementId controlId entryId reason retirementDateTime ## 1 1802 7562 21547 MECHANICAL 2021-02-26T14:50:00 ## 2 1803 7556 21542 OFF ROAD 2021-02-27T08:01:00 ## retirementDateTimeLocal status ## 1 0001-01-01T00:00:00+00:00 Permanent ## 2 0001-01-01T00:00:00+00:00 Temporary 2.5 Results and Stage Winner As well as retrieving penalties and retirements using just the event ID as a key, we can also retrieve the overall results and the stage winners: get_result = function(eventId) { result_url = paste0(results_api, &#39;/rally-event/&#39;, eventId,&#39;/result&#39;) jsonlite::fromJSON(result_url) } get_result(eventId) %&gt;% head(2) ## entryId stageTimeMs stageTime penaltyTimeMs penaltyTime totalTimeMs ## 1 21536 7429600 PT2H3M49.6S 0 PT0S 7429600 ## 2 21533 7447100 PT2H4M7.1S 0 PT0S 7447100 ## totalTime position diffFirstMs diffFirst diffPrevMs diffPrev ## 1 PT2H3M49.6S 1 0 PT0S 0 PT0S ## 2 PT2H4M7.1S 2 17500 PT17.5S 17500 PT17.5S And for the stage winners: get_stage_winners = function(eventId) { stage_winners_url = paste0(results_api, &#39;/rally-event/&#39;, eventId,&#39;/stage-winners&#39;) jsonlite::fromJSON(stage_winners_url) } get_stage_winners(eventId) %&gt;% head(2) ## stageId entryId stageName elapsedDurationMs elapsedDuration ## 1 1747 21536 Sarriojärvi 1 (Live TV) 957800 00:15:57.8000000 ## 2 1743 21536 Sarriojärvi 2 (Live TV) 952900 00:15:52.9000000 2.6 Stage Result At the end of each stage, there are actually two different sorts of results data are available: data relating to the result of the stage itself, and data relating to how the stage result affected the overall rally position. Let’s start by getting the overall rally result at the end of a particular stage. Note that the overall result does not include the stage ID in the returned data so we need to add it in: get_overall_result = function(eventId, stageId) { overall_url = paste0(results_api, &#39;/rally-event/&#39;, eventId, &#39;/stage-result/stage-external/&#39;, stageId) jsonlite::fromJSON(overall_url) %&gt;% # Also add in the stage ID mutate(stageId = stageId) } overall_result = get_overall_result(eventId, stageId) overall_result %&gt;% head(2) ## entryId stageTimeMs stageTime penaltyTimeMs penaltyTime totalTimeMs ## 1 21536 2745200 PT45M45.2S 0 PT0S 2745200 ## 2 21538 2768800 PT46M8.8S 0 PT0S 2768800 ## totalTime position diffFirstMs diffFirst diffPrevMs diffPrev stageId ## 1 PT45M45.2S 1 0 PT0S 0 PT0S 1750 ## 2 PT46M8.8S 2 23600 PT23.6S 23600 PT23.6S 1750 2.6.1 Getting Stage Results for Multiple Stages It will be convenient to be able to retrieve overall results for multiple stages from one function call. One way of achieving that is to create a function to retrieve the details for a single specified stage that can be applied via a purrr::map() function call to a list of the stage IDs we want overall results data for: library(purrr) ## ## Attaching package: &#39;purrr&#39; ## The following object is masked from &#39;package:jsonlite&#39;: ## ## flatten get_overall_result2 = function(stageId, eventId) { get_overall_result(eventId, stageId) } get_multi_overall = function(stage_list){ multi_overall = stage_list %&gt;% map(get_overall_result2, eventId=eventId) %&gt;% bind_rows() multi_overall } # Specify the stage IDs for multiple stages stage_list = c(1747, 1743) multi_overall_results = get_multi_overall(stage_list) multi_overall_results %&gt;% tail(2) ## entryId stageTimeMs stageTime penaltyTimeMs penaltyTime totalTimeMs ## 107 21579 2866500 PT47M46.5S 0 PT0S 2866500 ## 108 21573 3115400 PT51M55.4S 0 PT0S 3115400 ## totalTime position diffFirstMs diffFirst diffPrevMs diffPrev stageId ## 107 PT47M46.5S 53 955800 PT15M55.8S 123200 PT2M3.2S 1743 ## 108 PT51M55.4S 54 1204700 PT20M4.7S 248900 PT4M8.9S 1743 2.7 Stage Times We can get the stage times for each stage on a rally by event and stage ID: get_stage_times = function(eventId, stageId) { stage_times_url = paste0(results_api, &#39;/rally-event/&#39;, eventId, &#39;/stage-times/stage-external/&#39;, stageId) jsonlite::fromJSON(stage_times_url) } stage_times = get_stage_times(eventId, stageId) stage_times %&gt;% head(2) ## stageTimeId stageId entryId elapsedDurationMs elapsedDuration status ## 1 96580 1750 21536 834500 00:13:54.5000000 Completed ## 2 96474 1750 21532 835500 00:13:55.5000000 Completed ## source position diffFirstMs diffFirst diffPrevMs diffPrev ## 1 Default 1 0 00:00:00 0 00:00:00 ## 2 Default 2 1000 00:00:01 1000 00:00:01 2.7.1 Getting Stage Times for Multiple Stages It will also be convenient to be able to retrieve stage times for multiple stages from a single function call. We can take the same approach we used previously: get_stage_times2 = function(stageId, eventId) { get_stage_times(eventId, stageId) } get_multi_stage_times = function(stage_list){ multi_stage_times = stage_list %&gt;% map(get_stage_times2, eventId=eventId) %&gt;% bind_rows() multi_stage_times } multi_stage_times = get_multi_stage_times(stage_list) multi_stage_times %&gt;% tail(2) ## stageTimeId stageId entryId elapsedDurationMs elapsedDuration status ## 109 96321 1743 21573 1950700 00:32:30.7000000 Completed ## 110 96355 1743 21547 NA &lt;NA&gt; DNS ## source position diffFirstMs diffFirst diffPrevMs diffPrev ## 109 Default 54 997800 00:16:37.8000000 245500 00:04:05.5000000 ## 110 Default NA NA &lt;NA&gt; NA &lt;NA&gt; 2.7.2 Getting Wide Stage Times for Multiple Stages We can then widen the stage times for each driver: get_multi_stage_times_wide = function(multi_stage_times, stage_list){ stage_times_cols = c(&#39;entryId&#39;, &#39;stageId&#39;, &#39;elapsedDurationMs&#39;) multi_stage_times_wide = multi_stage_times %&gt;% select(all_of(stage_times_cols)) %&gt;% mutate(elapsedDurationS = elapsedDurationMs / 1000) %&gt;% select(-elapsedDurationMs) %&gt;% group_by(entryId) %&gt;% tidyr::spread(key = stageId, value = elapsedDurationS) %&gt;% select(c(&#39;entryId&#39;, as.character(stage_list))) %&gt;% # If we don&#39;t cast, it&#39;s a # non-rankable rowwise df as.data.frame() multi_stage_times_wide } multi_stage_times_wide = get_multi_stage_times_wide(multi_stage_times, stage_list) multi_stage_times_wide %&gt;% head(2) ## entryId 1747 1743 ## 1 21530 980.5 980.0 ## 2 21531 974.5 968.2 2.7.3 Getting Wide Stage Positions We can also get the stage positions: get_multi_stage_positions_wide = function(multi_stage_times, stage_list){ stage_positions_cols = c(&#39;entryId&#39;, &#39;stageId&#39;, &#39;position&#39;) multi_stage_positions_wide = multi_stage_times %&gt;% select(all_of(stage_positions_cols)) %&gt;% group_by(entryId) %&gt;% tidyr::spread(key = stageId, value = position) %&gt;% select(c(&#39;entryId&#39;, as.character(stage_list))) %&gt;% # If we don&#39;t cast, it&#39;s a # non-rankable rowwise df as.data.frame() } multi_stage_positions_wide = get_multi_stage_positions_wide(multi_stage_times, stage_list) multi_stage_positions_wide %&gt;% head(2) ## entryId 1747 1743 ## 1 21530 9 10 ## 2 21531 5 5 2.7.4 Getting Generic Wide Dataframes We can start to work up a function that is able to handle widening data frames more generally, albeit with a potential need to handle exceptions: get_multi_stage_generic_wide = function(multi_stage_generic, stage_list, wide_val, group_key=&#39;entryId&#39;, spread_key=&#39;stageId&#39;){ stage_times_cols = c(group_key, spread_key, wide_val ) if (wide_val==&#39;elapsedDurationMs&#39;) { multi_stage_times_wide = multi_stage_times %&gt;% select(all_of(stage_times_cols)) %&gt;% mutate(elapsedDurationS = elapsedDurationMs / 1000) %&gt;% select(-elapsedDurationMs) wide_val = &#39;elapsedDurationS&#39; } multi_stage_generic_wide = multi_stage_generic %&gt;% select(all_of(stage_times_cols)) %&gt;% # group_by_at lets us pass in the grouping column by variable group_by_at(group_key) %&gt;% tidyr::spread(key = spread_key, value = wide_val) %&gt;% select( c(group_key, as.character(stage_list))) %&gt;% # If we don&#39;t cast, it&#39;s a # non-rankable rowwise df as.data.frame() multi_stage_generic_wide } multi_stage_positions_wide_g = get_multi_stage_generic_wide(multi_stage_times, stage_list, &#39;position&#39;) ## Note: Using an external vector in selections is ambiguous. ## ℹ Use `all_of(group_key)` instead of `group_key` to silence this message. ## ℹ See &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;. ## This message is displayed once per session. multi_stage_positions_wide_g %&gt;% head(2) ## entryId 1747 1743 ## 1 21530 9 10 ## 2 21531 5 5 2.8 Split Times We can get split times and distance into stage data for each stage given the stage identifier: get_splits = function(eventId, stageId){ splits_url=paste0(results_api, &#39;/rally-event/&#39;, eventId, &#39;/split-times/stage-external/&#39;, stageId) jsonlite::fromJSON(splits_url) } splits = get_splits(eventId, stageId) # $splitPoints # $entrySplitPointTimes This includes handy information about split locations, such as distance into stage. This can also be useful for pace calculations: splits$splitPoints ## splitPointId stageId number distance ## 1 3593 1750 5 23.21 ## 2 3601 1750 2 9.02 ## 3 3615 1750 1 4.83 ## 4 3617 1750 4 20.63 ## 5 3621 1750 3 14.87 We can also view the split point times for each driver: splits$entrySplitPointTimes %&gt;% head(2) ## entryId startDateTime startDateTimeLocal stageTimeDurationMs ## 1 21540 2021-02-27T07:08:00 2021-02-27T09:08:00+02:00 844300 ## 2 21541 2021-02-27T07:11:00 2021-02-27T09:11:00+02:00 864400 ## stageTimeDuration ## 1 00:14:04.3000000 ## 2 00:14:24.4000000 ## splitPointTimes ## 1 123482, 123483, 123486, 123488, 123490, 3615, 3601, 3621, 3617, 3593, 21540, 21540, 21540, 21540, 21540, 161400, 272500, 471600, 692700, 791500, PT2M41.4S, PT4M32.5S, PT7M51.6S, PT11M32.7S, PT13M11.5S, 2021-02-27T07:10:41.4, 2021-02-27T07:12:32.5, 2021-02-27T07:15:51.6, 2021-02-27T07:19:32.7, 2021-02-27T07:21:11.5, 2021-02-27T09:10:41.4+02:00, 2021-02-27T09:12:32.5+02:00, 2021-02-27T09:15:51.6+02:00, 2021-02-27T09:19:32.7+02:00, 2021-02-27T09:21:11.5+02:00 ## 2 123484, 123485, 123487, 123493, 123494, 3615, 3601, 3621, 3617, 3593, 21541, 21541, 21541, 21541, 21541, 165200, 280600, 484700, 710100, 810300, PT2M45.2S, PT4M40.6S, PT8M4.7S, PT11M50.1S, PT13M30.3S, 2021-02-27T07:13:45.2, 2021-02-27T07:15:40.6, 2021-02-27T07:19:04.7, 2021-02-27T07:22:50.1, 2021-02-27T07:24:30.3, 2021-02-27T09:13:45.2+02:00, 2021-02-27T09:15:40.6+02:00, 2021-02-27T09:19:04.7+02:00, 2021-02-27T09:22:50.1+02:00, 2021-02-27T09:24:30.3+02:00 To view the split times for a specific driver, we can index into the dataframe using the driver entryId value: splits$entrySplitPointTimes[splits$entrySplitPointTimes[&#39;entryId&#39;]==ogierEntryId,]$splitPointTimes ## [[1]] ## splitPointTimeId splitPointId entryId elapsedDurationMs elapsedDuration ## 1 123492 3615 21530 161700 PT2M41.7S ## 2 123495 3601 21530 272300 PT4M32.3S ## 3 123499 3621 21530 471300 PT7M51.3S ## 4 123505 3617 21530 690400 PT11M30.4S ## 5 123507 3593 21530 789200 PT13M9.2S ## splitDateTime splitDateTimeLocal ## 1 2021-02-27T07:22:41.7 2021-02-27T09:22:41.7+02:00 ## 2 2021-02-27T07:24:32.3 2021-02-27T09:24:32.3+02:00 ## 3 2021-02-27T07:27:51.3 2021-02-27T09:27:51.3+02:00 ## 4 2021-02-27T07:31:30.4 2021-02-27T09:31:30.4+02:00 ## 5 2021-02-27T07:33:09.2 2021-02-27T09:33:09.2+02:00 2.8.1 Driver Split Times Detail We can get a flatter structure over all drivers, converting the elapsed duration in milliseconds to seconds along the way: #driver_splits = do.call(rbind, entry_splits$splitPointTimes) # The tidyverse approach is to use dplyr::bind_rows() # We can also construct a pipe to streamline the processing get_driver_splits = function(splits){ driver_splits = splits$entrySplitPointTimes$splitPointTimes %&gt;% bind_rows() %&gt;% mutate(elapsedDurationS = elapsedDurationMs / 1000) %&gt;% select(-elapsedDurationMs) driver_splits } driver_splits = get_driver_splits(splits) driver_splits %&gt;% head(2) ## splitPointTimeId splitPointId entryId elapsedDuration splitDateTime ## 1 123482 3615 21540 PT2M41.4S 2021-02-27T07:10:41.4 ## 2 123483 3601 21540 PT4M32.5S 2021-02-27T07:12:32.5 ## splitDateTimeLocal elapsedDurationS ## 1 2021-02-27T09:10:41.4+02:00 161.4 ## 2 2021-02-27T09:12:32.5+02:00 272.5 2.8.2 Wide Driver Split Times We can cast the data into a wide format, with splits ordered by their distance into the stage. Start by creating a function to help get the split point codes in order by distance along the stage: get_split_cols = function(splits){ split_cols = as.character(arrange(splits$splitPoints, distance)$splitPointId) split_cols } Now create a function to get the driver splits in a wide format using the distance-into-stage ordered split point codes as the widened columns: get_driver_splits_wide = function(driver_splits, splits){ split_cols = get_split_cols(splits) splits_cols = c(&#39;entryId&#39;, &#39;splitPointId&#39;, &#39;elapsedDurationS&#39;) driver_splits_wide = driver_splits %&gt;% group_by(entryId) %&gt;% select(all_of(splits_cols)) %&gt;% tidyr::spread(key = splitPointId, value = elapsedDurationS) %&gt;% select(all_of(c(&#39;entryId&#39;, split_cols))) %&gt;% # If we don&#39;t cast, it&#39;s a # non-rankable rowwise df as.data.frame() driver_splits_wide } driver_splits_wide = get_driver_splits_wide(driver_splits, splits) driver_splits_wide %&gt;% head(2) ## entryId 3615 3601 3621 3617 3593 ## 1 21530 161.7 272.3 471.3 690.4 789.2 ## 2 21531 162.3 273.7 472.3 692.1 792.4 "],["visualising-results-for-a-single-stage.html", "3 Visualising Results for a Single Stage 3.1 Load Base Data 3.2 Get Stage Results Data 3.3 Previewing Stage Results Data 3.4 Adding Stage Metadata to Table Captions 3.5 Colour Highlighting Stage Results 3.6 An Aside — Calculating DIFF and GAP times 3.7 Rebasing Stage Results 3.8 Colour Highlighting Rebased Values", " 3 Visualising Results for a Single Stage In this chapter, we’ll introduce some basic chart and chartable techniques for displaying stage timing and results data. 3.1 Load Base Data To get the splits data from a standing start, we can load in the current season list, select the rally we want, look up the itinerary from the rally, extract the sections and then the stages and the retrieve the stage ID for the stage we are interested in. To begin with, load in our WRC API helper functions: source(&#39;code/wrc-api.R&#39;) Now let’s grab some data: s = get_active_season() eventId = get_eventId_from_name(s, &#39;arctic&#39;) entries = get_rally_entries(eventId) itinerary = get_itinerary(eventId) sections = get_sections(itinerary) stages = get_stages(sections) stages_lookup = get_stages_lookup(stages) Get a sample stage ID: stageId = stages_lookup[[&#39;SS3&#39;]] 3.2 Get Stage Results Data Start by loading in some stage times data and previewing the columns available to us: stage_times = get_stage_times(eventId, stageId) colnames(stage_times) ## [1] &quot;stageTimeId&quot; &quot;stageId&quot; &quot;entryId&quot; ## [4] &quot;elapsedDurationMs&quot; &quot;elapsedDuration&quot; &quot;status&quot; ## [7] &quot;source&quot; &quot;position&quot; &quot;diffFirstMs&quot; ## [10] &quot;diffFirst&quot; &quot;diffPrevMs&quot; &quot;diffPrev&quot; 3.3 Previewing Stage Results Data Just using the stage results data, how might we display it? Let’s start with a view of the top 10. We can use the knitr::kable() function to provide a styled version of the table that slightly improves its appearance: library(knitr) kable( head(stage_times, 10)) stageTimeId stageId entryId elapsedDurationMs elapsedDuration status source position diffFirstMs diffFirst diffPrevMs diffPrev 96580 1750 21536 834500 00:13:54.5000000 Completed Default 1 0 00:00:00 0 00:00:00 96474 1750 21532 835500 00:13:55.5000000 Completed Default 2 1000 00:00:01 1000 00:00:01 96623 1750 21539 839100 00:13:59.1000000 Completed Default 3 4600 00:00:04.6000000 3600 00:00:03.6000000 96509 1750 21533 840200 00:14:00.2000000 Completed Default 4 5700 00:00:05.7000000 1100 00:00:01.1000000 96656 1750 21538 841900 00:14:01.9000000 Completed Default 5 7400 00:00:07.4000000 1700 00:00:01.7000000 96624 1750 21530 842000 00:14:02 Completed Default 6 7500 00:00:07.5000000 100 00:00:00.1000000 96693 1750 21534 843200 00:14:03.2000000 Completed Default 7 8700 00:00:08.7000000 1200 00:00:01.2000000 96480 1750 21540 844300 00:14:04.3000000 Completed Default 8 9800 00:00:09.8000000 1100 00:00:01.1000000 96523 1750 21531 845800 00:14:05.8000000 Completed Default 9 11300 00:00:11.3000000 1500 00:00:01.5000000 96419 1750 21537 846900 00:14:06.9000000 Completed Default 10 12400 00:00:12.4000000 1100 00:00:01.1000000 An alternative rich table formatter is the formattable (example usage) R package which builds on kable() and provides even more comprehensive support,, including cell colour highlighting, for rendering tables in a stylised way. In interactive HTML environments, the tables are rendered as an HTML widget, which allows for even more customisation, such as the inclusion of interactive HTML sparklines. library(formattable) formattable( head(stage_times, 10) ) stageTimeId stageId entryId elapsedDurationMs elapsedDuration status source position diffFirstMs diffFirst diffPrevMs diffPrev 96580 1750 21536 834500 00:13:54.5000000 Completed Default 1 0 00:00:00 0 00:00:00 96474 1750 21532 835500 00:13:55.5000000 Completed Default 2 1000 00:00:01 1000 00:00:01 96623 1750 21539 839100 00:13:59.1000000 Completed Default 3 4600 00:00:04.6000000 3600 00:00:03.6000000 96509 1750 21533 840200 00:14:00.2000000 Completed Default 4 5700 00:00:05.7000000 1100 00:00:01.1000000 96656 1750 21538 841900 00:14:01.9000000 Completed Default 5 7400 00:00:07.4000000 1700 00:00:01.7000000 96624 1750 21530 842000 00:14:02 Completed Default 6 7500 00:00:07.5000000 100 00:00:00.1000000 96693 1750 21534 843200 00:14:03.2000000 Completed Default 7 8700 00:00:08.7000000 1200 00:00:01.2000000 96480 1750 21540 844300 00:14:04.3000000 Completed Default 8 9800 00:00:09.8000000 1100 00:00:01.1000000 96523 1750 21531 845800 00:14:05.8000000 Completed Default 9 11300 00:00:11.3000000 1500 00:00:01.5000000 96419 1750 21537 846900 00:14:06.9000000 Completed Default 10 12400 00:00:12.4000000 1100 00:00:01.1000000 The data itself looks quite cryptic, so we need to convert it to something a little bit more human readable. To enrich the display, we might want to add in information relating to a stage, rather than just refer to it by stage ID, or to describe each entry in rather more detail than just by the entry ID. The way the table is actually presented may also mean that not all the columns may be displayed, so reducing the number of columns would presumably help address that, in part at least. 3.3.1 Adding Entry Metadata In the first instance, it would probably make sense to pull in some human readable data about each entry: cars = get_car_data(entries) cars %&gt;% head(2) ## entryId driverId codriverId manufacturerId vehicleModel eligibility classname ## 1 21530 670 3027 84 Yaris WRC M RC1 ## 2 21531 534 553 84 Yaris WRC M RC1 ## manufacturer entrantname groupname identifier drivername code ## 1 Toyota TOYOTA GAZOO RACING WRT WRC 1 S. OGIER OGI ## 2 Toyota TOYOTA GAZOO RACING WRT WRC 33 E. EVANS EVA ## driverfullname codrivername codriverfullname ## 1 Sébastien OGIER J. INGRASSIA Julien INGRASSIA ## 2 Elfyn EVANS S. MARTIN Scott MARTIN We can the merge this data into out original table, and filter out some of the less useful columns. We’ll also limit ourselves to just the top 10 results: top10_display_cols_base = c(&#39;position&#39;, &#39;identifier&#39;, &#39;code&#39;, #&#39;drivername&#39;, &#39;codrivername&#39;, #&#39;groupname&#39;, &#39;entrantname&#39;, #&#39;classname&#39;, &#39;eligibility&#39;, #&#39;elapsedDuration&#39;, # gap is the time delta between a driver # and the leader; diff (or interval) # is the difference between a driver # and the driver immediately ahead &#39;TimeInS&#39;, &#39;gap&#39;, &#39;diff&#39;) top10_stage_times = stage_times %&gt;% # A minor optimisation step to # limit the amount of merging arrange(position) %&gt;% head(10) %&gt;% # Merge in the entries data merge(cars, by=&#39;entryId&#39;) %&gt;% # Convert milliseconds to seconds mutate(TimeInS = elapsedDurationMs/1000, gap = diffFirstMs/1000, diff = diffPrevMs/1000) %&gt;% # Limit columns and set column order select(all_of(top10_display_cols_base)) %&gt;% # The merge may upset the row order # so reset the order again arrange(position) %&gt;% # Improve column names by renaming them rename(Pos=position, Car = identifier, Code = code, `Time (s)` = TimeInS, Gap = gap, Diff = diff) formattable( top10_stage_times ) Pos Car Code Time (s) Gap Diff 1 8 TÄN 834.5 0.0 0.0 2 11 NEU 835.5 1.0 1.0 3 2 SOL 839.1 4.6 3.6 4 69 ROV 840.2 5.7 1.1 5 42 BRE 841.9 7.4 1.7 6 1 OGI 842.0 7.5 0.1 7 18 KAT 843.2 8.7 1.2 8 7 LOU 844.3 9.8 1.1 9 33 EVA 845.8 11.3 1.5 10 3 SUN 846.9 12.4 1.1 3.4 Adding Stage Metadata to Table Captions To improve the table further, we may want to add a caption to the table describing the stage to which the results actually refer. The caption might include the stage code and the stage name, for example, and perhaps the stage distance. It might also be handy to retrieve the stage number so that if we are displaying several tables, we can check we present the stages in the correct running order: stage_cols = c(&#39;stageId&#39;, &#39;number&#39;, &#39;name&#39;, &#39;distance&#39;, &#39;code&#39;) stage_info = stages %&gt;% select(all_of(stage_cols)) %&gt;% # Tidy up the stage name mutate(name = str_replace(name, &#39; \\\\(Live TV\\\\)&#39;, &#39;&#39;)) stage_info %&gt;% head(2) ## stageId number name distance code ## 1 1747 1 Sarriojärvi 1 31.05 SS1 ## 2 1743 2 Sarriojärvi 2 31.05 SS2 We can create a caption for our selected stage using what essentially amounts to a string template: stage_info_ = stage_info[stage_info[&#39;stageId&#39;]==stageId,] # paste0() ensures there are no separators between substrings caption = paste0(&#39;Stage &#39;, stage_info_$code, &#39;, &#39;, stage_info_$name, &#39; (&#39;, stage_info_$distance, &#39;km)&#39;) caption ## [1] &quot;Stage SS3, Mustalampi 1 (24.43km)&quot; We can add a caption to the table via the caption parameter: formattable( top10_stage_times, caption = caption) Table 3.1: Stage SS3, Mustalampi 1 (24.43km) Pos Car Code Time (s) Gap Diff 1 8 TÄN 834.5 0.0 0.0 2 11 NEU 835.5 1.0 1.0 3 2 SOL 839.1 4.6 3.6 4 69 ROV 840.2 5.7 1.1 5 42 BRE 841.9 7.4 1.7 6 1 OGI 842.0 7.5 0.1 7 18 KAT 843.2 8.7 1.2 8 7 LOU 844.3 9.8 1.1 9 33 EVA 845.8 11.3 1.5 10 3 SUN 846.9 12.4 1.1 3.5 Colour Highlighting Stage Results The formattable::formattable() function is capable of highlighting cell values in a variety of customisable ways. For example, we can emphasise differences that exceed a specific amount: large_diff = 2 formattable(top10_stage_times, list(Diff = formatter(&quot;span&quot;, style = x ~ style(font.weight = ifelse(x&gt;=large_diff, &quot;bold&quot;, &#39;normal&#39;))))) Pos Car Code Time (s) Gap Diff 1 8 TÄN 834.5 0.0 0.0 2 11 NEU 835.5 1.0 1.0 3 2 SOL 839.1 4.6 3.6 4 69 ROV 840.2 5.7 1.1 5 42 BRE 841.9 7.4 1.7 6 1 OGI 842.0 7.5 0.1 7 18 KAT 843.2 8.7 1.2 8 7 LOU 844.3 9.8 1.1 9 33 EVA 845.8 11.3 1.5 10 3 SUN 846.9 12.4 1.1 Alternatively, we can add a coloured bar that depicts the increasing gap time down the leaderboard: #https://www.displayr.com/formattable/ unit.scale = function(x) (x - min(x)) / (max(x) - min(x)) formattable(top10_stage_times, list(Gap = color_bar(&quot;#FA614B66&quot;, fun = unit.scale))) Pos Car Code Time (s) Gap Diff 1 8 TÄN 834.5 0.0 0.0 2 11 NEU 835.5 1.0 1.0 3 2 SOL 839.1 4.6 3.6 4 69 ROV 840.2 5.7 1.1 5 42 BRE 841.9 7.4 1.7 6 1 OGI 842.0 7.5 0.1 7 18 KAT 843.2 8.7 1.2 8 7 LOU 844.3 9.8 1.1 9 33 EVA 845.8 11.3 1.5 10 3 SUN 846.9 12.4 1.1 There seems to be an edge effect there for the zero gap value? Let’s see if we can tidy that up a bit: new_color_bar &lt;- function(color = &quot;lightgreen&quot;, ...){ formatter(&quot;span&quot;, style = function(x) style( display = &quot;inline-block&quot;, direction = &quot;rtl&quot;, `unicode-bidi` = &quot;plaintext&quot;, &quot;border-radius&quot; = &quot;4px&quot;, &quot;background-color&quot; = color, width = percent(proportion(abs(as.numeric(x)), ...)) )) } formattable(top10_stage_times, list(Gap = new_color_bar(&quot;#FA614B66&quot;))) Pos Car Code Time (s) Gap Diff 1 8 TÄN 834.5 0.0 0.0 2 11 NEU 835.5 1.0 1.0 3 2 SOL 839.1 4.6 3.6 4 69 ROV 840.2 5.7 1.1 5 42 BRE 841.9 7.4 1.7 6 1 OGI 842.0 7.5 0.1 7 18 KAT 843.2 8.7 1.2 8 7 LOU 844.3 9.8 1.1 9 33 EVA 845.8 11.3 1.5 10 3 SUN 846.9 12.4 1.1 The edge effect is gone, but the default color_bar() function doesn’t seem to render the values very well where the bars is narrow, at least when the table is rendered to HTML using bookdown. If we provide am alternative color bar function that makes use of a CSS linear gradient to create the bar rather than a setting the width of text cell and colouring its background we can decouple the color bar and the size of the text area: bg = function(start, end, color, ...) { paste(&quot;linear-gradient(90deg,transparent &quot;,percent(start),&quot;,&quot;, color, percent(start), &quot;,&quot;, color, percent(end), &quot;, transparent&quot;, percent(end),&quot;)&quot;) } color_bar2 = function (color = &quot;lightgray&quot;, fun = &quot;proportion&quot;, ...) { fun &lt;- match.fun(fun) formatter(&quot;span&quot;, style = function(x) style(display = &quot;inline-block&quot;, `unicode-bidi` = &quot;plaintext&quot;, &quot;background&quot; = bg(1-fun(as.numeric(x), ...), 1, color), &quot;width&quot;=&quot;100%&quot; )) } formattable(top10_stage_times, list(Gap = color_bar2(&quot;#FA614B66&quot;) )) Pos Car Code Time (s) Gap Diff 1 8 TÄN 834.5 0.0 0.0 2 11 NEU 835.5 1.0 1.0 3 2 SOL 839.1 4.6 3.6 4 69 ROV 840.2 5.7 1.1 5 42 BRE 841.9 7.4 1.7 6 1 OGI 842.0 7.5 0.1 7 18 KAT 843.2 8.7 1.2 8 7 LOU 844.3 9.8 1.1 9 33 EVA 845.8 11.3 1.5 10 3 SUN 846.9 12.4 1.1 3.5.1 Heatmap Style Column Cell Backgrounds As well as in cell bar charts, we can also use more of a heatmap style approach and colour the background down a column according to value. formattable(top10_stage_times, list(Gap = color_bar2(&quot;#FA614B66&quot;), Diff = color_tile(&quot;#DeF7E9&quot;, &quot;#71CA97&quot;))) Pos Car Code Time (s) Gap Diff 1 8 TÄN 834.5 0.0 0.0 2 11 NEU 835.5 1.0 1.0 3 2 SOL 839.1 4.6 3.6 4 69 ROV 840.2 5.7 1.1 5 42 BRE 841.9 7.4 1.7 6 1 OGI 842.0 7.5 0.1 7 18 KAT 843.2 8.7 1.2 8 7 LOU 844.3 9.8 1.1 9 33 EVA 845.8 11.3 1.5 10 3 SUN 846.9 12.4 1.1 3.6 An Aside — Calculating DIFF and GAP times As has previously been mentioned, the GAP to leader and +/- DIFF times to any car placed directly ahead of a particular car, are typical across many forms of motorsport timing screen. In rally terms, these metrics might apply either in overall rally terms or in stage terms; in circuit racing, the measures might apply relative to overall race position or track position. The GAP (time to leader) is calculated as the difference between a time associated with the current leader and a similarly measured time associated with every other driver. The GAP between driver in first position,, \\(i=1\\), and the driver in the \\(j\\)’th position is given in various abuses of the notation as: \\[GAP_{j}=t_{j,GAP}=t_{j,1,DIFF}=t_j-t_1\\] Alternatively, we can calculate the gap as the sum of differences between consecutively placed drivers, \\(j\\neq1\\), and the leader. The interval or DIFF between drivers in positions \\(i\\) and \\(j\\), where \\(i\\) is ahead of \\(j\\) (that is, \\(i&lt;j\\)) and the driver in first position has \\(i=1\\) is given as: \\[DIFF_{j,i}=t_{j,i,DIFF}=t_{j,i}=t_j-t_i: i&lt;j, t_0=t_1\\] The GAP between a driver in position \\(j=P\\) and the leader \\(i=1\\) is then: \\[GAP_j=t_{j,GAP}=DIFF_{2,1}+DIFF_{3,2}+..+DIFF_{P,P-1}\\] We can write this more succinctly as: \\[GAP_{j}=t_{j,GAP}=0+\\sum_{p=1}^{j}DIFF_{p,p-1}=\\sum_{p=1}^{j}\\left ( t_p-t_{p-1} \\right ): j\\ge1, t_0=t_1\\] We can implement these calculations directly as follows: top10_stage_times %&gt;% mutate(DIFF = c(0, diff(`Time (s)`)), GAP = cumsum(DIFF)) %&gt;% select(c(&#39;Car&#39;, &#39;Gap&#39;, &#39;GAP&#39;, &#39;Diff&#39;, &#39;DIFF&#39;)) %&gt;% formattable(caption = caption) Table 3.2: Stage SS3, Mustalampi 1 (24.43km) Car Gap GAP Diff DIFF 8 0.0 0.0 0.0 0.0 11 1.0 1.0 1.0 1.0 2 4.6 4.6 3.6 3.6 69 5.7 5.7 1.1 1.1 42 7.4 7.4 1.7 1.7 1 7.5 7.5 0.1 0.1 18 8.7 8.7 1.2 1.2 7 9.8 9.8 1.1 1.1 33 11.3 11.3 1.5 1.5 3 12.4 12.4 1.1 1.1 3.7 Rebasing Stage Results Simple as they are, the GAP and DIFF times are very powerful: for any driver, we can see how far off the stage winning time they were (the Gap) and by summing appropriate Diff values you can quickly determine the time difference between any two drivers. However, if we are interested in a particular driver, we can “rebase” the table to show the time differences between that driver and the other drivers explicitly. To rebase times, \\(t_i\\) for a set of drivers, \\(i\\), relative to a particular driver, \\(j\\), we set: \\[ t_{i}^{j} = t_i - t_j \\] For a stage \\(S\\), we might extend the notation to write: \\[ {_S}t_{i}^{j} = {_S}t_{i} - {_S}t_{j} \\] using the simpler form with the \\(S\\) prefix where the stage is known. In passing, we note that we can calculate the overall rally time (without penalties) for driver \\(i\\), up to and including stage \\(N\\) as: \\[ {_N}T_{i}=\\sum_{S=1}^{N}{_S}t_{i} \\] The overall time at the end of the rally is then given as: \\[ T_{i}=\\sum_{S=1}^{S{_{max}}}{_S}t_{i} + {penalties}_i \\] Let’s see how the rebasing works. First, get a driver code: ogier = get_person_id(cars, &#39;ogier&#39;, ret=&#39;identifier&#39;) ogier ## [1] &quot;1&quot; Now we can start to build up a rebase function that takes a data frame, an entryId and a set of columns we want to rebase. To begin with, we note that we can rebase a single column simply by finding the value associated with a particular driver in that column and subtracting that value from each row in the column. For example, we can get Ogier’s stage time: ogier_time = top10_stage_times[top10_stage_times[[&#39;Car&#39;]]==ogier, &quot;Time (s)&quot;] ogier_time ## [1] 842 And we can then subtract that time from every other car’s time: top10_stage_times$`Time (s)` - ogier_time ## [1] -7.5 -6.5 -2.9 -1.8 -0.1 0.0 1.2 2.3 3.8 4.9 To rebase more than one column, we can specify a list of columns we want to rebase and then process the response as a named list before subtracting the items in that named list from each of the correspondingly named columns in each row of the dataframe: #https://stackoverflow.com/a/32267785/454773 rebase_cols = c(&#39;Time (s)&#39;, &#39;Gap&#39;) df = top10_stage_times # From each row, select specific columns # From those values subtract correspondingly named items # representing the times in those columns for our specified driver df[,rebase_cols] - c(df[df$Car==ogier, rebase_cols]) ## Time (s) Gap ## 1 -7.5 -7.5 ## 2 -6.5 -6.5 ## 3 -2.9 -2.9 ## 4 -1.8 -1.8 ## 5 -0.1 -0.1 ## 6 0.0 0.0 ## 7 1.2 1.2 ## 8 2.3 2.3 ## 9 3.8 3.8 ## 10 4.9 4.9 Let’s put that into a function, generalised to allow is to specify which column we want to use as a rebasing identifier column, and optioning allow the return of either just the rebased columns (and identifier) or the complete dataframe, including rebased columns: rebase = function(df, id, rebase_cols, id_col=&#39;entryId&#39;, base=FALSE, base_id=FALSE) { df_ = df # The rebase values are the ones # we want to subtract from each row rebase_vals = c(df[df[[id_col]]==id, rebase_cols]) # Do the rebasing df_[,rebase_cols] = df[,rebase_cols] - rebase_vals df_[[id_col]] = df[[id_col]] # Return just the rebased and identifier columns or the # whole dataframe cols = rebase_cols if (base_id) cols = c(id_col, cols) if (base) df_ %&gt;% select(cols) else df_ } We can now rebase the stage times across one or more columns relative to a specified driver: rebase_cols = c(&#39;Time (s)&#39;, &#39;Gap&#39;) rov = get_person_id(cars, &#39;rov&#39;, ret=&#39;identifier&#39;) rov_rebased_gap = rebase(top10_stage_times, rov, rebase_cols, id_col=&#39;Car&#39;) rov_rebased_gap ## Pos Car Code Time (s) Gap Diff ## 1 1 8 TÄN -5.7 -5.7 0.0 ## 2 2 11 NEU -4.7 -4.7 1.0 ## 3 3 2 SOL -1.1 -1.1 3.6 ## 4 4 69 ROV 0.0 0.0 1.1 ## 5 5 42 BRE 1.7 1.7 1.7 ## 6 6 1 OGI 1.8 1.8 0.1 ## 7 7 18 KAT 3.0 3.0 1.2 ## 8 8 7 LOU 4.1 4.1 1.1 ## 9 9 33 EVA 5.6 5.6 1.5 ## 10 10 3 SUN 6.7 6.7 1.1 The rebased time dataframe makes it easier to see how a specified driver compares with every other driver. But can we make the differences jump out in a more striking fashion? 3.8 Colour Highlighting Rebased Values In the rebased tables, we are likely to be presented with a range of positive and negative values within a rebased column. We can highlight the positive and negative values using colour. For example: formattable(rov_rebased_gap, list(Gap = formatter(&quot;span&quot;, style = x ~ style(color = ifelse(x&lt;0, &quot;red&quot;, ifelse(x&gt;0, &#39;green&#39;, &#39;grey&#39;)), # Example additional style font.weight = ifelse(abs(x)&gt;=2, &#39;bold&#39;, &#39;normal&#39;) )))) Pos Car Code Time (s) Gap Diff 1 8 TÄN -5.7 -5.7 0.0 2 11 NEU -4.7 -4.7 1.0 3 2 SOL -1.1 -1.1 3.6 4 69 ROV 0.0 0.0 1.1 5 42 BRE 1.7 1.7 1.7 6 1 OGI 1.8 1.8 0.1 7 18 KAT 3.0 3.0 1.2 8 7 LOU 4.1 4.1 1.1 9 33 EVA 5.6 5.6 1.5 10 3 SUN 6.7 6.7 1.1 Although the formattable() function does not directly support divergent colour indicators, we can create a custom formatter that does provide such a view over the data. For example, we can create a mapping that will display coloured backgrounds that diverge around the zero value to give distinct hues for positive and negative values. The easiest way to render such a mapping is to map the rage of value onto the unit range, and map the 0 value in the original range to the 0.5 value in the normalised unit range. The following function will create a normalised range across a set of positive and negative values, mapping the origin (0) to the normalised 0.5 value: xnormalize = function(x){ # Normalise to the full range of values about 0 # O will map to 0.5 in the normalised range x = c(x, -max(abs(x)), max(abs(x))) normalize(x)[1:(length(x)-2)] } Let’s see how it works: xnormalize(c(-1, 0, 2)) ## [1] 0.25 0.50 1.00 We can now define a custom mapping to render red and green palettised backgrounds depending on whether the value is negative or positive. To maintain contrast in the displayed text values, we can render white or black text depending on the likely intensity of the background colour: #https://stackoverflow.com/a/49887341/454773 color_tile2 &lt;- function (...) { formatter(&quot;span&quot;, style = function(x) { style(display = &quot;block&quot;, &#39;text-align&#39; = &#39;center&#39;, padding = &quot;0 4px&quot;, `border-radius` = &quot;4px&quot;, `font.weight` = ifelse(abs(x)&gt; 0.3*max(x), &quot;bold&quot;, &quot;normal&quot;), color = ifelse(abs(x)&gt; 0.3*max(x),&#39;white&#39;, ifelse(x==0,&#39;lightgrey&#39;,&#39;black&#39;)), `background-color` = csscolor(matrix(as.integer(colorRamp(...)(xnormalize(as.numeric(x)))), byrow=TRUE, dimnames=list(c(&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;), NULL), nrow=3))) })} formattable(rov_rebased_gap, align=&#39;c&#39;, list(Gap = color_tile2(c(&quot;red&quot;,&#39;white&#39;, &quot;forestgreen&quot;)))) Pos Car Code Time (s) Gap Diff 1 8 TÄN -5.7 -5.7 0.0 2 11 NEU -4.7 -4.7 1.0 3 2 SOL -1.1 -1.1 3.6 4 69 ROV 0.0 0.0 1.1 5 42 BRE 1.7 1.7 1.7 6 1 OGI 1.8 1.8 0.1 7 18 KAT 3.0 3.0 1.2 8 7 LOU 4.1 4.1 1.1 9 33 EVA 5.6 5.6 1.5 10 3 SUN 6.7 6.7 1.1 For further possible discussions about divergent palette definitions, see here. # Recall the CSS style from previously #bg = function(start, end, color, ...) { # paste(&quot;linear-gradient(90deg,transparent &quot;,percent(start),&quot;,&quot;, # color, percent(start), &quot;,&quot;, color, percent(end), # &quot;, transparent&quot;, percent(end),&quot;)&quot;) #} pm_color_bar2 &lt;- function(color1 = &quot;lightgreen&quot;, color2 = &quot;pink&quot;, ...){ formatter(&quot;span&quot;, style = function(x) style( display = &quot;inline-block&quot;, color = ifelse(x&gt; 0,&#39;green&#39;,ifelse(x&lt;0,&#39;red&#39;,&#39;lightgrey&#39;)), &quot;text-align&quot; = ifelse(x &gt; 0, &#39;left&#39;, ifelse(x&lt;0, &#39;right&#39;, &#39;center&#39;)), &quot;width&quot;=&#39;100%&#39;, &quot;background&quot; = bg(ifelse(x &gt;= 0, 0.5,xnormalize(x)), ifelse(x &gt;= 0,xnormalize(x),0.5), ifelse(x &gt;= 0, color1, color2)) )) } formattable(rov_rebased_gap, align=&#39;c&#39;, list(Gap = pm_color_bar2() )) Pos Car Code Time (s) Gap Diff 1 8 TÄN -5.7 -5.7 0.0 2 11 NEU -4.7 -4.7 1.0 3 2 SOL -1.1 -1.1 3.6 4 69 ROV 0.0 0.0 1.1 5 42 BRE 1.7 1.7 1.7 6 1 OGI 1.8 1.8 0.1 7 18 KAT 3.0 3.0 1.2 8 7 LOU 4.1 4.1 1.1 9 33 EVA 5.6 5.6 1.5 10 3 SUN 6.7 6.7 1.1 "],["visualising-results-for-multiple-stages.html", "4 Visualising Results for Multiple Stages 4.1 Load Base Data 4.2 Retrieving Stage Results for Multiple Stages 4.3 Mapping Stage and Driver Identifiers to Meaningful Labels 4.4 Rebasing Overall Times 4.5 Visualising Multiple Stage Results 4.6 Retrieving Stage Times for Multiple Stages", " 4 Visualising Results for Multiple Stages As well as visualising the results for a single stage, we might want to visualise the results over multiple stages. The basic overall results can be retrieved from a single call to the WRC results API, but to view the stage times and rankings across multiple stages requires retrieving detailed for each stage and then combining it into a single dataframe. 4.1 Load Base Data To get the splits data from a standing start, we can load in the current season list, select the rally we want, look up the itinerary from the rally, extract the sections and then the stages and the retrieve the stage ID for the stage we are interested in. To begin with, load in our WRC API helper functions: source(&#39;code/wrc-api.R&#39;) Now let’s grab some data: s = get_active_season() eventId = get_eventId_from_name(s, &#39;arctic&#39;) entries = get_rally_entries(eventId) itinerary = get_itinerary(eventId) sections = get_sections(itinerary) stages = get_stages(sections) stages_lookup = get_stages_lookup(stages) 4.2 Retrieving Stage Results for Multiple Stages To being with, lets get the overall results at the end of each stage: multi_overall_results = get_multi_overall(stage_list) multi_overall_results %&gt;% tail(2) ## entryId stageTimeMs stageTime penaltyTimeMs penaltyTime totalTimeMs ## 107 21579 2866500 PT47M46.5S 0 PT0S 2866500 ## 108 21573 3115400 PT51M55.4S 0 PT0S 3115400 ## totalTime position diffFirstMs diffFirst diffPrevMs diffPrev stageId ## 107 PT47M46.5S 53 955800 PT15M55.8S 123200 PT2M3.2S 1743 ## 108 PT51M55.4S 54 1204700 PT20M4.7S 248900 PT4M8.9S 1743 We can reduce the amount of data by casting the long raw result to a wide format: multi_overall_wide_pos = get_multi_stage_generic_wide(multi_overall_results, stage_list, &#39;position&#39;) multi_overall_wide_pos %&gt;% head(2) ## entryId 1747 1743 ## 1 21530 9 9 ## 2 21531 5 5 To get the stage times, first create a column corresponding to time in seconds, then widen using those values: multi_overall_results = multi_overall_results %&gt;% mutate(totalTimeS = totalTimeMs/1000) multi_overall_wide_time = get_multi_stage_generic_wide(multi_overall_results, stage_list, &#39;totalTimeS&#39;) multi_overall_wide_time %&gt;% head(2) ## entryId 1747 1743 ## 1 21530 980.5 1960.5 ## 2 21531 974.5 1942.7 Another useful time is the time to first. As the overall rally leader may change at the end of each stage, it is convenient to grab the data directly from the original dataframe: multi_overall_results = multi_overall_results %&gt;% mutate(diffFirstS = diffFirstMs/1000) multi_overall_wide_gap = get_multi_stage_generic_wide(multi_overall_results, stage_list, &#39;diffFirstS&#39;) multi_overall_wide_gap %&gt;% head(2) ## entryId 1747 1743 ## 1 21530 22.7 49.8 ## 2 21531 16.7 32.0 However, we could also calculate the gap to leader from the overall times, first by identifying the minimum accumulated time at each stage (that is, the minimum time, excluding null values, in each overall time column) and then by subtracting those values from each row in the overall times dataframe. If we try to subtract a list of values from an R dataframe, we need to tell R how we want that subtraction performed. Internally, the dataframe is represented as a long list of values made up from values in the first column, then the second, and so on. If we subtract a list of N values from the dataframe, the values are selected from the first N items in this long serialised version of the dataframe, then the next N values and so on. So to subtract a “dummy” row of values from the dataframe, we need another approach. The purrr::map2df() function allows us to apply a function, in this case the subtraction - function, with a set of specified values we want to subtract, from each row in the dataframe. So let’s create a set of values representing the minimum overall time in each stage. The matrixStats::colMins() function will find the minimum values by row from a matrix, so cast the stage time columns from the wide dataframe to an appropriately sized matrix and then find the minimum in each column, ignoring null values: overall_m = as.matrix(multi_overall_wide_time[,as.character(stage_list)], ncols=length(stage_list)) mins_overall = matrixStats::colMins(overall_m, na.rm=TRUE) mins_overall ## [1] 957.8 1910.7 We can now subtract this “dummy row” of values from each row in the dataframe to find the gap to leader for each row on each stage: purrr::map2_df(multi_overall_wide_time[,as.character(stage_list)], mins_overall, `-`) %&gt;% head(2) ## # A tibble: 2 x 2 ## `1747` `1743` ## &lt;dbl&gt; &lt;dbl&gt; ## 1 22.7 49.8 ## 2 16.7 32 Comparison with the “diffToFirst” times should show them to be the same. 4.3 Mapping Stage and Driver Identifiers to Meaningful Labels To improve the look of the table, we might use stage codes and driver codes to label the columns and identify the rows. To start with, we can map the column names that correspond to stage codes via a lookup list of stage ID to stage code values: map_stage_codes = function(df, stage_list) { # Get stage codes lookup id-&gt;code stages_lookup_code = get_stages_lookup(stages, &#39;stageId&#39;, &#39;code&#39;) #https://stackoverflow.com/a/34299333/454773 plyr::rename(df, replace = stages_lookup_code, warn_missing = FALSE) } multi_overall_wide_time = map_stage_codes(multi_overall_wide_time, stage_list) multi_overall_wide_time %&gt;% head(2) ## entryId SS1 SS2 ## 1 21530 980.5 1960.5 ## 2 21531 974.5 1942.7 We can also create a function to replace the entry ID with the driver code. Note also the select statement at the end that puts the columns into a sensible order: cars = get_car_data(entries) map_driver_names = function(df, cars){ df %&gt;% merge(cars[,c(&#39;entryId&#39;,&#39;code&#39;)], by=&#39;entryId&#39;) %&gt;% # Limit columns and set column order select(-&#39;entryId&#39;) %&gt;% # Move last column to first select(&#39;code&#39;, everything()) } multi_overall_wide_time = map_driver_names(multi_overall_wide_time, cars) multi_overall_wide_time %&gt;% head(2) ## code SS1 SS2 ## 1 OGI 980.5 1960.5 ## 2 EVA 974.5 1942.7 4.4 Rebasing Overall Times We can rebase the overall times with respect to a particular driver in the normal way: example_driver = multi_overall_wide_time[2,]$code overall_wide_time_rebased = rebase(multi_overall_wide_time, example_driver, stage_codes, id_col=&#39;code&#39;) ## Error in `[.data.frame`(df, df[[id_col]] == id, rebase_cols): object &#39;stage_codes&#39; not found overall_wide_time_rebased %&gt;% head(3) ## Error in head(., 3): object &#39;overall_wide_time_rebased&#39; not found 4.4.1 Find Changes in Rebased Gaps Across Stages The rebasing operation essentially allows us to select a row of times for one particular driver and then subtract that row from every other row to give us a direct comparison of the gap between a specified driver and every other driver. But we can also perform a consecutive column-wise differencing operation on the rebased times that allows to see how much time was gained or relative to a particular driver in going from one stage to the next (observant readers may note that this results in the rebased stage time for each stage…). TO subtract one column from the next, create two offset dataframes, one containing all but the first stage (first stage column) and one containing all but the last stage (final stage column). If we subtract one dataframe from the other, it gives us our column differences. Inserting the original first column back in its rightful place gives us the columnwise differences table: #https://stackoverflow.com/a/50411529/454773 df = overall_wide_time_rebased ## Error in eval(expr, envir, enclos): object &#39;overall_wide_time_rebased&#39; not found # [-1] drops the first column, [-ncol()] drops the last df_ = df[,stage_codes][-1] - df[,stage_codes][-ncol(df[,stage_codes])] ## Error in `[.data.frame`(df, , stage_codes): object &#39;stage_codes&#39; not found # The split time to the first split is simply the first split time df_[stage_codes[1]] = df[stage_codes[1]] ## Error in `[.data.frame`(df, stage_codes[1]): object &#39;stage_codes&#39; not found # Return the dataframe in a sensible column order df_ %&gt;% select(stage_codes) %&gt;% head(3) ## Error in select(., stage_codes): object &#39;df_&#39; not found (A similar technique could be used to recreate stage times from the overall times.) 4.5 Visualising Multiple Stage Results The overall stage results provides information regarding the overall times and positions at the end of each stage and the rebased overall times provide us with gap information from a specified driver to every other driver. So how might we use exploratory data visualisation techniques to support a conversation with that data or highlight potential stories hidden within it? TO DO… 4.6 Retrieving Stage Times for Multiple Stages We can retrieve detailed results for multiple stages by requesting stage results for a specified list of stages: stage_list = get_stage_list(stages) multi_stage_times = get_multi_stage_times(stage_list) multi_stage_times %&gt;% tail(2) ## stageTimeId stageId entryId elapsedDurationMs elapsedDuration status ## 539 96810 1749 21571 1301693 00:21:41.6930000 Completed ## 540 96793 1749 21541 NA &lt;NA&gt; DNS ## source position diffFirstMs diffFirst diffPrevMs diffPrev ## 539 Default 52 699224 00:11:39.2240000 153590 00:02:33.5900000 ## 540 Default NA NA &lt;NA&gt; NA &lt;NA&gt; We can then cast the data to a wide format: multi_stage_times_wide = get_multi_stage_times_wide(multi_stage_times, stage_list) multi_stage_times_wide %&gt;% head(2) ## entryId 1747 1743 1750 1751 1748 1745 1744 1742 1746 1749 ## 1 21530 980.5 980.0 842.0 548.5 751.2 853.7 556.7 1364.0 615.0 604.272 ## 2 21531 974.5 968.2 845.8 546.6 750.2 853.6 552.6 784.1 607.5 608.028 And process: multi_stage_times_wide= map_stage_codes(multi_stage_times_wide, stage_list) "],["finding-pace-across-stages.html", "5 Finding Pace Across Stages 5.1 Load Base Data 5.2 Defining Pace 5.3 Calculating Stage Pace 5.4 Rebasing Stage Pace 5.5 Visualising Stage Pace Using Pace Maps 5.6 Off-the-Pace Charts", " 5 Finding Pace Across Stages Average speed on a rally is all very well, but it’s not the most useful of metrics for making sense of what’s actually going on in a rally. Far more useful is the notion of pace the reciprocal of a speed like measure, that tells you how many seconds it’s taking each driver to cover one kilometer. Knowing the pace allows you to make more direct comparisons between drivers, as well as simplifying rule of thumb calculations, like what sort of pace advantage a driver needs to make up the 2s to the leader over the remaining 100 kilometers available in the final four stages… In this chapter, we look at some simple pace calculations, rebase pace values relative to a specified driver, and explore a couple of ways of visualising differential pace over the course of a rally in the form of pace maps and off-the-pace charts. 5.1 Load Base Data To get the stage data from a standing start, we can load in the current season list, select the rally we want, look up the itinerary from the rally, extract the sections and then the stages, and from that access the stage ID for the stage or stages we are interested in. Load in the helper functions: source(&#39;code/wrc-api.R&#39;) And get the base data: s = get_active_season() eventId = get_eventId_from_name(s, &#39;arctic&#39;) itinerary = get_itinerary(eventId) sections = get_sections(itinerary) stages = get_stages(sections) stages_lookup = get_stages_lookup(stages) # Driver details cars = get_car_data(entries) Get a sample stage ID: stageId = stages_lookup[[&#39;SS3&#39;]] 5.2 Defining Pace With variable stage distances on a stage rally, metrics such as average speed provide one way of comparing performances across stage, calculated as \\(\\textrm{stage_time}/\\textrm{stage_distance}\\) with units of kilometers or miles per hour. A more useful measure, particularly in rally terms, is the notion of pace, typically given with units of seconds per kilometer. Speed tells us much quickly a car covers distance in unit time; pace gives us an indication of how much time is required to travel a unit distance. When used as a rebased difference measure between drivers, pace difference allows us to rapidly calculate how much time a driver is likely to gain or lose over a particular stage distance as per the word equation \\(\\textrm{time_gain}=\\textrm{stage_distance}\\cdot\\textrm{pace_difference}\\). Basic pace itself is given as \\(\\textrm{pace}=\\textrm{time}/\\textrm{distance}\\). Developing our rally algebra, we might identify the stage distance for stage \\(S\\) as \\(d_S\\). For a stage time by driver \\(i\\) of \\({_S}t_i\\) the stage pace \\({_S}p_i\\) for driver \\(i\\) on stage \\(S\\) is then given as: \\[ {_S}p_i = \\frac{{_S}t_i}{d_S} \\] 5.3 Calculating Stage Pace We can calculate stage pace from stage times and stage distances. We can find stages distances directly from the stages dataframe: stages %&gt;% select(c(&#39;code&#39;,&#39;distance&#39;)) %&gt;% head(3) ## code distance ## 1 SS1 31.05 ## 2 SS2 31.05 ## 3 SS3 24.43 5.3.1 Calculating Pace for a Single Stage Let’s start by looking a single stage using a recipe we have used before: # Example stage code stage_code = &#39;SS3&#39; stageId = stages_lookup[[stage_code]] # Get the stage distance stage_distance = stages[stages[&#39;code&#39;]==stage_code, &#39;distance&#39;] # Get driver metadata cars = get_car_data(entries) # Create stage times with merged in driver metadata stage_times = get_stage_times(eventId, stageId) %&gt;% arrange(position) %&gt;% head(10) %&gt;% # Merge in the entries data merge(cars, by=&#39;entryId&#39;) %&gt;% # Convert milliseconds to seconds mutate(TimeInS = elapsedDurationMs/1000) %&gt;% # Limit columns and set column order select(c(&#39;position&#39;, &#39;identifier&#39;, &#39;code&#39;, &#39;TimeInS&#39;)) %&gt;% # The merge may upset the row order # so reset the order again arrange(position) %&gt;% # Improve column names by renaming them rename(Pos=position, Car = identifier, Code = code, `Time (s)` = TimeInS) formattable(stage_times ) Pos Car Code Time (s) 1 8 TÄN 834.5 2 11 NEU 835.5 3 2 SOL 839.1 4 69 ROV 840.2 5 42 BRE 841.9 6 1 OGI 842.0 7 18 KAT 843.2 8 7 LOU 844.3 9 33 EVA 845.8 10 3 SUN 846.9 We can now calculate pace as the stage time divided by the stage distance: stage_times$pace = stage_times$&#39;Time (s)&#39; / stage_distance stage_times ## Pos Car Code Time (s) pace ## 1 1 8 TÄN 834.5 34.15882 ## 2 2 11 NEU 835.5 34.19975 ## 3 3 2 SOL 839.1 34.34711 ## 4 4 69 ROV 840.2 34.39214 ## 5 5 42 BRE 841.9 34.46173 ## 6 6 1 OGI 842.0 34.46582 ## 7 7 18 KAT 843.2 34.51494 ## 8 8 7 LOU 844.3 34.55997 ## 9 9 33 EVA 845.8 34.62137 ## 10 10 3 SUN 846.9 34.66639 5.3.2 Calculating Pace for Multiple Stages First, let’s get the data for all the stages: stage_list = get_stage_list(stages) multi_stage_times = get_multi_stage_times(stage_list) multi_stage_times %&gt;% tail(2) ## stageTimeId stageId entryId elapsedDurationMs elapsedDuration status ## 539 96810 1749 21571 1301693 00:21:41.6930000 Completed ## 540 96793 1749 21541 NA &lt;NA&gt; DNS ## source position diffFirstMs diffFirst diffPrevMs diffPrev ## 539 Default 52 699224 00:11:39.2240000 153590 00:02:33.5900000 ## 540 Default NA NA &lt;NA&gt; NA &lt;NA&gt; We can generate the pace by adding the stage distance as an extra column and performing the pace calculation. We’ll also take the opportunity to merge in driver metadata and limit cars to WRC group entries: multi_stage_pace = multi_stage_times %&gt;% merge(stages[,c(&#39;stageId&#39; ,&#39;distance&#39;, &#39;number&#39;, &#39;code&#39;)], by=&#39;stageId&#39;) %&gt;% mutate(elapsedDurationS = elapsedDurationMs / 1000, pace = elapsedDurationS / distance) %&gt;% merge(cars[,c(&#39;entryId&#39;,&#39;drivername&#39;, &#39;code&#39;, &#39;groupname&#39;)], by=&#39;entryId&#39;, suffixes=c(&#39;&#39;,&#39;_driver&#39;)) %&gt;% filter(groupname==&#39;WRC&#39;) %&gt;% select(c(&#39;stageId&#39;, &#39;number&#39;, &#39;code_driver&#39;, &#39;elapsedDurationS&#39;, &#39;pace&#39;, &#39;code&#39;)) %&gt;% arrange(number, elapsedDurationS) multi_stage_pace %&gt;% head(3) ## stageId number code_driver elapsedDurationS pace code ## 1 1747 1 TÄN 957.8 30.84702 SS1 ## 2 1747 1 BRE 961.4 30.96296 SS1 ## 3 1747 1 ROV 968.4 31.18841 SS1 Create a mapping from stage ID to stage codes and cast the ordered list of stage Ids to an ordered list of stage codes: # Create a stage code mapping function stages_lookup_code = get_stages_lookup(stages, &#39;stageId&#39;, &#39;code&#39;) stage_code_map = function(stageId) stages_lookup_code[[as.character(stageId)]] # Map stage ID column names to stage codes stage_codes = unlist(purrr::map(stage_list, function (x) stage_code_map(x))) stage_codes ## [1] &quot;SS1&quot; &quot;SS2&quot; &quot;SS3&quot; &quot;SS4&quot; &quot;SS5&quot; &quot;SS6&quot; &quot;SS7&quot; &quot;SS8&quot; &quot;SS9&quot; &quot;SS10&quot; Use the generic widener function to widen the pace dataframe to give the pace for each driver on each stage: pace_wide = get_multi_stage_generic_wide(multi_stage_pace, stage_codes, &#39;pace&#39;, # Unique group keys required # Driver code not guaranteed unique group_key=c(&#39;code_driver&#39;), spread_key=&#39;code&#39;) pace_wide %&gt;% head(3) ## code_driver SS1 SS2 SS3 SS4 SS5 SS6 SS7 ## 1 BER 32.66345 32.84380 58.71879 57.58915 48.77529 58.83340 57.69965 ## 2 BRE 30.96296 31.09501 34.46173 27.69965 27.33382 34.84241 28.04119 ## 3 EVA 31.38486 31.18196 34.62137 27.45354 27.10260 34.94065 27.75490 ## SS8 SS9 SS10 ## 1 49.27746 28.69159 28.64174 ## 2 28.14668 27.32532 26.82381 ## 3 28.32731 27.03605 27.05955 5.4 Rebasing Stage Pace We can rebase the stage pace according to a specific driver: example_driver = pace_wide[2,]$code_driver pace_wide_rebased = rebase(pace_wide, example_driver, stage_codes, id_col=&#39;code_driver&#39;) pace_wide_rebased %&gt;% head(3) ## code_driver SS1 SS2 SS3 SS4 SS5 SS6 ## 1 BER 1.7004831 1.74879227 24.2570610 29.8895028 21.4414740 23.99099468 ## 2 BRE 0.0000000 0.00000000 0.0000000 0.0000000 0.0000000 0.00000000 ## 3 EVA 0.4219002 0.08695652 0.1596398 -0.2461075 -0.2312139 0.09823987 ## SS7 SS8 SS9 SS10 ## 1 29.6584631 21.1307803 1.3662661 1.8179350 ## 2 0.0000000 0.0000000 0.0000000 0.0000000 ## 3 -0.2862883 0.1806358 -0.2892746 0.2357365 More abstractly, the rebased pace, \\({_S}p_i^j\\), for driver \\(i\\) relative to driver \\(j\\) on stage \\(S\\) is given as: \\[ {_S}p_i^j = {_S}p_i - {_S}p_j = \\frac{{_S}t_i - {_S}t_j}{d_S} = \\frac{{_S}t_i^j}{d_S} \\] 5.5 Visualising Stage Pace Using Pace Maps To compare pace, it is useful to look at rebased pace times relative to a particular driver and also indicate the length of stage with which particular pace levels are associated. We can do this with a chart that presents distance into stage along the horizontal x-axis and relative pace on the y axis, using a line to indicate the pace for each driver relative to a specified driver. One of the easiest way of plotting charts is to plot from a tidy dataframe, so let’s cast the rebased wide pace dataframe back to a long form and also add in the distance into stage at the start and end of each stage: library(tidyr) stage_range = c(start=stage_codes[1], end=stage_codes[length(stage_codes)]) stages$cum_dist = cumsum(stages$distance) stages$start_dist = c(0, stages$cum_dist[-length(stages$cum_dist)]) pace_long = pace_wide_rebased %&gt;% gather(code, pace, stage_range[&#39;start&#39;]:stage_range[&#39;end&#39;]) %&gt;% merge(stages[,c(&#39;code&#39;, &#39;start_dist&#39;, &#39;cum_dist&#39;)], by=&#39;code&#39;) pace_long %&gt;% head(3) ## code code_driver pace start_dist cum_dist ## 1 SS1 BER 1.7004831 0 31.05 ## 2 SS1 BRE 0.0000000 0 31.05 ## 3 SS1 EVA 0.4219002 0 31.05 We can now construct a chart using line segments to represent the pace for each driver on each stage: library(ggplot2) g0 = ggplot(pace_long, aes(group=code_driver)) + geom_hline(yintercept = 0, colour=&#39;lightgrey&#39;, linetype=&#39;dotted&#39;) + geom_segment(aes(x=start_dist, xend=cum_dist, y=pace, yend=pace), color = &#39;lightgrey&#39;) g = g0 + geom_text(aes(x=(start_dist+cum_dist)/2,y=pace+0.03, label=code_driver,group=code_driver), position = position_dodge(15), size=1) + coord_cartesian(ylim=c(-0.5,2)) + theme_classic() g We could highlight positive and negative differences in the label colourings: g0 + geom_text(aes(x=(start_dist+cum_dist)/2, y=ifelse(pace&gt;0,pace+0.03,pace-0.03), label=code_driver,group=code_driver, color=pace&gt;0), position = position_dodge(15), size=1) + coord_cartesian(ylim=c(-0.5,2)) + theme_classic() + theme(legend.position=&quot;none&quot;) We can also highlight values for a particular driver: g + geom_segment(data=pace_long[pace_long$code_driver==&#39;EVA&#39;,], aes(x=start_dist, xend=cum_dist, y=pace, yend=pace, color = pace&gt;0)) + theme(legend.position=&quot;none&quot;) Or abuse the gghiglight package to modify the aesthetics of unselected items: g + gghighlight::gghighlight(code_driver==&#39;EVA&#39;, unhighlighted_params=list(alpha=0.1)) Alternatively, abuse gghighlight() again with a negative form of selection to highlight items: g + gghighlight::gghighlight(code_driver!=&#39;EVA&#39;,label_key=code_driver, unhighlighted_params=list(color=&#39;blue&#39;)) We could even add a transparency layer bar to highlight the pace difference compared to a particular driver: g + geom_rect(data=pace_long[pace_long$code_driver==&#39;EVA&#39;,], aes(xmin=start_dist, xmax=cum_dist, ymin = ifelse(pace&gt;0,0,pace), ymax = ifelse(pace&gt;0,pace,0), fill = pace&gt;0, alpha=0.7)) + theme(legend.position=&quot;none&quot;) Could we perhaps also extend that a little to allow us to compare more drivers? pace_map_highlight = function(sub_df, m, n){ # If we don&#39;t grab the actual value # the referenced value is used... m_ = m geom_rect(data=sub_df, aes(xmin= start_dist + (m_-1) * (cum_dist - start_dist)/n, xmax= start_dist + m_ * (cum_dist - start_dist)/n, ymin = ifelse(pace&gt;0,0,pace), ymax = ifelse(pace&gt;0,pace,0), fill = pace&gt;0, alpha=0.7)) } pace_map_highlight_many = function(df, g, codes){ n = length(codes) for (m in 1:n){ sub_df = df[df$code_driver==codes[m],] g = g + pace_map_highlight(sub_df, m, n) } g } Let’s try it with two drivers: pace_map_highlight_many(pace_long, g, c(&#39;EVA&#39;, &#39;ROV&#39; )) + theme(legend.position=&quot;none&quot;) With multiple drivers, it may get difficult to see where the stages are delimited, so we might add separators to delimit them: g + geom_vline(data = stages, aes(xintercept = cum_dist), color=&#39;lightgrey&#39;, linetype=&#39;dotted&#39;) To highlight stages further, we could add a “banner” to the chart: g + geom_rect(data=pace_long[pace_long$code_driver==example_driver,], aes(xmin=0, xmax=max(cum_dist), ymin = 1.8, ymax = 2.0, alpha=0), fill = &#39;black&#39;) + geom_text(data=pace_long[pace_long$code_driver==example_driver,], aes(x=(cum_dist + start_dist)/2, label=code), y=1.9, color=&#39;yellow&#39;, size=3) + geom_segment(data=pace_long[pace_long$code_driver==example_driver,], aes(x=cum_dist, xend=cum_dist, y=1.8, yend=2.0), color=&#39;yellow&#39;) + theme(legend.position=&quot;none&quot;) 5.6 Off-the-Pace Charts Another way or reviewing pace is to consider the gap to leader, or rebased gap to a particular driver across the stages, using distance into stage along the x-axis to locate the x-value and gap (measured in seconds) along the y-axis. A moment’s consideration suggests that the gradient (\\(\\textrm{change_in_gap}/\\textrm{change_in_distance}\\)) is a measure of pace. The slope of the line thus indicates relative pace between the focal driver and the other drivers. As with the pace map, if we have the data in a long, tidy form, we can create charts from it quite straightforwardly. So let’s add in the accumulated distance into stage and accumulated stage time for each time: off_the_pace = multi_stage_pace %&gt;% merge(stages[,c(&#39;stageId&#39;, &#39;cum_dist&#39;)], by=&#39;stageId&#39;) %&gt;% arrange(number) %&gt;% group_by(code_driver) %&gt;% mutate(totalDurationS = cumsum(elapsedDurationS)) off_the_pace %&gt;% head(3) ## # A tibble: 3 x 8 ## # Groups: code_driver [3] ## stageId number code_driver elapsedDurationS pace code cum_dist ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1747 1 TÄN 958. 30.8 SS1 31.0 ## 2 1747 1 BRE 961. 31.0 SS1 31.0 ## 3 1747 1 ROV 968. 31.2 SS1 31.0 ## # … with 1 more variable: totalDurationS &lt;dbl&gt; Now we can create a basic off-the pace chart: ggplot(off_the_pace, aes(x=cum_dist, y=totalDurationS, color=code_driver)) + geom_line() As with the pace map, the chart is often most informative if we rebase it relative to a particular driver. Let’s create a wide dataframe to simplify the rebasing process: off_the_pace_wide = get_multi_stage_generic_wide(off_the_pace, stage_codes, &#39;totalDurationS&#39;, group_key=c(&#39;code_driver&#39;), spread_key=&#39;code&#39;) off_the_pace_wide %&gt;% head(3) ## code_driver SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 ## 1 BER 1014.2 2034.0 3468.5 4615.1 5965.2 7402.5 8551.3 9915.3 10560.0 ## 2 BRE 961.4 1926.9 2768.8 3320.3 4076.9 4928.1 5486.4 6265.5 6879.5 ## 3 EVA 974.5 1942.7 2788.5 3335.1 4085.3 4938.9 5491.5 6275.6 6883.1 ## SS10 ## 1 11203.580 ## 2 7482.231 ## 3 7491.128 Now we can rebase: off_the_pace_wide_rebased = rebase(off_the_pace_wide, example_driver, stage_codes, id_col=&#39;code_driver&#39;) off_the_pace_wide_rebased %&gt;% head(3) ## code_driver SS1 SS2 SS3 SS4 SS5 SS6 SS7 SS8 SS9 ## 1 BER 52.8 107.1 699.7 1294.8 1888.3 2474.4 3064.9 3649.8 3680.5 ## 2 BRE 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 ## 3 EVA 13.1 15.8 19.7 14.8 8.4 10.8 5.1 10.1 3.6 ## SS10 ## 1 3721.349 ## 2 0.000 ## 3 8.897 And cast back to the long, tidy form: off_the_pace_long = off_the_pace_wide_rebased %&gt;% gather(code, totalDurationGapS, stage_range[&#39;start&#39;]:stage_range[&#39;end&#39;]) %&gt;% merge(stages[,c(&#39;code&#39;, &#39;cum_dist&#39;)], by=&#39;code&#39;) off_the_pace_long %&gt;% head(3) ## code code_driver totalDurationGapS cum_dist ## 1 SS1 BER 52.8 31.05 ## 2 SS1 BRE 0.0 31.05 ## 3 SS1 EVA 13.1 31.05 And now we can plot the simple rebased off-the-pace chart: g_otp = ggplot(off_the_pace_long, aes(x=cum_dist, y=totalDurationGapS, color=code_driver)) + geom_line() + # Retain the points outside the limits # by using coord_cartesian() # We can also flip the coordinate axis coord_cartesian(ylim=c(100, -100)) + theme_classic() g_otp Trivially, we might try to add labels at the end of each line: off_the_pace_end = off_the_pace_long %&gt;% filter(cum_dist == max(cum_dist)) g_otp + geom_text(data = off_the_pace_end, aes(x = cum_dist+ 10, y = totalDurationGapS, label = code_driver, color = code_driver)) + theme(legend.position=&quot;none&quot;) However, there are various other packages that provide alternative ways of doing this, including directlabels and ggrepel. For example, using directlabels: library(directlabels) g_otp + geom_dl(aes(label = code_driver, x=cum_dist+2), # cex is text label size method = list(&#39;last.bumpup&#39;, cex = 0.5)) + theme(legend.position=&quot;none&quot;) And using ggrepel, which also has the advantage of adding labels for drivers who curves are really of the pace, albeit not in an obviously natural order: g_otp + ggrepel::geom_text_repel(data = off_the_pace_end, aes(label = code_driver), size = 3) + theme(legend.position=&quot;none&quot;) The gghighlight package is also useful in highlighting traces, as well as usefully automatically labeling highlighted lines: g_otp + gghighlight::gghighlight(code_driver==&#39;EVA&#39;, unhighlighted_params=list(alpha=0.1)) + theme(legend.position=&quot;none&quot;) ## label_key: code_driver "],["visualising-split-times.html", "6 Visualising Split Times 6.1 Load Base Data 6.2 Get Splits Data 6.3 Rebasing Split Times 6.4 Visualising Rebased Split Times Using Sparklines 6.5 Finding the Rank Position at Each Split Point 6.6 Finding Split Section Durations 6.7 Adding Overall Stage Time to the Split Times", " 6 Visualising Split Times In this chapter we’ll explore some of the ways in which we might visualise the split times on a stage. We can do these either either on a time basis, or we can explore the time differences in terms of pace differences by normalising the split times over split distances. We’ll also see how we can make split time comparisons as gaps relative to a specified driver, rather than the stage winner as well as calculating times to complete each split (that is, the difference between consecutive split times for a particular driver). From the split section times, we can also calculate various derived measures, such as the ultimate possible stage time, based on the sum of fastest times to complete each split section. Having access to split times also sets up the potential for rating the performance of a driver on each split against various stage and stage route metrics, such as road order or route metrics such as the “wiggliness” of the split section, although these will not be covered here. 6.1 Load Base Data To get the splits data from a standing start, we can load in the current season list, select the rally we want, look up the itinerary from the rally, extract the sections and then the stages and the retrieve the stage ID for the stage we are interested in: source(&#39;code/wrc-api.R&#39;) s = get_active_season() eventId = get_eventId_from_name(s, &#39;arctic&#39;) itinerary = get_itinerary(eventId) sections = get_sections(itinerary) stages = get_stages(sections) stages_lookup = get_stages_lookup(stages) # For driver details entries = get_rally_entries(eventId) cars = get_car_data(entries) As a working example, let’s define an example stage by its code: stage_code = &#39;SS3&#39; Get a sample stage ID: stageId = stages_lookup[[stage_code]] 6.2 Get Splits Data We can load the splits data if we know the event and stage ID: splits = get_splits(eventId, stageId) The split times represented the accumulated time going the the stage at each split point. However, the split times do not include the overall stage time, so we need to be mindful that if we want to report on a stage the split times in and of themselves do not contain any information about the final section of the stage between the final split point and the stage finish line. The splits data actually comprises two dataframes. The first is the splits locations: get_split_locations = function(splits){ splits_locations = splits$splitPoints splits_locations } splits_locations = get_split_locations(splits) splits_locations %&gt;% head(2) ## splitPointId stageId number distance ## 1 3593 1750 5 23.21 ## 2 3601 1750 2 9.02 To produce a wide data frame of split times by driver, we need to be able to reference the split codes ordered by the distance into the stage of each split point: get_split_cols = function(splits){ split_cols = as.character(arrange(splits$splitPoints, distance)$splitPointId) split_cols } split_cols = get_split_cols(splits) split_cols ## [1] &quot;3615&quot; &quot;3601&quot; &quot;3621&quot; &quot;3617&quot; &quot;3593&quot; For reference, we can also get the full stage distance from the stages dataframe: stages[stages[&#39;code&#39;]==stage_code, &#39;distance&#39;] ## [1] 24.43 The second dataframe returned from the splits API call contains the splits times, accessed via the get_driver_splits() function defined previously and imported from the wrc-api.R file. The data is returned in a long format, with each row describing a single split time for a particular driver on the single stage the split times were retrieved for. driver_splits = get_driver_splits(splits) driver_splits %&gt;% head(2) ## splitPointTimeId splitPointId entryId elapsedDuration splitDateTime ## 1 123482 3615 21540 PT2M41.4S 2021-02-27T07:10:41.4 ## 2 123483 3601 21540 PT4M32.5S 2021-02-27T07:12:32.5 ## splitDateTimeLocal elapsedDurationS ## 1 2021-02-27T09:10:41.4+02:00 161.4 ## 2 2021-02-27T09:12:32.5+02:00 272.5 6.2.1 Wide Driver Split Times We then cast the the driver split points into a wide format using the split point codes, ordered by split distance into the stage, as the widened column names: get_splits_wide = function(splits){ driver_splits = get_driver_splits(splits) split_cols = get_split_cols(splits) splits_cols = c(&#39;entryId&#39;, &#39;splitPointId&#39;, &#39;elapsedDurationS&#39;) splits_wide = driver_splits %&gt;% group_by(entryId) %&gt;% select(all_of(splits_cols)) %&gt;% tidyr::spread(key = splitPointId, value = elapsedDurationS) %&gt;% select(all_of(c(&#39;entryId&#39;, split_cols))) %&gt;% # If we don&#39;t cast, it&#39;s a # non-rankable rowwise df as.data.frame() splits_wide } Rather than retrieve the split times into a long format, with one row per driver split, we can now retrieve the data into a wide form with one row per driver and a column for each split on the stage: splits_wide = get_splits_wide(splits) splits_wide %&gt;% head(2) ## entryId 3615 3601 3621 3617 3593 ## 1 21530 161.7 272.3 471.3 690.4 789.2 ## 2 21531 162.3 273.7 472.3 692.1 792.4 6.3 Rebasing Split Times The split times describe the split times recorded for each driver, but in many situations we may be interested in knowing the difference in split times for a specific driver relative to every other driver. More formally, for drivers \\(j\\) on stage \\(S\\) and split \\(s\\), we find the rebased stage times relative to driver \\(j\\) as: \\[ {_{S,s}}t_{i}^{j} = {_{S,s}}t_{i} - {_{S,s}}t_{j} \\] although we may want to negate that value depending on the sense of whether we want to focus on times from the selected driver’s perspective, or from the perspective of the field of drivers they are being rebased against. . To calculate the rebased times, we note that the wide dataframe format gives rows containing the split times for each driver, which is to say \\({_{S,*}}t_i\\). To calculate the rebased times, we can simply subtract the row corresponding to the driver we want to rebase relative to, from the other driver rows: #https://stackoverflow.com/a/32267785/454773 rebase = function(df, id, rebase_cols, id_col=&#39;entryId&#39;, base=FALSE, base_id=FALSE) { df_ = df # The rebase values are the ones # we want to subtract from each row rebase_vals = c(df[df[[id_col]]==id, rebase_cols]) # Do the rebasing df_[,rebase_cols] = df[,rebase_cols] - rebase_vals df_[[id_col]] = df[[id_col]] # Return just the rebased and identifier columns or the # whole dataframe cols = rebase_cols if (base_id) cols = c(id_col, cols) if (base) df_ %&gt;% select(cols) else df_ } Let’s try it with an example driver: ogierEntryId = get_person_id(cars, &#39;ogier&#39;, ret=&#39;entryId&#39;) ogier_rebased = rebase(splits_wide, ogierEntryId, split_cols) ogier_rebased %&gt;% head(10) ## entryId 3615 3601 3621 3617 3593 ## 1 21530 0.0 0.0 0.0 0.0 0.0 ## 2 21531 0.6 1.4 1.0 1.7 3.2 ## 3 21532 -2.6 -3.7 -5.5 -7.7 -6.5 ## 4 21533 -2.1 -1.7 -3.0 -3.8 -2.3 ## 5 21534 -0.3 -2.0 -1.5 -0.9 0.7 ## 6 21535 4.1 6.0 8.0 10.0 11.2 ## 7 21536 -4.2 -5.0 -7.5 -9.2 -7.6 ## 8 21537 0.1 2.2 3.0 3.8 5.0 ## 9 21538 -3.3 -2.0 -0.1 -2.0 -0.7 ## 10 21539 1.9 2.8 0.0 -2.1 -2.5 6.4 Visualising Rebased Split Times Using Sparklines If we cast the data back to a tidy long form data, we can easily generate a graphical summary from the long form data: library(tidyr) ogier_rebased_long &lt;- ogier_rebased %&gt;% gather(key =&quot;Split&quot;, value =&quot;TimeInS&quot;, split_cols) ## Note: Using an external vector in selections is ambiguous. ## ℹ Use `all_of(split_cols)` instead of `split_cols` to silence this message. ## ℹ See &lt;https://tidyselect.r-lib.org/reference/faq-external-vector.html&gt;. ## This message is displayed once per session. ogier_rebased_long %&gt;% head(10) ## entryId Split TimeInS ## 1 21530 3615 0.0 ## 2 21531 3615 0.6 ## 3 21532 3615 -2.6 ## 4 21533 3615 -2.1 ## 5 21534 3615 -0.3 ## 6 21535 3615 4.1 ## 7 21536 3615 -4.2 ## 8 21537 3615 0.1 ## 9 21538 3615 -3.3 ## 10 21539 3615 1.9 For example, we can use the sparkline::spk_chr() function to generate an HTML sparkline widget that we can embed in a formattable::formattable() generated table: library(formattable) library(sparkline) ogier_sparkline &lt;- ogier_rebased_long %&gt;% group_by(entryId) %&gt;% summarize(spk_ = spk_chr(TimeInS, type =&quot;bar&quot;)) # We need to create an htmlwidget form of the table out = as.htmlwidget(formattable(head(ogier_sparkline, 5))) # The table also has a requirement on the sparkline package out$dependencies = c(out$dependencies, htmlwidgets:::widget_dependencies(&quot;sparkline&quot;, &quot;sparkline&quot;)) out 6.5 Finding the Rank Position at Each Split Point It can often be tricky to work out the rank at each split by eye, so let’s create a simple function to display the rank at each split for us: get_split_rank = function(df, split_cols){ df %&gt;% mutate(across( split_cols, dense_rank )) } get_split_rank(splits_wide, split_cols) %&gt;% head(5) ## entryId 3615 3601 3621 3617 3593 ## 1 21530 6 5 6 7 6 ## 2 21531 8 7 8 8 9 ## 3 21532 3 2 2 2 2 ## 4 21533 4 4 3 3 4 ## 5 21534 5 3 4 6 7 6.6 Finding Split Section Durations Inspection of the split times data show the split times to be a strictly increasing function over the ordered in-stage split locations. That is, the times represent the time in stage up to that split point, rather than the fractional time taken to get from one split timing point to another. In many cases, it will be convenient to know how much time a driver took to get from one split point to the next, not least because this allows us to identify sections of the stage where a driver may have particularly gained or lost time, or to identify where a driver may be making or losing time consistently across different parts of the stage. In abstract terms, then, what we want to calculate is the time taken for a driver \\(i\\) on stage \\(S\\) to go between two split points, \\(m\\) and \\(n\\), where \\(m=0\\) is the start, \\(m={_S}s_{max}+1\\) is the stage end, and \\({_S}s_{max}\\) is the number of split points on stage \\(S\\): \\[ {_{S,m,n}}t_{i} = {_{S,n}}t_{i} - {_{S,m}}t_{i}: 0{\\le}m&lt;n{\\le}{_S}s_{max} \\] For a specific, known stage, we might write the simpler: \\[ S={stagenum}; {_{m,n}}t_{i} = {_{n}}t_{i} - {_{m}}t_{i}: 0{\\le}m&lt;n{\\le}s_{max} \\] For a driver, i, we note that the accumulated stage time on stage \\(S\\) as given by the split times is: \\[ S={stagenum};t_{i}=\\sum_{s=0}^{s{_{max}}}{_{s,s+1}}t_{i}: \\] To get the duration between two split points, we can create two temporary dataframes, one representing the original split times without the first split \\({_{{s+1},s_{max}}}t\\), one representing the split times without the last split, \\({_{s,s_{max}-1}}t\\). Subtracting one dataframe from the other this finds the difference across all consecutive columns: \\[ {_{{s+1},s_{max}}}t - {_{s,s_{max}-1}}t \\] Let’s see how that works in practice: #https://stackoverflow.com/a/50411529/454773 get_split_duration = function(df, split_cols, retId=TRUE) { # [-1] drops the first column, [-ncol()] drops the last df_ = df[,split_cols][-1] - df[,split_cols][-ncol(df[,split_cols])] # The split time to the first split is simply the first split time df_[split_cols[1]] = df[split_cols[1]] if (retId) { # Add in the entryId column df_$entryId = df$entryId # Return the dataframe in a sensible column order df_ %&gt;% select(c(&#39;entryId&#39;, split_cols)) } else { df_ } } split_durations_wide = get_split_duration(splits_wide, split_cols) split_durations_wide %&gt;% head(5) ## entryId 3615 3601 3621 3617 3593 ## 1 21530 161.7 110.6 199.0 219.1 98.8 ## 2 21531 162.3 111.4 198.6 219.8 100.3 ## 3 21532 159.1 109.5 197.2 216.9 100.0 ## 4 21533 159.6 111.0 197.7 218.3 100.3 ## 5 21534 161.4 108.9 199.5 219.7 100.4 6.6.1 Finding Split Section Ranks To find the rank in terms of which driver completed each stage section in the quickest time, we can simply pass the split_durations_wide dataframe rather than the split_durations dataframe to the get_split_rank() function: get_split_rank(split_durations_wide, split_cols) %&gt;% head(5) ## entryId 3615 3601 3621 3617 3593 ## 1 21530 6 4 6 6 3 ## 2 21531 8 7 5 8 7 ## 3 21532 3 2 3 1 4 ## 4 21533 4 5 4 5 7 ## 5 21534 5 1 8 7 8 6.7 Adding Overall Stage Time to the Split Times It is important to note that the split times data does not contain all the timing data for the stage, just the times relating to split points along the stage route. For a complete summary of stage timing data, we also need to add in the overall stage time from the stage results table: stage_times = get_stage_times(eventId, stageId) stage_times %&gt;% head(2) ## stageTimeId stageId entryId elapsedDurationMs elapsedDuration status ## 1 96580 1750 21536 834500 00:13:54.5000000 Completed ## 2 96474 1750 21532 835500 00:13:55.5000000 Completed ## source position diffFirstMs diffFirst diffPrevMs diffPrev ## 1 Default 1 0 00:00:00 0 00:00:00 ## 2 Default 2 1000 00:00:01 1000 00:00:01 Recall that if required we can also retrieve stage time for multiple stages using the get_multi_stage_times(stagelist) function. The get_stage_list(stages) function will return a list of all stage IDs. If we merge each driver’s stage times as an extra, final column to the wide split times dataframe, we can calculate the split section durations over the whole stage, including the time taken to get from the final split to the stage end: widen_splits_stage_times = function(splits_wide, stage_times){ results_cols = c(&#39;elapsedDurationMs&#39;, &#39;entryId&#39;, &#39;diffFirstMs&#39;, &#39;position&#39;) splits_wide = splits_wide %&gt;% merge(stage_times[,results_cols], by = &#39;entryId&#39;) %&gt;% mutate(elapsedDurationMs = elapsedDurationMs/1000) %&gt;% rename(elapsedDurationS = elapsedDurationMs) splits_wide } splits_wide = widen_splits_stage_times(splits_wide, stage_times) splits_wide %&gt;% head(2) ## entryId 3615 3601 3621 3617 3593 elapsedDurationS diffFirstMs position ## 1 21530 161.7 272.3 471.3 690.4 789.2 842.0 7500 6 ## 2 21531 162.3 273.7 472.3 692.1 792.4 845.8 11300 9 To make further processing easier, we add the overall stage time to the list of split time column names. The “final split” is now the completed stage time: split_cols = get_split_cols(splits) split_cols = c(split_cols, &#39;elapsedDurationS&#39;) "],["finding-pace-across-splits.html", "7 Finding Pace Across Splits 7.1 Load Base Data 7.2 Calculating Splits Pace", " 7 Finding Pace Across Splits We have already seen how we can perform pace calculations on stage level data and use pace maps and off-the-pace charts to visualise pace over the course of a rally. But in WRC rallies at least, the stages are often long enough, and the promoter well resourced enough, to merit the collection of split data data at various split points along a stage. So in this chapter, we’ll review how we can create pace charts and apply the techniques to plotting progress within a stage, across stage splits. 7.1 Load Base Data As ever, load in the helper functions: source(&#39;code/wrc-api.R&#39;) And get the base data: s = get_active_season() eventId = get_eventId_from_name(s, &#39;arctic&#39;) itinerary = get_itinerary(eventId) sections = get_sections(itinerary) stages = get_stages(sections) stages_lookup = get_stages_lookup(stages) # Driver details cars = get_car_data(entries) Get a sample stage ID: stageId = stages_lookup[[&#39;SS3&#39;]] 7.2 Calculating Splits Pace TO DO… "]]
